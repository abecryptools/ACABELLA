{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Attribute-based encryption is a type of public key encryption in which the keys are linked to attributes. It enforces access control on a cryptographic level in a fine-grained fashion. For instance, a person with attributes Department = Research <code>and</code> Auditor = Yes could satisfy an access policy Department = Finance <code>or</code> Auditor = Yes. Both ABE and its multi-authority variant, MA-AE can be used in the Cloud and in medical environments to protect private data. </p> <p><code>ACABELLA</code> is a tool for analyzing the security of ABE schemes. This documentation details the different components of  <code>ACABELLA</code>, how to analyze the security of an ABE scheme and how to look for master key and decryption attacks. <code>ACABELLA</code> is written in Python and uses Sympy as the main dependency.</p> <p>There are three ways of using <code>ACABELLA</code>:</p> <ul> <li>Via the <code>Attack</code> classes, which independently provide methods for finding master key and decryption attacks and analyze the security of an ABE scheme.</li> <li>Via the <code>Analysis</code> class, which prepares batches of attacks and run them on the description of an ABE scheme.</li> <li>Via the <code>Analysis</code> class using the JSON <code>ACABELLA</code> format, which describes the properties of an ABE scheme and particular corruption environments where security is analyzed.</li> </ul> <p>and two main tools:</p> <ul> <li><code>acabella_cmd</code>: A command line tool, based on python, for analyzing the security of ABE schemes based on the <code>ACABELLA</code> JSON format. It provides an easy way to access the different checks and analysis that are implemented in <code>ACABELLA</code>.</li> <li><code>acabella_web</code>: A web interface built with Flask that provides a similar functionality as <code>acabella_cmd</code>. It comes with prefilled forms to help the user to understand the different inputs required for analyzing an ABE scheme.</li> </ul>"},{"location":"#abe-and-ma-abe-schemes","title":"ABE and MA-ABE schemes","text":"<p>ABE can be implemented using different cryptographic primitives. In this work, we focus on pairing-based (MA) - ABE. Typically, the parties involved in ABE are:</p> <ul> <li>Key generation authorities (KGA): They are part of ABE schemes and could appear as Central Authorities   (CAs) in MA-ABE schemes, together with distributed Attribute Authorities (AAs). A KGA typically   generates the master key pair MPK, MSK. They generate secet keys associated to sets of attributes using the master key,   which can be used to decrypt any ciphertext.</li> <li>Users, which can be data consumers (e.g. they can fulfill an access policy with their attributes and have access to sensitive data) or data owners: they encrypt sensitive data using a particular access policy.</li> <li>An storage entity such as the Cloud, where ciphertexts are stored and available to data consumers.</li> </ul> <p>Both ABE and MA-ABE schemes have several security requirements. First, master keys should be hidden in secret keys. Second, a scheme should provide collusion security, that is, users with keys related to attributers shouldn't be able to collude an access sensitive data protected with an access policy that they cannot fulfill independently. Finally, in MA-ABE we assume that the scheme includes the notion of corruption in their security model. That means, that an attacker can corrupt one or more authorities (AAs) in an attack. However, this fact shouldn't give enough power to attack an honest authority. Similarly, we should take into account that in MA-ABE schemes where CA and AAs are involved, different corruption cases could apply which could yield attacks if the respective security model is not well defined.</p> <p><code>ACABELLA</code> automates the verification of different security properties and looks for the existence of attacks in a scheme. It relies on the following analysis frameworks:</p> <ul> <li>The Venema-Alpar cryptanalysis framework [^1]</li> <li>The AC17 framework [^2]</li> <li>The FAEBO property [^3]</li> </ul>"},{"location":"#pair-encodings","title":"Pair encodings","text":"<p>The Venema-Alpar framework [^1] analyzes the security of a scheme according to its pair encoding.  The pair encoding shows what happens in the realm of the exponent. Since we are focusing on pairing-based ABE schemes, keys and ciphertext components exists in two groups:  and . For a pairing  with generator  and , keys and ciphertext components have the following form:</p> <ul> <li>SK  </li> <li>CT ,  </li> </ul> <p>In this case,  and  are the ke and ciphertext encoding of the scheme.  is the master key,  is part of the public key and ,  are random values linked to a keys and ciphertext respectively.</p> <p>More generally, we can see pair encodings as a way of encoding the inputs ,  of a predicate into polynomials made of 3 type of variables:</p> <ul> <li>Common variables, which are shared by the ,  encodings and that are typically designated in ABE as , etc.</li> <li>Specific variables for the encoding of , in ABE typycally designated as , etc.</li> <li>Specific variables for the encding of , in ABE typically designated as , etc.</li> </ul> <p>The input  is related to the ciphertext part and the input  to the key. </p> <p>The common variables , etc. generally appear as , etc. in the system parameters of the scheme and are generated . Further,  appears as part of , which is the MSK of the system and is generated . </p> <p>Encrypting a message using attributes x means generating random numbers , etc. in order to create new terms common or not common with  variables. Then, the message is integrated into the ciphertext with a blinding factor, via the re-randomization of  as . </p> <p>Finally, the exponents in key components consist of variables , etc.  variables and possibly . For  it is possible to combine ciphertext and key encodings in order to retrieve  and consequently the message.</p>"},{"location":"#the-venema-alpar-cryptanalysis-framework","title":"The Venema-Alpar cryptanalysis framework","text":"<p>The Venema-Alpar cryptanalysis framework [^1] extends the pair encodings to MA-ABE schemes and provides a categorization of different possible attacks and different heuristics to  find them. It employs linear approach to the security analysis of ABE schemes. It looks for cases where the master key can be recovered and analyzes in which cases users can collude and decrypt ciphertexts. Finally, it models the notion of corruption for MA-ABE schemes.</p> <p>The security of a scheme depends on the possibility of obtaining  using ciphertext components an a non-authorized secret key. This would mean to obtain  via a linear combination of  and . This approach can also be understood as finding a matrix  where .</p> <p>When describing MA-ABE schemes in <code>ACABELLA</code>, we rely on the pair encodings extended by the Venema-Alpar cryptanalysis framework:</p> <ul> <li>Global parameter encoding: or gp, which consist of common variables .</li> <li>Master attribute-key encoding: or , consisting of integers  and encodings .</li> <li>User key encoding or , represented by  for user-specific random integers .</li> <li>Attribute-independent ciphertext encodings: consisting of  for ciphertext-specific random .</li> </ul>"},{"location":"#the-ac17-analysis-framework","title":"The AC17 analysis framework","text":"<p>The AC17 analysis framework [^2] studies the exponent space of the schemes (pair encodings) and relate it to security notions. It shows that fully secure schemes can be constructed from pair encodings that are provably symbolically secure. </p> <p>In the AC17 framework, Agrawal and Chase propose the symbolic security property for pair encodings and show that every predicated encryption scheme (that is, ABE included) that is not trivially broken should satisfy it.</p>"},{"location":"#the-symbolic-property","title":"The symbolic property","text":"<p>If the pair encodings have this property, it means that it is possibe lo describe a mapping from the encoding variables to matrices and vectors. We should see that the polynomials in the encoding are evaluated to 0 when the variables are replaced. These matrices and vectors are generated by three deterministic algorithms in AC17:</p> <ul> <li><code>EncB</code> generates matrices for common variables.</li> <li><code>EncS</code> generates vectors for ciphertext encoding variables.</li> <li><code>EncR</code> generates vectors for key encoding variables.</li> </ul> <p>These entries are generated according to the type of security property we want to prove:</p> <ul> <li><code>Selective property</code>: The three algorithms receive , <code>EncR</code> receives .</li> <li><code>Co-selective property</code>: The three algorithms receive , <code>EncS</code> receives .</li> </ul>"},{"location":"#the-trivially-broken-property","title":"The trivially broken property","text":"<p>This property means that there exist a way of combining the encoding polynomials in order to recover the blinding factor  for a particular message  with a false predicate.</p> <p>We can see this property from predicated-based encryption as a way of recovering  via a matrix , for inputs  that make  where . </p>"},{"location":"#the-fabeo-property","title":"The FABEO property","text":"<p>In [^3], the authors extend the symbolic property of [^2] in order to support many-ciphertext CPA security. Hence, the new property, <code>Strong Symbolic Security</code> includes:</p> <ul> <li>Many secret keys, ciphertexts and the public key.</li> <li>The adversay may ask for the same  multiple times.</li> </ul>"},{"location":"#references","title":"References","text":"<p>[^1]: Marloes Venema and Greg Alp\u00e1r. A bunch of broken schemes: A simple yet powerful linear approach to analyzing security of attribute-based encryption. In Kenneth G. Paterson, editor, Topics in Cryptology - CT-RSA 2021 - Cryptographers' Track at the RSA Conference 2021, Virtual Event, May 17-20, 2021, Proceedings, volume 12704 of Lecture Notes in Computer Science, 100\u2013125. Springer, 2021. URL: https://doi.org/10.1007/978-3-030-75539-3\\_5, doi:10.1007/978-3-030-75539-3\\_5. [^2]: Shashank Agrawal and Melissa Chase. Simplifying design and analysis of complex predicate encryption schemes. In Jean-S\u00e9bastien Coron and Jesper Buus Nielsen, editors, Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part I, volume 10210 of Lecture Notes in Computer Science, 627\u2013656. 2017. URL: https://doi.org/10.1007/978-3-319-56620-7\\_22, doi:10.1007/978-3-319-56620-7\\_22. [^3]: Doreen Riepel and Hoeteck Wee. Fabeo: fast attribute-based encryption with optimal security. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS '22, 2491\u20132504. New York, NY, USA, 2022. Association for Computing Machinery. URL: https://doi.org/10.1145/3548606.3560699, doi:10.1145/3548606.3560699.</p>"},{"location":"abgw/","title":"Bridge to the ABGW17 analyzer","text":"<p>In [ABGW17], the authors provided a tool for analyzing the security of ABE schemes within the context of the group generic model. In ACABELLA, we provide a bridge to obtain an output that can be analyzed with the ABGW tool.</p> <p>The bridge is composed of two modules:</p> <ol> <li>A command line tool: Located at <code>tools/abgw_bridge</code>, it receives a description of an ABE scheme written in JSON, for instance, for the YJR13 scheme:</li> </ol> <pre><code>{\n    \"scheme_id\": \"yjr13\",\n    \"analysis\": \"abgw\",\n    \"k\": [\"a * (1 / x1) + x2 * b + r * (b / bp)\", \"r * bp * (1 / x1)\", \"r * b\"],\n    \"c\": [\"s\", \"s / bp\"],\n    \"mpk\": [\"bp\"],\n    \"gp\": [\"b\"],\n    \"key\" : \"a * s\",\n    \"unknown_vars\" :  [\"a\", \"r\", \"s\", \"b\", \"bp\"],\n    \"known_vars\" : [\"x1\", \"x2\"]\n}\n</code></pre> <p>It can be used to obtain the corresponding input for ABGW, for instance:</p> <pre><code>$ python abgw_bridge_cmd.py example.json \n[*] ABGW bridge cmd tool\n[!] Processing example.json\n\nparams c1,c2,c3,c4,c5,c6 in Zp.\nvars a,r,s,b,bp in Zp.\nparams x1,x2 in Zp.\n\n\nc1*(a*s/x1 + b*s*x2 + b*r*s/bp) +\nc2*(a*s/(bp*x1) + b*s*x2/bp + b*r*s/bp*bp) +\nc3*(bp*r*s/x1) +\nc4*(r*s/x1) +\nc5*(b*r*s) +\nc6*(b*r*s/bp)\n= a * s.\n\ngo.\n</code></pre> <ol> <li>A dockerized version of the ABGW tool. Located at <code>tools/abgw_docker</code>, it invokes the ABGW tool with ABE schemes defined in the <code>solver_inputs</code> directory. Note that the <code>build_and_run.sh</code> script compiles the image defined in the docker file and launch a container image where ABGW is executed.</li> </ol> <p>For instance:</p> <pre><code>$ ./build_and_run.sh               \nSending build context to Docker daemon  48.13kB\nStep 1/27 : FROM ubuntu:16.04\n ---&gt; b6f507652425\nStep 2/27 : RUN apt update -y\n ---&gt; Using cache\n ---&gt; 1688783f3dcc\nStep 3/27 : RUN ln -fs /usr/share/zoneinfo/America/New_York /etc/localtime\n ---&gt; Using cache\n ---&gt; 0dbe43f37870\nStep 4/27 : RUN apt-get install -y tzdata\n ---&gt; Using cache\n ---&gt; e3f3790737f4\nStep 5/27 : RUN dpkg-reconfigure --frontend noninteractive tzdata\n ---&gt; Using cache\n ---&gt; e6d34b8176ad\nStep 6/27 : RUN apt-get --assume-yes install software-properties-common\n ---&gt; Using cache\n ---&gt; 9ed00e1180b3\nStep 7/27 : RUN echo \"export GGM_PATH=/root/ggm-symbolic-solver\" &gt;&gt; /etc/bash.bashrc\n ---&gt; Using cache\n ---&gt; c09a02d4d6f1\nStep 8/27 : RUN apt install git vim build-essential sudo python3-dev wget flex bison python3-pip libssl-dev libgmp10 libgmp-dev git openssl -y\n ---&gt; Using cache\n ---&gt; 0107f2df09fb\nStep 9/27 : RUN apt-get install -y curl ocaml ocaml-native-compilers opam libtool libtool-bin libgmp-dev libffi-dev m4 libz-dev libssl-dev camlp4-extra\n ---&gt; Using cache\n ---&gt; 629689e6d19b\nStep 10/27 : WORKDIR /root\n ---&gt; Using cache\n ---&gt; d79f0bee8e6f\nStep 11/27 : RUN git clone https://github.com/miguel-ambrona/ggm-symbolic-solver\n ---&gt; Using cache\n ---&gt; 1a87191dcd28\nStep 12/27 : WORKDIR /root/ggm-symbolic-solver\n ---&gt; Using cache\n ---&gt; d9117f162a43\nStep 13/27 : RUN opam init --yes\n ---&gt; Using cache\n ---&gt; ea83d8958f44\nStep 14/27 : RUN eval `opam config env`\n ---&gt; Using cache\n ---&gt; 3744bac4bc53\nStep 15/27 : RUN opam pin add symbolic-solver . -n --yes\n ---&gt; Using cache\n ---&gt; 57ee5bb1a57a\nStep 16/27 : RUN opam install symbolic-solver --deps-only --yes\n ---&gt; Using cache\n ---&gt; d151dd1a053f\nStep 17/27 : RUN export GGM_PATH=/root/ggm-symbolic-solver/\n ---&gt; Using cache\n ---&gt; fc1963909dd5\nStep 18/27 : RUN apt-add-repository -y ppa:aims/sagemath\n ---&gt; Using cache\n ---&gt; d74a3b71a915\nStep 19/27 : RUN apt-get update -y\n ---&gt; Using cache\n ---&gt; e66d9de8839d\nStep 20/27 : RUN apt-get --assume-yes install sagemath-upstream-binary\n ---&gt; Using cache\n ---&gt; 0dc912223b53\nStep 21/27 : COPY ggm_setup.sh/ .\n ---&gt; Using cache\n ---&gt; 54581c89d3eb\nStep 22/27 : RUN chmod +x ggm_setup.sh\n ---&gt; Using cache\n ---&gt; 99be81b5d1b0\nStep 23/27 : RUN ./ggm_setup.sh\n ---&gt; Using cache\n ---&gt; 2caff98e273d\nStep 24/27 : RUN rm -rf examples/*\n ---&gt; Using cache\n ---&gt; ff8f9b8c477b\nStep 25/27 : COPY solver_inputs/* examples/\n ---&gt; Using cache\n ---&gt; 4df8886f035e\nStep 26/27 : COPY changes/* .\n ---&gt; Using cache\n ---&gt; c62e8b35a2c7\nStep 27/27 : CMD [\"/bin/bash\"]\n ---&gt; Using cache\n ---&gt; eb18b1849e3d\nSuccessfully built eb18b1849e3d\nSuccessfully tagged abeattacks:latest\n\n\n[*] Now run run_examples.py\n\nroot@5f232cb06e7c:~/ggm-symbolic-solver# \nroot@5f232cb06e7c:~/ggm-symbolic-solver# ./run_examples.py \n\nInitialized solver!\n\n./examples/cp_abe_ndcw15.ggm  Complete output:\n\\begin{aligned} &amp; \\text{sets:} &amp;&amp; \\emptyset\\\\ &amp; \\text{parameters:} &amp;&amp; \\color{#ccee77}{d_{1}}, \\color{#ccee77}{d_{2}}, \\color{#ccee77}{d_{3}}, \\color{#ccee77}{c_{1}}, \\color{#ccee77}{c_{2}}, \\color{#ccee77}{c_{3}}, \\color{#ccee77}{c_{4}}, \\color{#ccee77}{c_{5}}, \\color{#ccee77}{c_{6}}, \\color{#ccee77}{c_{7}}, \\color{#ccee77}{c_{8}}, \\color{#ccee77}{c_{9}}, \\color{#ccee77}{c_{10}}, \\color{#ccee77}{c_{11}}, \\color{#ccee77}{c_{12}} \\in \\mathbb{Z}_p^{} \\\\  &amp; \\text{variables:} &amp;&amp; \\color{#dd83f9}{a}, \\color{#dd83f9}{b_{1}}, \\color{#dd83f9}{b_{2}}, \\color{#dd83f9}{s} \\in \\mathbb{Z}_p^{} \\\\  \\\\ &amp; \\text{goal }1 \\text{ out of } 1 \\end{aligned}@\\begin{aligned}(1) \\  &amp; \\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}} +  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} +  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (2) \\  &amp;  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}} +  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} +  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (3) \\  &amp;  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}} +  20  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} +  20  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (4) \\  &amp;  20  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}} +  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} +  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (5) \\  &amp;  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}} +  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} +  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (6) \\  &amp;  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}} + \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} + \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (7) \\  &amp; \\color{#ccee77}{c_{5}}\\color{#ccee77}{d_{1}} + \\color{#ccee77}{c_{7}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (8) \\  &amp; \\color{#ccee77}{c_{8}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (9) \\  &amp; \\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (10) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (11) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (12) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (13) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (14) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (15) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}=0&amp; &amp; \\land \\\\ (16) \\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}=0&amp; &amp; \\land \\\\ (17) \\  &amp; \\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}} +  6  \\ \\color{#ccee77}{d_{3}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}} +  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}} +  20  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}} +  15  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#dd83f9}{b_{1}}\\color{#dd83f9}{b_{1}} +  6  \\ \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#dd83f9}{b_{1}} + \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\neq0 \\\\  &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{1}}\\mapsto \\color{#ccee77}{d_{3}} &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{2}}\\mapsto  1  &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{2}}\\mapsto \\left( -1 \\right)\\color{#ccee77}{c_{6}}\\color{#ccee77}{d_{1}} + \\left( -6 \\right)\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}} &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{3}}\\mapsto 0 \\\\  &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{8}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{4}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{c_{9}}\\color{#ccee77}{d_{1}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\color{#ccee77}{d_{3}}\\mapsto 0\\end{aligned}\n\nNot proven        Time: 2.043\n./examples/cp_abe_yjr13.ggm   Complete output:\n\\begin{aligned} &amp; \\text{sets:} &amp;&amp; \\emptyset\\\\ &amp; \\text{parameters:} &amp;&amp; \\color{#ccee77}{c_{1}}, \\color{#ccee77}{c_{2}}, \\color{#ccee77}{c_{3}}, \\color{#ccee77}{c_{4}}, \\color{#ccee77}{c_{5}}, \\color{#ccee77}{c_{6}}, \\color{#ccee77}{x_{1}}, \\color{#ccee77}{x_{2}} \\in \\mathbb{Z}_p^{} \\\\  &amp; \\text{variables:} &amp;&amp; \\color{#dd83f9}{a}, \\color{#dd83f9}{r}, \\color{#dd83f9}{s}, \\color{#dd83f9}{b}, \\color{#dd83f9}{bp} \\in \\mathbb{Z}_p^{} \\\\  \\\\ &amp; \\text{goal }1 \\text{ out of } 1 \\end{aligned}@\\begin{aligned}(1) \\  &amp; \\color{#ccee77}{c_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}} + \\left( -1 \\right)\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}=0&amp; &amp; \\land \\\\ (2) \\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}} + \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{6}}=0&amp; &amp; \\land \\\\ (3) \\  &amp; \\color{#ccee77}{c_{2}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}=0&amp; &amp; \\land \\\\ (4) \\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{3}}\\color{#ccee77}{x_{1}}=0&amp; &amp; \\land \\\\ (5) \\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{4}}=0&amp; &amp; \\land \\\\ (6) \\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{5}}=0&amp; &amp; \\land \\\\ (7) \\  &amp; \\color{#ccee77}{c_{2}}\\color{#ccee77}{x_{2}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}=0&amp; &amp; \\land \\\\ (8) \\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{1}}\\color{#ccee77}{x_{2}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}=0&amp; &amp; \\land \\\\ (9) \\  &amp; \\color{#ccee77}{x_{1}}\\neq0&amp; &amp; \\land \\\\ (10) \\  &amp; \\color{#dd83f9}{bp}\\neq0 \\\\  \\\\  &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{2}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{3}}\\color{#ccee77}{x_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{4}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{5}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{c_{2}}\\color{#ccee77}{x_{2}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\mapsto 0 &amp; &amp; \\\\  &amp; \\color{#ccee77}{x_{1}}\\color{#ccee77}{c_{1}}\\color{#ccee77}{x_{2}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\color{#ccee77}{x_{1}}\\mapsto 0\\end{aligned}\n\nNot proven        Time: 0.037\nroot@5f232cb06e7c:~/ggm-symbolic-solver# \n</code></pre>"},{"location":"ac17/","title":"Analyzing the security of ABE schemes using ACABELLA","text":"<p>In this part of the documentation, we show how to analyze the security of ABE schemes using the <code>SecurityAttack</code> class and also, using the acabella command line tool.</p> <p>The <code>SecurityAttack</code> class (and the <code>Analysis</code> class, when using the security analysis part) performs the following checks:</p> <ul> <li>It validates whether the scheme satisfies the AC17 form or not.</li> <li>It checks if the scheme is trivially and collusion secure.</li> <li>For secure schemes, it finds a proof for the symbolic property (in the AC17 framework).</li> <li>It validates whether the ABE scheme sastisfies the FABEO property or not.</li> </ul> <p>Using the analysis report, the practitioner can look further into the possiblity of attacking the scheme via master key attacks and decryption attacks, as we explain in the next sections.</p>"},{"location":"ac17/#example-analyzing-a-secure-scheme","title":"Example: analyzing a secure scheme","text":"<p>We'll analyze the security of the RW13 ABE scheme using the SecurityAttack class. First, we need to declare the encodings of the scheme as Sympy symbols and create lists of encodings for each type, e.g., key encodings, ciphertext encodings, MPK encodings, etc. We also need to identify the unknown variables of the scheme:</p> <pre><code>    alpha, b, bp, b0, b1, r, rp, rp2, x, y, z, s, sp, sp2, v2 = symbols('alpha, b, bp, b0, b1, r, rp, rp2, x, y, z, s, sp, sp2, v2')\n\n    k1 = alpha + r*b\n    k2 = r*bp + rp*(b0 + y*b1)\n    k3 = r\n    k4 = rp\n    k5 = r*bp + rp2*(b0 + z*b1)\n    k6 = rp2\n    c1 = (s-v2)*b + sp*bp\n    c2 = sp*(b0 + x*b1)\n    c3 = s\n    c4 = sp\n    c5 = v2*b + sp2*bp\n    c6 = sp2*(b0 + z*b1)\n    c7 = sp2\n    mpk1 = b0\n    mpk2 = b1\n    mpk3 = b\n    mpk4 = bp\n\n    # known values: x, y\n\n    unknown = [alpha, b, b0, b1, bp, r, rp, rp2, s, sp, sp2, v2]\n\n    k = [k1, k2, k3, k4, k5, k6]\n    c = [c1, c2, c3, c4, c5, c6, c7]\n    mpk = [mpk1, mpk2, mpk3, mpk4]\n</code></pre> <p>Then, we create a SecurityAttack() element and initialize it with the description of alpha, s, the blinding factor and the encodings. The fourth parameter is related to the type of scheme we are dealing with, and if this scheme is fractional or not:</p> <pre><code>    security_attack = SecurityAttack()\n    security_attack.init(alpha*s, k, c, mpk, unknown)\n    security_attack.run()\n    print(\"\\n[*] Security analysis results:\\n\")\n    print(\"\\n\" + security_attack.show_solution())\n    security_attack.show_proof()\n</code></pre> <p>It produces the following analysis report:</p> <pre><code>\n[*] Security analysis results:\n\n\nSee the analysis report below. If the scheme is MA-ABE you might try to run this check with corruption.\n\n\n The pair encoding scheme satisfies the AC17 form. The ciphertext encoding previously contained non-lone variables that act as lone variables. These have now been replaced by lone variables.\n\n\n Performing security analysis on the following encodings:\n\n                MPK encodings:                  [b0, b1, b, bp]\n\n                Key encodings:                  [alpha + b*r, b0*rp + b1*rp*y + bp*r, r, rp, b0*rp2 + b1*rp2*z + bp*r, rp2]\n\n                Ciphertext encodings:   [b*s + bp*sp - v2, b0*sp + b1*sp*x, s, sp, bp*sp2 + v2, b0*sp2 + b1*sp2*z, sp2]\n\n\n == Performing simple trivial security check.. ==\n\n         Passed! The security of the scheme depends on whether at least one of the following assumption(s) holds:\n\n                 (1) x - z != 0\n\n == Performing collusion security checks.. ==\n\n\n         The scheme satisfies our collusion property and is thus secure against collusion. \n\n         The scheme satisfies the FABEO property and is thus secure against collusion. \n\n         Generating transcript that proves that the FABEO property holds..\n                 For the transcript, we use the following reference vector of monomials: \n                        [r*v2, b*r*s, bp*r*sp, b0*r*sp, b1*r*sp, bp*r*sp2, b0*r*sp2, b1*r*sp2, rp*v2, b*rp*s, bp*rp*sp, b0*rp*sp, b1*rp*sp, bp*rp*sp2, b0*rp*sp2, b1*rp*sp2, rp2*v2, b*rp2*s, bp*rp2*sp, b0*rp2*sp, b1*rp2*sp, bp*rp2*sp2, b0*rp2*sp2, b1*rp2*sp2, alpha*s, b0*rp*s, bp*r*s, b1*rp*s, b0*rp2*s, b1*rp2*s, alpha*sp, b*r*sp, alpha*sp2, b*r*sp2]\n\n                 The vector with 1 in the entry corresponding to alpha*s and 0 in the entries corresponding to alpha*sp,alpha*sp2 is: \n                        [0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, -x/(x - y), 1/(x - y), 0, 0, 0, 0, 0, 0, -x/(x - z), 1/(x - z), 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n                 The vector with 1 in the entry corresponding to alpha*sp and 0 in the entries corresponding to alpha*s,alpha*sp2 is: \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0]\n\n                 The vector with 1 in the entry corresponding to alpha*sp2 and 0 in the entries corresponding to alpha*s,alpha*sp is: \n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1]\n\n== Generating a security proof for the following encodings: ==\n\n                MPK encodings:                  [b0, b1, b, bp]\n\n                Key encodings:                  [alpha + b*r, b0*rp + b1*rp*y + bp*r, r, rp, b0*rp2 + b1*rp2*z + bp*r, rp2]\n\n                Ciphertext encodings:   [b*s + bp*sp - v2, b0*sp + b1*sp*x, s, sp, bp*sp2 + v2, b0*sp2 + b1*sp2*z, sp2]\n\n\n The selective proof: \n\n\u239b                                                                                    \n\u239c                                                                                    \n\u239c\u23a1\u239b    \u23a10  0   0  0 \u23a4\u239e  \u239b    \u23a10  0  0  0\u23a4\u239e  \u239b   \u23a1-1  0  -1  0\u23a4\u239e  \u239b    \u23a10  0  0  0\u23a4\u239e\u23a4 \n\u239c\u23a2\u239c    \u23a2            \u23a5\u239f  \u239c    \u23a2          \u23a5\u239f  \u239c   \u23a2            \u23a5\u239f  \u239c    \u23a2          \u23a5\u239f\u23a5 \n\u239c\u23a2\u239cb\u2080, \u23a20  -x  0  0 \u23a5\u239f, \u239cb\u2081, \u23a20  1  0  0\u23a5\u239f, \u239cb, \u23a20   0  0   0\u23a5\u239f, \u239cbp, \u23a21  0  0  0\u23a5\u239f\u23a5,\n\u239c\u23a2\u239c    \u23a2            \u23a5\u239f  \u239c    \u23a2          \u23a5\u239f  \u239c   \u23a2            \u23a5\u239f  \u239c    \u23a2          \u23a5\u239f\u23a5 \n\u239c\u23a3\u239d    \u23a30  0   0  -z\u23a6\u23a0  \u239d    \u23a30  0  0  1\u23a6\u23a0  \u239d   \u23a30   0  0   0\u23a6\u23a0  \u239d    \u23a30  0  1  0\u23a6\u23a0\u23a6 \n\u239c                                                                                    \n\u239d                                                                                    \n\n                                                                             \u23a1       \n                                                                             \u23a2\u239b   \u23a11\u23a4\n                                                                             \u23a2\u239c   \u23a2 \u23a5\n                                                                             \u23a2\u239c   \u23a20\u23a5\n [(s, [1  0  0]), (sp, [0  1  0]), (sp\u2082, [0  0  1])], [(v\u2082, [0  0  -1  0])], \u23a2\u239cr, \u23a2 \u23a5\n                                                                             \u23a2\u239c   \u23a20\u23a5\n                                                                             \u23a2\u239c   \u23a2 \u23a5\n                                                                             \u23a2\u239d   \u23a30\u23a6\n                                                                             \u23a3       \n\n   \u239b    \u23a1  0  \u23a4\u239e  \u239b     \u23a1  0  \u23a4\u239e\u23a4            \u239e\n\u239e  \u239c    \u23a2     \u23a5\u239f  \u239c     \u23a2     \u23a5\u239f\u23a5            \u239f\n\u239f  \u239c    \u23a2  1  \u23a5\u239f  \u239c     \u23a2  1  \u23a5\u239f\u23a5  \u23a1\u239b   \u23a11\u23a4\u239e\u23a4\u239f\n\u239f  \u239c    \u23a2\u2500\u2500\u2500\u2500\u2500\u23a5\u239f  \u239c     \u23a2\u2500\u2500\u2500\u2500\u2500\u23a5\u239f\u23a5  \u23a2\u239c   \u23a2 \u23a5\u239f\u23a5\u239f\n\u239f, \u239crp, \u23a2x - y\u23a5\u239f, \u239crp\u2082, \u23a2x - z\u23a5\u239f\u23a5, \u23a2\u239c\u03b1, \u23a20\u23a5\u239f\u23a5\u239f\n\u239f  \u239c    \u23a2     \u23a5\u239f  \u239c     \u23a2     \u23a5\u239f\u23a5  \u23a2\u239c   \u23a2 \u23a5\u239f\u23a5\u239f\n\u239f  \u239c    \u23a2  0  \u23a5\u239f  \u239c     \u23a2  0  \u23a5\u239f\u23a5  \u23a3\u239d   \u23a30\u23a6\u23a0\u23a6\u239f\n\u23a0  \u239c    \u23a2     \u23a5\u239f  \u239c     \u23a2     \u23a5\u239f\u23a5            \u239f\n   \u239d    \u23a3  0  \u23a6\u23a0  \u239d     \u23a3  0  \u23a6\u23a0\u23a6            \u23a0\n\n\n The selective proof verifies correctly. \n\n\n The co-selective proof: \n\n\u239b\u23a1\u239b    \u23a10  0   0\u23a4\u239e  \u239b    \u23a10  0  0\u23a4\u239e  \u239b   \u23a11  0  0\u23a4\u239e  \u239b    \u23a10   0  0\u23a4\u239e\u23a4               \n\u239c\u23a2\u239c    \u23a2        \u23a5\u239f  \u239c    \u23a2       \u23a5\u239f  \u239c   \u23a2       \u23a5\u239f  \u239c    \u23a2        \u23a5\u239f\u23a5               \n\u239c\u23a2\u239c    \u23a20  -y  0\u23a5\u239f  \u239c    \u23a20  1  0\u23a5\u239f  \u239c   \u23a20  0  0\u23a5\u239f  \u239c    \u23a20   0  0\u23a5\u239f\u23a5  \u23a1            \n\u239c\u23a2\u239cb\u2080, \u23a2        \u23a5\u239f, \u239cb\u2081, \u23a2       \u23a5\u239f, \u239cb, \u23a2       \u23a5\u239f, \u239cbp, \u23a2        \u23a5\u239f\u23a5, \u23a2(s, [1  0  0\n\u239c\u23a2\u239c    \u23a20  1   1\u23a5\u239f  \u239c    \u23a20  0  0\u23a5\u239f  \u239c   \u23a20  0  0\u23a5\u239f  \u239c    \u23a2-1  0  0\u23a5\u239f\u23a5  \u23a3            \n\u239c\u23a2\u239c    \u23a2        \u23a5\u239f  \u239c    \u23a2       \u23a5\u239f  \u239c   \u23a2       \u23a5\u239f  \u239c    \u23a2        \u23a5\u239f\u23a5               \n\u239d\u23a3\u239d    \u23a30  z   0\u23a6\u23a0  \u239d    \u23a30  0  1\u23a6\u23a0  \u239d   \u23a30  0  0\u23a6\u23a0  \u239d    \u23a3-z  0  0\u23a6\u23a0\u23a6               \n\n\n                                                                                \u23a1\u239b   \n       \u239b    \u23a1    -1      x     -1  \u23a4\u239e                     \u23a4                     \u23a2\u239c   \n  0]), \u239csp, \u23a20  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u23a5\u239f, (sp\u2082, [0  0  0  0])\u23a5, [(v\u2082, [0  0  0])], \u23a2\u239cr, \n       \u239d    \u23a3   x - y  x - z  x - z\u23a6\u23a0                     \u23a6                     \u23a2\u239c   \n                                                                                \u23a3\u239d   \n\n\n                                 \u23a1\u239b   \u23a11\u23a4\u239e\u23a4\u239e\n\u23a1-1\u23a4\u239e  \u239b    \u23a10 \u23a4\u239e  \u239b     \u23a10 \u23a4\u239e\u23a4  \u23a2\u239c   \u23a2 \u23a5\u239f\u23a5\u239f\n\u23a2  \u23a5\u239f  \u239c    \u23a2  \u23a5\u239f  \u239c     \u23a2  \u23a5\u239f\u23a5  \u23a2\u239c   \u23a20\u23a5\u239f\u23a5\u239f\n\u23a20 \u23a5\u239f, \u239crp, \u23a2-1\u23a5\u239f, \u239crp\u2082, \u23a20 \u23a5\u239f\u23a5, \u23a2\u239c\u03b1, \u23a2 \u23a5\u239f\u23a5\u239f\n\u23a2  \u23a5\u239f  \u239c    \u23a2  \u23a5\u239f  \u239c     \u23a2  \u23a5\u239f\u23a5  \u23a2\u239c   \u23a20\u23a5\u239f\u23a5\u239f\n\u23a30 \u23a6\u23a0  \u239d    \u23a30 \u23a6\u23a0  \u239d     \u23a3-1\u23a6\u23a0\u23a6  \u23a2\u239c   \u23a2 \u23a5\u239f\u23a5\u239f\n                                 \u23a3\u239d   \u23a30\u23a6\u23a0\u23a6\u23a0\n\n\n The co-selective proof verifies correctly. \n</code></pre>"},{"location":"ac17/#example-analyzing-an-insecure-scheme","title":"Example: analyzing an insecure scheme","text":"<p>In this example, we'll analyze an insecure scheme, namely the NDCW15 scheme, which can be attacked via a decryption attack (which we show in the next section).</p> <p>First, we'll prepare a JSON file including the definition of the scheme, that is, the description of alpha, s, the blinding factor and the respective encodings and unknown variables:</p> <pre><code>{\n    \"scheme_id\": \"ndcw15\",\n    \"analysis\": \"security\",\n    \"k\": [\"alpha * (1 / (b1 + x3)) + x2 * b2 * (1 / (b1 + x3))\", \"x1\", \"x1 * b1\"],\n    \"c\": [\"s\", \"s * b1\", \"s * b2\"],\n    \"mpk\": [],\n    \"key\" : \"alpha * s\",\n    \"unknown_vars\" :  [\"alpha\", \"b1\", \"b2\", \"s\"],\n    \"corruptable_vars\": []\n}\n</code></pre> <p>We then can run ACABELLA and obtain the following analysis report, which finds that the scheme is trivially broken:</p> <p>Note</p> <p>The respective JSON files, and others, for the NDCW15 scheme are included in the current ACABELLA distribution.</p> <pre><code>$ python acabella_cmd.py -a sec -c examples/ndcw15/ndcw15_analysis_config.json\n[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Security analysis results:\n\n\nSee the analysis report below. If the scheme is MA-ABE you might try to run this check with corruption.\n\n                MPK encodings:                  []\n\n                Key encodings:                  [alpha/(b1 + x3) + b2*x2/(b1 + x3), x1, b1*x1]\n\n                Ciphertext encodings:   [s, b1*s, b2*s]\n\n\n == Performing simple trivial security check.. ==\n\n                 (1)  c0*(-x2/x3**2) = d0\n                 (2)  c0*(x2/x3) = d1\n                 (3)  d0*(x3) + d1*1 != 0\n\n         where c0,d0,d1 denote the coefficients, then the scheme is trivially secure.\n\n         The scheme may not be trivially secure, because no solution could be found.\n\n == Performing collusion security check.. ==\n\n         Attempting to compute transcript to trivial and collusion security..\n\n         The system could not find a transcript.\n\n         If there exists a solution for the previous system of equations such that the following system of equations holds:\n\n\n         then the scheme is secure against collusion. If not, then the scheme may be vulnerable to a collusion attack.\n</code></pre>"},{"location":"corruption/","title":"About corruption in master and decryption key attacks","text":""},{"location":"corruption/#internal-structures-for-keeping-track-of-corruption-attacks","title":"Internal structures for keeping track of corruption attacks","text":"<ul> <li><code>corruption_map</code>: Updated via <code>add_corruptable_var</code>, it keeps entries of name, origin pairs, being the origin a type of corupted variable in the <code>MasterKeyCorruptedVariable</code> enumeration.</li> </ul>"},{"location":"corruption/#utilization-of-corruption-based-methods-in-master-key-attacks","title":"Utilization of corruption-based methods in master key attacks","text":"<p>In order to use the master key class for utilizing corruption, the following steps should be followed:</p> <ol> <li>Define the parameters and initialize the attack based on master key to recover and  unknown variables:</li> </ol> <pre><code>    alpha, r, b = sp.symbols(\"alpha, r, b\")\n\n    k0 = alpha + r * b\n    k1 = r\n    k = [k0, k1]\n\n    corruptable_vars_from_CA = [b]\n\n    master_key_attack = MasterKeyAttack()\n    master_key_attack.init(alpha, k, [alpha, r, b])\n</code></pre> <ol> <li>Define the encodings that belong to the MPK/MSK pair for the CA or AA involved in the attack:</li> </ol> <pre><code>    # add CA master pair\n\n    master_key_attack.add_mpk_CA(b)\n    master_key_attack.add_msk_CA(alpha)\n</code></pre> <ol> <li>Set the corruption model:</li> </ol> <pre><code>    # set corruption model\n\n    master_key_attack.set_corruption_model(MasterKeyCorruptionModel.CA)\n</code></pre> <ol> <li>Add variables obtained by corruption using its origin according to the <code>MasterKeyCorruptedVariable</code> Enum type:</li> </ol> <pre><code>    # add corruptable variables \n\n    for var in corruptable_vars_from_CA:\n        master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MPK_CA, var)\n</code></pre>"},{"location":"corruption/#utilization-of-variable-names-in-corruption-cases","title":"Utilization of variable names in corruption cases","text":"<p>In ACABELLA, we address a variety of setups in multi-authority designs e.g. where multiple attribute authorities (AA) and central authorities (CA) are involved.</p> <p>In general, we consider that several AAs are involved and that they are identified by the index <code>i</code> where a CA is not involved in the corruption model. That means that master secret keys alpha that are part of the attribute authority, are now  identified as alpha_i, that is, they belong to the attribute authority i.</p> <p>Besides this, if the corruption model involves a CA, we identify a CA by the index <code>i</code> and all the variables are related to that index.</p> <p>Finally, if the corruption model involves CAs and AAs, CAs are identified by the index <code>i</code> and the attribute authorities and their variables with the index <code>j</code>.</p> <p>When using the classes defined in <code>core/master_key</code> and <code>core/decryption</code> this naming procedure must be respected to match the output of the <code>format_encodings</code> method.</p>"},{"location":"corruption/#available-functions-for-adding-variables-that-belong-to-authorities","title":"Available functions for adding variables that belong to authorities","text":"<p>Where an attacker is able to compromise an authority via corruption there are different variables that can be taken into account when performing a master and/or a decryption attack. </p> <p>These variables should be added to the list of encodings involving in the attack.  This can be done via the following functions depending on the type of variable:</p> <ul> <li> <p>For master key attacks:</p> <ul> <li><code>add_corruptable_variable_from_CA</code>: for a single parameter.</li> <li><code>add_corruptable_variable_from_AA</code>: for a single parameter. We must note   that this function and <code>add_corruptable_variable_from_CA</code> modify the unknown   list by removing the supplied parameter, that is, making that parameter known.</li> <li><code>add_gp_variable</code>: for a global parameter.</li> <li><code>add_mpk</code>: for a master public key parameter.</li> </ul> </li> <li> <p>For decryption key attacks:</p> <ul> <li><code>add_corruptable_variable_from_AA</code>: for a single parameter.</li> <li><code>add_corruptable_variable_from_CA</code>: for a single parameter.</li> <li><code>add_mpk_variable</code>: for a master public key parameter.</li> <li><code>add_gp_variable</code>: for a global parameter.</li> </ul> </li> </ul>"},{"location":"corruption/#corruption-models-in-master-key-attacks","title":"Corruption models in master key attacks","text":"<p>When analyzing the security a multi-authority ABE scheme, we distinguish among the following corruption cases:</p> <ul> <li><code>NoCorruption</code>: An attack can be performed without performing corruption of one  of the authorities.</li> <li><code>CA</code>: the unique central authority is corrupted and its sensitive parameters captured by an attacker.</li> <li><code>AA</code>: Simple corruption of AAs. One attribute authority, <code>AA[i]</code> is corrupted and its sensitive parameters captured.</li> <li><code>mixed_CA_corr</code>: the scheme consists of several authorities, CAs and AAs. However, we consider the case where the CA has been corrupted.</li> <li><code>mixed_AA_corr</code>: the scheme consists of several authorities, CAs and AAs. However, we consider the case where the AA has been corrupted.</li> </ul>"},{"location":"corruption/#corruption-models-in-decryption-attacks","title":"Corruption models in decryption attacks","text":"<p>When analyzing the security a multi-authority ABE scheme, we distinguish among the following corruption cases for decryption attacks:</p> <ul> <li><code>NoCorruption</code>: An attack can be performed without performing corruption of one  of the authorities.</li> <li><code>AA</code>: One attribute authority, <code>AA[i]</code> is corrupted and its sensitive parameters captured.</li> <li><code>AA_extended</code>: One attribute authority, <code>AA[i]</code> is corrupted and its sensitive parameters captured. However, interacction with a different <code>AA[j]</code> where <code>j</code> and <code>i</code> are different is required to finish the attack. The rationale here is that different attribute-independent encodings <code>c_i</code>, <code>c_j</code> for <code>i != j</code> must be obtained for the attack.</li> </ul>"},{"location":"corruption/#a-note-about-simulating-corruption-in-security-checks","title":"A note about simulating corruption in security checks","text":"<p>It is possible to use the <code>\"corruptable_vars\": []</code> field in the JSON input to add possible variables captured via corruption during the security analysis of an ABE scheme.</p>"},{"location":"decryption/","title":"Finding decryption attacks","text":""},{"location":"decryption/#finding-decryption-attacks-in-abe-schemes","title":"Finding decryption attacks in ABE schemes","text":"<p>In this section we show, step by step, how to find decryption attacks in  ABE schemes. First, we start by describing the JSON input file that ACABELLA expects for looking for this type of attack.</p>"},{"location":"decryption/#the-json-input-for-acabella","title":"The JSON input for ACABELLA","text":"<p>In decryption attacks, the MPK value introduces the encodings in the matrix. When using  the AA extended corruption model, this value is equivalent to MPK_AAj. However the MPK_AAj input field is only use for adding descriptive information about the structure of an attribute authority. </p> <p>Note</p> <p>Take into account that both MPK_AAj and MPK_AAi do not insert any additional encoding into the matrix.</p>"},{"location":"decryption/#type-of-corruptable-variables-in-decryption-attacks","title":"Type of corruptable variables in decryption attacks","text":"<p>Similarly, in decryption attacks the corrupted variables (<code>DecryptionKeyCorruptedVariable</code>) can be categorized as:</p> <ul> <li>MPK_AAi: The variable belongs to an Attribute Authority j. It will be used to obtain the master key of an AA[i].</li> <li>misc = misc. variable part of an attribute autority [i].</li> </ul>"},{"location":"decryption/#attacking-cm14","title":"Attacking CM14","text":"<p>The CM14 scheme [^1] is a multi-authority ABE where there are only distributed AAs and no CA. During Setup, every authority generates a secret key consisting of ,  and for every attribte , . The public key of every authority consists of the tuple ,  and . Every user of the system has an identifier (GID). This identifier is involved in the key components to link them to the user.</p> <p>During key generation, the attribute-independent component is:</p> <ul> <li>  =  </li> </ul> <p>During encryption, the attribute-independent component is .</p>"},{"location":"decryption/#obtaining-the-involved-encodings","title":"Obtaining the involved encodings","text":"<p>To obtain the involved key encodings, we take  and replace the hash of GID by  and add the encoding . Then, we rename  as  and obtain:   as encodings. From the ciphertext encodings, we obtain . And as MPK encodings, we obtain .</p> <p>As unknown variables, we have: , , , .</p>"},{"location":"decryption/#generating-inputs-for-acabella","title":"Generating inputs for ACABELLA","text":"<p>In this case, we can only perform an decryption attack with or without corruption. If we use corruption, we should use the <code>AA_extended</code> corruption model, based on the corruption of an attribute authority where we obtain one of its values (and possibly, key or ciphertext components) and on the use of the recovered parameters to attack an honest attribute authority.</p> <p>Given on the encodings that we have obtained in the past section, we can prepare the following input to ACABELLA for a decryption attack without corruption:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_AAi\": [],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n}\n</code></pre> <p>In this case, the output of ACABELLA is: </p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\n         k0 : (alpha_i + r)/b\n         k1 : r\n         c0 : b*s\n         mpk0 : b\n\nStructure of CA/AAs:\n\n[!] No decryption attack found\n</code></pre> <p>We can also try the AA_extended corruption model. We'll suppose we obtain the  parameter of a corrupted authority , . Then, we'll obtain ciphertext encodings from that authority too. The goal is to attack, using those encodings, a honest authority . We prepare the following input for ACABELLA:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\", \"s * b2\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"AA_extended\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AAi\", \"var\":\"b2\" }\n         ],\n    \"MPK_AAi\": [\"b2\"],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n}\n</code></pre> <p>ACABELLA finds the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0[i]*c0 : s*(alpha_i + r)\n         k1[i]*c1 : b2*r*s\n         k1[i]*mpk1 : b2*r\n         c0*mpk1 : b*b2*s\n         c1*mpk0 : b*b2*s\n         k[i]0 : (alpha_i + r)/b\n         k[i]1 : r\n         c0 : b*s\n         c1 : b2*s\n         mpk0 : b\n         mpk1 : b2\n\nFor the corruption of an attribute authority AA[i] where c0 and c1 are obtained from different attribute authorities.\n\nStructure of CA/AAs:\n        Master key pair of AA[i]: mpk[i]: [b2]\n        Master key pair of AA[j]: mpk[j]: [b]\n\nList of variables obtained via corruption:\n        b2 from MPK_AAi\n\n[*] Decryption attack found: 1*k0[i]*c0 + -1/b2*k1[i]*c1\n</code></pre>"},{"location":"decryption/#attacking-po17","title":"Attacking PO17","text":"<p>The PO17 scheme [^2] is a MA-ABE scheme with a similar structure as CM14. It only consists of multiple attribute-authorities AA in a distributed fashion. </p> <ul> <li> <p>During <code>Setup</code>, every attribute authority generates ,  and  (for every supported attribute  as the master secret key tuple MSK. The MPK of every authority consist then on  and .  Moreover, for every attribute , an associated public key is generated as . </p> </li> <li> <p>The key generation component that is attribute-independent is .</p> </li> <li> <p>In the encryption process, the attribute-independent variables correspond to . </p> </li> </ul>"},{"location":"decryption/#obtaining-the-involved-encodings_1","title":"Obtaining the involved encodings","text":"<p>We rename the key generation component  as  and we  add the corresponding encoding of , . From the ciphertext component, we rename it as . Finally, we also add the MPK corresponding to the attribute authority to the encoding list.</p>"},{"location":"decryption/#generating-inputs-for-acabella_1","title":"Generating inputs for ACABELLA","text":"<p>We follow the same strategy as with the CM14 [^1] scheme, using the <code>AA_extended</code> corruption model. We create the following JSON input:</p> <pre><code>{\n    \"scheme_id\": \"po17\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i - r) / b\", \"r\"],\n    \"c\": [\"s * b\", \"s * b2\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"AA_extended\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AAi\", \"var\":\"b2\" }\n         ],\n    \"MPK_AAi\": [\"b2\"],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n}\n</code></pre> <p>and ACABELLA finds the following decryption attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0[i]*c0 : s*(alpha_i - r)\n         k1[i]*c0 : b*r*s\n         k0[i]*mpk0 : alpha_i - r\n         k0[i]*mpk0 : alpha_i - r\n         k1[i]*mpk0 : b*r\n         k1[i]*mpk0 : b*r\n         c0*mpk0 : b**2*s\n         c0*mpk0 : b**2*s\n         k[i]0 : (alpha_i - r)/b\n         k[i]1 : r\n         c0 : b*s\n         mpk0 : b\n         mpk0 : b\n\nFor the corruption of an attribute authority AA[i].\n\nStructure of CA/AAs:\n        Master key pair of AA[i]: mpk[i]: [b]\n\nList of variables obtained via corruption:\n        b from MPK_AAi\n\n[*] Decryption attack found: 1*k0[i]*c0 + 1/b*k1[i]*c0\n</code></pre>"},{"location":"decryption/#attacking-ndcw15","title":"Attacking NDCW15","text":"<p>The NDCW15 scheme [^3] is a CP-ABE scheme with traceability capabilities to detect illegal key redistribution. </p> <p>During <code>Setup</code>, the master key of the system,  is generated as well  as the corresponding public keys of every attribute in the system and the rest of public parameters ( for instance is relevant to us as it appears in one of the attribute-independent ciphertext components).</p> <p>We are interested in the following key components, that are attribute-independent:</p> <p>for  and .</p> <ul> <li> <p> </p> </li> <li> <p> </p> </li> </ul> <p>where  is known by the user as well as .</p> <p>From <code>Encryption</code>, we are interested in the following ciphertext encodings:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> <p>The user knows the following variables  (sent by the authority),  (generated by the user) and , that is part of one attribute-independent component of the key.</p>"},{"location":"decryption/#obtaining-the-involved-encodings_2","title":"Obtaining the involved encodings","text":"<p>We rename the known variables by the user as  variables:</p> <ul> <li>  becomes  </li> <li>  becomes  </li> <li>  becomes  </li> </ul> <p>The global parameters are renamed as:</p> <ul> <li>  becomes  </li> <li>  becomes  </li> </ul> <p>Now, the corresponding key encodings are:</p> <ul> <li> </li> <li> </li> </ul> <p>And the corresponding ciphertext encodings are:</p> <ul> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"decryption/#generating-inputs-for-acabella_2","title":"Generating inputs for ACABELLA","text":"<p>If we try a decryption attack without corruptin with the following input:</p> <pre><code>{\n    \"scheme_id\": \"ndcw15\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha * (1 / (b1 + x3)) + x2 * b2 * (1 / (b1 + x3))\", \"x1\", \"x1 * b1\"],\n    \"c\": [\"s\", \"s * b1\", \"s * b2\"],\n    \"mpk\": [],\n    \"gp\": [\"b1\", \"b2\", \"1\"],\n    \"key\" : \"alpha * s\",\n    \"unknown_vars\" :  [\"alpha\", \"b1\", \"b2\", \"s\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_AAi\": [],\n    \"MPK_AAj\": [],\n    \"misc_vars\": []\n}\n</code></pre> <p>ACABELLA finds a decryption attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0*c0 : s*(alpha/(b1 + x3) + b2*x2/(b1 + x3))\n         k0*c1 : b1*s*(alpha/(b1 + x3) + b2*x2/(b1 + x3))\n         k1*c0 : s*x1\n         k1*c1 : b1*s*x1\n         k1*c2 : b2*s*x1\n         k2*c0 : b1*s*x1\n         k2*c1 : b1**2*s*x1\n         k2*c2 : b1*b2*s*x1\n         c0*gp0 : b1*s\n         c0*gp1 : b2*s\n         c0*gp2 : s\n         c1*gp0 : b1**2*s\n         c1*gp1 : b1*b2*s\n         c1*gp2 : b1*s\n         c2*gp0 : b1*b2*s\n         c2*gp2 : b2*s\n         k1*gp0 : b1*x1\n         k1*gp1 : b2*x1\n         k2*gp2 : b1*x1\n         k0 : alpha/(b1 + x3) + b2*x2/(b1 + x3)\n         k1 : x1\n         k2 : b1*x1\n         c0 : s\n         c1 : b1*s\n         c2 : b2*s\n         gp0 : b1\n         gp1 : b2\n         gp2 : 1\n\n[*] Decryption attack found: k0*c0*x3 + 1*k0*c1 + -x2/x1*k1*c2\n</code></pre>"},{"location":"decryption/#attacking-yj14","title":"Attacking YJ14","text":"<p>The YJ14 scheme [^4] is a MA-ABE scheme that uses one central authority and several attribute authorities. The CA runs the Setup algorithm and registers users and AAs. The AAs are independents and generate attribute public and secret keys as well as revoke attributes. The scheme is cloud-centered and also consists of a cloud server, data owners (those who encrypt and store ciphertextexts in the cloud) as well as data consumers (or users, those who decrypt ciphertexts if they can fulfill an access policy).</p> <p>During Setup, the CA generates  global master key comprised of , . It also publishes the global system parameters tuple, consisting of , ,  and the hash function . During the user registration functionality, the CA generates  and  and generates the following keys:</p> <p>It sends to the user ,  and a certificate.</p> <p>It also generates an identifier, aid to every AA involved in the system.</p> <p>Each  generates the parameters: ,  and . The AA public key consists of ,  and .</p> <p>We are interested in the following key encodings, which are attribute-independent:</p> <p>where  is generated .</p> <p>Finally, we are interested in the following ciphertext encodings (which are attribute-independent):</p>"},{"location":"decryption/#obtaining-the-involved-encodings_3","title":"Obtaining the involved encodings","text":"<ul> <li>We identify the  and  encodings that are part of the global parameters. We rename  to  and  to .</li> <li>The user secret key,  parameter, is renamed it as . This parameter is kept secret and distributed in the attribute authorities.</li> <li>The key encodings are then  and .</li> <li>The ciphertext encodings are  and .</li> <li>The unkown variables in this case are <code>[\"alpha_i\", \"b\", \"bp\", \"r\", \"s\", \"x\"]</code>.</li> </ul>"},{"location":"decryption/#generating-inputs-for-acabella_3","title":"Generating inputs for ACABELLA","text":"<p>Given the identified encodings, we can try to find a decryption attack with the following input:</p> <pre><code>{\n    \"scheme_id\": \"yj14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha_i + x * b + r * bp\", \"r\"],\n    \"c\": [\"s\", \"s * bp\"],\n    \"mpk\": [\"b\", \"bp\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"bp\", \"r\", \"s\", \"x\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],    \n    \"MPK_AAi\": [\"alpha_i\", \"x\"],\n    \"MPK_AAj\": [],\n    \"misc_vars\": [\"x\"]\n}\n</code></pre> <p>However, ACABELLA doesn't find an attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k1*c1 : bp*r*s\n         k0 : alpha_i + b*x + bp*r\n         k1 : r\n         c0 : s\n         c1 : bp*s\n         mpk0 : b\n         mpk1 : bp\n\nStructure of CA/AAs:\n\n[!] No decryption attack found\n</code></pre> <p>Every attribute authority in the system contains the user secret key . It could be that having this parameter could enable a decryption attack. In order to check that, we can corrupt an , obtain  and then launch an attack against an honest authority . In this case, we'll use the <code>AA</code> corruption model (there is no CA involved), and we'll obtain the variable  from a corrupted authority:</p> <pre><code>{\n    \"scheme_id\": \"yj14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha_i + x * b + r * bp\", \"r\"],\n    \"c\": [\"s\", \"s * bp\"],\n    \"mpk\": [\"b\", \"bp\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"bp\", \"r\", \"s\", \"x\"],\n    \"corruption_model\": \"AA\",\n    \"corruptable_vars\": [\n        { \"type\":\"misc\", \"var\":\"x\" }\n         ],    \n    \"MPK_AAi\": [\"alpha_i\", \"x\"],\n    \"MPK_AAj\": [],\n    \"misc_vars\": [\"x\"]\n}\n</code></pre> <p>In this case, ACABELLA shows us how to perform a decryption attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0[i]*c0 : s*(alpha_i + b*x + bp*r)\n         k1[i]*c1 : bp*r*s\n         c0*mpk0 : b*s\n         c1*mpk0 : b*bp*s\n         k[i]0 : alpha_i + b*x + bp*r\n         k[i]1 : r\n         c0 : s\n         c1 : bp*s\n         mpk0 : b\n         mpk1 : bp\n\nFor the corruption of an attribute authority AA[i].\n\nStructure of CA/AAs:\n        Master key pair of AA[i]: mpk[i]: [alpha_i, x]\n\nList of variables obtained via corruption:\n        x from AAi\n\n[*] Decryption attack found: 1*k0[i]*c0 + -1*k1[i]*c1 + -x*c0*mpk0\n</code></pre>"},{"location":"decryption/#attacking-yjr13","title":"Attacking YJR13","text":"<p>The YJR13 scheme [^5] is a multi-authority scheme that uses a CA and several attribute authorities. The problem of this scheme, as we'll see is that the user knows two exponents that enable it to perform a decryption attack without the need of corruption.</p> <ul> <li>The CA, during <code>Setup</code>, generates  as master key and publshes  as part of the system parameters.</li> <li>During the user registration, the CA generates  and  via  and . In this scheme, the user knows  a well as its uid (used as  in the scheme).</li> <li>The AAs, during <code>Setup</code>, generate ,  and  as secret key and publish as public key: , , .</li> <li>During key generation, the followign attribute-independent components are generated: ,  and  for .</li> <li>We are interested in the following attribute-independent components generated during encryption:  and .</li> </ul>"},{"location":"decryption/#obtaining-the-involved-encodings_4","title":"Obtaining the involved encodings","text":"<ul> <li>We know that the user has , that we rename as  and , renamed as .</li> <li>The random exponent  is renamed as .</li> <li>The key encodings are then: ,  and .</li> <li>The global parameter , generated by the CA is also involved in our analysis and we rename it as .</li> <li>The MPK triple of every attribute authority i consists of ,  (renamed as ) and , renamed as .</li> <li>The ciphertex-related encodings are  and .</li> </ul>"},{"location":"decryption/#generating-inputs-for-acabella_4","title":"Generating inputs for ACABELLA","text":"<p>Since the user knows already two exponents in the scheme, we can try to find an attack without corruption using the following input:</p> <pre><code>{\n    \"scheme_id\": \"yjr13\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha_i * (1 / x1) + x2 * b + r * (b / bp)\", \"r * bp * (1 / x1)\", \"r*b\"],\n    \"c\": [\"s\", \"s / bp\"],\n    \"mpk\": [\"bp\"],\n    \"gp\": [\"b\"],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\", \"bp\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],    \n    \"MPK_AAi\": [\"alpha_i\", \"bp\"],\n    \"MPK_AAj\": [],\n    \"misc_vars\": [\"x1\", \"x2\"]\n}\n</code></pre> <p>ACABELLA finds the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0*c0 : s*(alpha_i/x1 + b*x2 + b*r/bp)\n         k2*c1 : b*r*s/bp\n         k2*mpk0 : b*bp*r\n         c0*gp0 : b*s\n         c1*gp0 : b*s/bp\n         k1*gp0 : b*bp*r/x1\n         k0 : alpha_i/x1 + b*x2 + b*r/bp\n         k1 : bp*r/x1\n         k2 : b*r\n         c0 : s\n         c1 : s/bp\n         mpk0 : bp\n         gp0 : b\n\nStructure of CA/AAs:\n\n[*] Decryption attack found: k0*c0*x1 + -x1*k2*c1 + -x1*x2*c0*gp0\n</code></pre>"},{"location":"decryption/#advice-on-finding-decryption-attacks","title":"Advice on finding decryption attacks","text":"<ul> <li>Sometimes, it is possible to corrupt an attribute authority and obtain a variable, that, together with an ciphertext component from the same attribute, allow us to attack an honest attribute authority. See for instance the attack against the CM14 and PO17 schemes.</li> </ul>"},{"location":"decryption/#references","title":"References","text":"<p>[^1]: Jianwei Chen and Huadong Ma. Efficient decentralized attribute-based access control for cloud storage with user revocation. In 2014 IEEE International Conference on Communications, ICC 2014, 3782\u20133787. 06 2014. doi:10.1109/ICC.2014.6883910. [^2]: Harsha S. Gardiyawasam Pussewalage and Vladimir A. Oleshchuk. A distributed multi-authority attribute based encryption scheme for secure sharing of personal health records. In Proceedings of the 22nd ACM on Symposium on Access Control Models and Technologies, SACMAT '17 Abstracts, 255\u2013262. New York, NY, USA, 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3078861.3078880, doi:10.1145/3078861.3078880. [^3]: Jianting Ning, Xiaolei Dong, Zhenfu Cao, and Lifei Wei. Accountable authority ciphertext-policy attribute-based encryption with white-box traceability and public auditing in the cloud. In European Symposium on Research in Computer Security, 270\u2013289. Springer, 2015. [^4]: Kan Yang and Xiaohua Jia. Expressive, efficient, and revocable data access control for multi-authority cloud storage. Parallel and Distributed Systems, IEEE Transactions on, 25:1735\u20131744, 07 2014. doi:10.1109/TPDS.2013.253. [^5]: Kan Yang, Xiaohua Jia, Kui Ren, Bo Zhang, and Ruitao Xie. DAC-MACS: effective data access control for multiauthority cloud storage systems. IEEE Trans. Inf. Forensics Secur., 8(11):1790\u20131801, 2013. URL: https://doi.org/10.1109/TIFS.2013.2279531, doi:10.1109/TIFS.2013.2279531.</p>"},{"location":"json/","title":"JSON formats in ACABELLA","text":"<p>For the different tools and analysis types in ACABELLA, JSON files are utililized as inputs. In this section, we describe each input file and format.</p>"},{"location":"json/#json-format-for-abgw-bridge","title":"JSON format for ABGW bridge","text":"<p>Transforming an scheme specified using the ACABELLA format into an input for ABGW requires the following fields:</p> <ul> <li>scheme_id: This filed identifies the scheme with a label e.g. \"yjr13\".</li> <li>analysis: ABGW bridge input files are identified by the tag \"abgw\".</li> <li>k: List of key encodings.</li> <li>c: List of ciphertext encodings. </li> <li>mpk: List of mpk encodings. </li> <li>gp: List of global parameter encodings.</li> <li>key: Blinding value e.g. \"a * s\",</li> <li>unknown_vars:  List of unkown variables. </li> <li>known_vars: List of known variables. </li> </ul> <p>An valid input file for transforming the specification of the YJR13 scheme into a valid input for the ABGW tool is:</p> <pre><code>{\n    \"scheme_id\": \"yjr13\",\n    \"analysis\": \"abgw\",\n    \"k\": [\"a * (1 / x1) + x2 * b + r * (b / bp)\", \"r * bp * (1 / x1)\", \"r * b\"],\n    \"c\": [\"s\", \"s / bp\"],\n    \"mpk\": [\"bp\"],\n    \"gp\": [\"b\"],\n    \"key\" : \"a * s\",\n    \"unknown_vars\" :  [\"a\", \"r\", \"s\", \"b\", \"bp\"],\n    \"known_vars\" : [\"x1\", \"x2\"]\n}\n</code></pre>"},{"location":"json/#json-format-for-master-key-attacks","title":"JSON format for master-key attacks","text":"<p>A master-key attack requires the following parameters in the JSON input file:</p> <ul> <li>scheme_id: This filed identifies the scheme with a label e.g. \"yjr13\".</li> <li>analysis: Identified by the \"master_key\" tag.</li> <li>master_key: Master key identifier e.g. alpha.</li> <li>unknown_vars:  List of unkown variables. </li> <li>corruption_model: corruption model for master key attacks.</li> <li>corruptable_vars: list of dictionarie entries including  variable type and variable.</li> <li>MPK_CA: List of encodings that are part of the MPK of the CA </li> <li>MPK_AA: List of encodings that are part of the MPK of the AA </li> <li>MPK_vars: Variables that are part of the MPK tha could be involved in the attack</li> <li>GP_vars: List of global parameters involved in the attack.</li> </ul> <p>An example input file for analyzing the possibility of master-key attacks could be:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha + r * b\", \"r\"],\n    \"master_key\": \"alpha\",\n    \"unknown_vars\" :  [\"alpha\", \"b\", \"r\"],\n    \"corruption_model\" : \"CA\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_CA\", \"var\":\"b\" }\n         ],\n    \"MPK_CA\": [\"b\"],\n    \"MPK_AA\": [],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>Note: The <code>unknown_vars</code> list should remain static and related to the description of the scheme. That means that, even if we add corruptable-variable entries in the <code>corruptable_vars</code> dictionary, we do not need to remove those variables from <code>unknown_vars</code>. The parser function that processes the JSON files will automatically remove those variables from <code>unknown_vars</code> during the analysis. Further, the <code>MPK_vars</code> list is related to those MPK encodings (either coming from the CA or an AA) that are involved in the attack. We must distinguish this list from <code>MPK_CA</code> and <code>MPK_AA</code> which are only descriptive.</p>"},{"location":"json/#json-format-for-decryption-attacks","title":"JSON format for decryption attacks","text":"<p>A decryption attack requires the following parameters in the JSON input file:</p> <ul> <li>scheme_id: This filed identifies the scheme with a label e.g. \"yjr13\".</li> <li>k: Key encodings.</li> <li>c: Ciphertext encodings.</li> <li>mpk:  List of mpk encodings.</li> <li>gp: List of global parameter encodings.</li> <li>key: blinding value.</li> <li>unknown_vars: List of unknown variables.</li> <li>corruption_model: Corruption model associated to the attack.</li> <li>corruptable_vars: List of dictionaries with the corruptable variable and its type.</li> <li>MPK_AAi: List of MPK encodings related to the second AAi for the AA_extended corruption model.</li> <li>misc_vars: Misc. variables involved in the attack obtained by corruption.</li> </ul> <p>An example input file for analyzing the possibility of master-key attacks could be:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\", \"s * b2\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"AA_extended\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AAi\", \"var\":\"b2\" }\n         ],\n    \"MPK_AAi\": [\"b2\"],\n    \"misc_vars\": []\n}\n</code></pre>"},{"location":"json/#json-format-for-security-analysis","title":"JSON format for security analysis","text":"<p>An AC17 security analysis requires the following parameters in the JSON input file:</p> <ul> <li><code>scheme_id</code>: This filed identifies the scheme with a label e.g. \"yjr13\".</li> <li><code>k</code>: Key encodings.</li> <li><code>c</code>: Ciphertext encodings.</li> <li><code>mpk</code>:  List of mpk encodings.</li> <li><code>gp</code>: List of global parameter encodings.</li> <li><code>key</code>: Blinding factor.</li> <li><code>alpha</code>: Descriptin of alpha.</li> <li><code>s</code>: Description of s.</li> <li><code>unknown_vars</code>: List of unknown variables.</li> <li><code>corruptable_vars</code>: List of variables obtained via corruption.</li> </ul> <p>An example input file for analyzing the security of a scheme is:</p> <pre><code>{\n    \"scheme_id\": \"bsw07\",\n    \"analysis\": \"security\",\n    \"k\": [\"(alpha + r)/b\", \"r + r0 * b0\", \"r0\", \"(alpha + rp)/b\", \"rp + r1 * b1\", \"r1\"],\n    \"c\": [\"s*b\", \"s - sp\", \"(s - sp)*b0\", \"sp * b1\", \"sp\"],\n    \"mpk\": [\"b\", \"b0\", \"b1\", \"1\"],\n    \"key\" : \"alpha * s\",\n    \"unknown_vars\" :  [\"alpha\", \"b\", \"b0\", \"b1\", \"r\", \"rp\", \"r0\", \"r1\", \"s\", \"sp\"],\n    \"corruptable_vars\": []\n}\n</code></pre>"},{"location":"json/#json-format-for-complete-analysis","title":"JSON format for complete analysis","text":"<p>It also possible to prepare a JSON file that includes the parameters to perform a security analysis followed by master key and decryption attacks. In that case, it is possible to use the following JSON input file:</p> <pre><code>{\n\"scheme_id\": \"cm14\",\n\"security\":{\n    \"analysis\": \"security\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\"],\n    \"mpk\": [\"b\"],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"]\n},\n\"master_key\":{\n    \"analysis\": \"master_key\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\"],\n    \"corruption_model\" : \"AA\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AA\", \"var\":\"b\" }\n         ],    \n    \"MPK_CA\": [],\n    \"MPK_AA\": [\"alpha_i\", \"b\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n    },\n\"decryption\":{\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\", \"s * b2\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"AA_extended\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AAi\", \"var\":\"b2\" }\n         ],\n    \"MPK_AAi\": [\"b2\"],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n    }\n}\n</code></pre>"},{"location":"json/#logic-for-complete-analysis","title":"Logic for complete analysis","text":"<p>Of type \"all\" is based on the following logic:</p> <ol> <li>Runs <code>security_analysis</code> - if this step is successful, then there\u2019s no need to run the <code>analysis_trivial_and_collusion_security function</code>.</li> <li>If the security analysis is not successful, it runs <code>analysis_trivial_and_collusion_security</code>.</li> <li>If the checks indicate that there might be attacks, run master-key and decryption attack analysis.</li> </ol>"},{"location":"master/","title":"Finding master key attacks","text":""},{"location":"master/#finding-master-key-attacks-in-abe-schemes","title":"Finding master-key attacks in ABE schemes","text":"<p>In this section, we utilize the ACABELLA command-line tool to demonstrate how to find master-key attacks in ABE schemes. We first introduce the type of corruptable variables that we can use in this case. </p> <p>Further, we recommend the reader to read the supported corruption models for MA-ABE schemes in the respective section.</p>"},{"location":"master/#type-of-corruptable-variables-in-master-key-attacks","title":"Type of corruptable variables in master key attacks","text":"<p>When using corruption models in master key attacks, the variables that we receive from either CAs or AAs can be categorized using the enum type <code>MasterKeyCorruptedVariable</code>:</p> <ul> <li>MPK_CA: The variable is part of the corruption of the Central Authority (CA).</li> <li>MPK_AA: The variable belongs to an Attribute Authority j. It will be used to obtain the master key of an AA[i].</li> </ul> <p>The type of corrupted variable is used in the JSON input files for ACABELLA, for instance:</p> <pre><code>{\n    \"scheme_id\": \"yj12\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"r * b / bp + alpha_i/bp\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\"],\n    \"corruption_model\" : \"mixed_AA_corr\",\n    \"corruptable_vars\": [ { \"type\":\"MPK_AA\", \"var\":\"b/bp\" }],\n    \"MPK_CA\": [\"r\"],\n    \"MPK_AA\": [\"alpha_i\", \"b/bp\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": [\"b\", \"bp\"]\n}\n</code></pre>"},{"location":"master/#attacking-lxxh16","title":"Attacking LXXH16","text":"<p>The LXXH16 scheme [^1] is a multi-authority ABE scheme for the Cloud, based on five different entities. </p> <p>Note</p> <p>In this section we only describe the variables that are interesting for testing if  we can find a master key attack on the scheme.</p> <ul> <li>CA: It generates the system parameters and the attributes public keys. Register users attribute-authorities and creates a uid and an aid respectively. The CA is not involved in the generation of secret keys related to attributes.</li> </ul> <p>Once the system parameters have been chosen (pairing groups, group generators, etc.),  the CA generates the value  as master key and computes the master public key (MPK) as .</p> <p>The CA will generate a uid  for each user of the system as well as an aid for identifying the AAs involved where aid .</p> <p>In summary, if the CA is corrupted, we could obtain the parameter  and that could perhaps help us in performing a master key attack and obtain the attribute-authority private key .</p> <ul> <li>AA: It manages the attribute generation and secret key sassociated to the attributes.</li> </ul> <p>During the <code>AASetup</code> algorithm each AA i generates a master secret key MSK AA =   and an MPK AA = .</p> <ul> <li>Data owner: It uses MA-ABE to encrypt a plaintext with a certain access policy.</li> <li>User: Identified by the uid generated by the CA. It can decrypt a ciphertext if it can satisfiy the respective access policy.</li> </ul> <p>If they have the right permissions in the system, the can ask secret keys related to attributes that they can use to fuilfill an access policy and decrypt a ciphertext. We focus on those components of the secret keys during the key generation algorithm that are attribute-independent: </p> <p>The AA generates the random value . Then, it obtains the attribute key component  and the component  .</p> <ul> <li>Cloud server: It provides the storage capabilities to deploy the system.</li> </ul>"},{"location":"master/#obtaining-the-involved-encodings","title":"Obtaining the involved encodings","text":"<ul> <li> <p>For the CA, we have the  encoding as  that we rename as  (we use  to describe public key parameters in the scheme). We consider that we can obtain this value via corruption of the CA.</p> </li> <li> <p>Every AA contains the encoding .</p> </li> <li> <p>For every key generated by an AA, the user obtains the encodings: , that we rename as  (we use  to denote random variables associated to keys) and .</p> </li> </ul>"},{"location":"master/#generating-inputs-for-acabella","title":"Generating inputs for ACABELLA","text":"<p>Based on the encodings we identified, we can prepare JSON inputs for ACABELLA.</p> <p>We'll start with an input file where corruption is not performed, and where we try to find  based on the available encodings as a normal user:</p> <pre><code>{\n    \"scheme_id\": \"lxhh16\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_i + r * b\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"r\"],\n    \"corruption_model\" : \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_CA\": [\"b\"],\n    \"MPK_AA\": [\"alpha_i\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>Using acabella_cmd will report that no attack was found, via <code>python acabella_cmd.py -a mk -c examples/lxxh16/lxxh16_config_mka_no_corruption.json</code>.</p> <p>However, we can suppose that the CA has been corrupted and that we have obtained the MPK CA encoding, :</p> <pre><code>{\n    \"scheme_id\": \"lxhh16\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_i + r * b\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"r\"],\n    \"corruption_model\" : \"mixed_CA_corr\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_CA\", \"var\":\"b\" }\n         ],\n    \"MPK_CA\": [\"b\"],\n    \"MPK_AA\": [\"alpha_i\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>Note</p> <p>We have chosen the mixed_CA_corr corruption model, that is, a system where multiple AAs and a CA is used. Within this corruption model, we associated the variable b as a variable of the CA (MPK).</p> <p>In this case, the output we obtain from ACABELLA is:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0[i][j] : alpha_i + b*r\n         k1[i][j] : r\n\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: [b]\n        Contents of the AA MPK encodings: [alpha_i]\n\nList of variables obtained via corruption:\n        b from MPK_CA\n\n[*] Master key attack with corruption found: 1*k0[i][j] + -b*k1[i][j]\n</code></pre> <p>and we have obtained a linar combination of key encodings that allow us to recover the master key of the AA.</p>"},{"location":"master/#attacking-mgz19","title":"Attacking MGZ19","text":"<p>The MGZ19 scheme [^2] is a multi-authority ABE scheme that uses multiplies CAs and AAs. We first describe each entity and identify the relevant encodings that we could use in our attack:</p> <ul> <li> <p>The CA generates the system parameters and execute <code>CKeyGen</code>, which generates an identity key  for a user id GID and a set of attributes. Moreover, it generates the parameter r and the component , later used by the attribute authorities. We should keep in mind that we can corrupt the CA and recover the  encoding.</p> </li> <li> <p>Each AA i generates  and  and assign those values to the master secret key of the AA. The MPK pair of the AA is then represented by  and .</p> </li> </ul> <p>For those registers user, the AA i generates secret keys related to attributes  as .</p>"},{"location":"master/#obtaining-the-involved-encodings_1","title":"Obtaining the involved encodings","text":"<ul> <li>The structure of the CA contains the parameter .</li> <li>Each AA contain a MPK with encodings  and , that we rename as  (related to a public key).</li> <li>For ever attribute key generated by an authenticated user, the key-independent part contains the encodings  and .</li> <li>If the corruption of the CA is possible, we could obtain .</li> </ul>"},{"location":"master/#generating-inputs-for-acabella_1","title":"Generating inputs for ACABELLA","text":"<p>Let's assume that the CA can be corrupted and that we can obtain  in the following JSON input for ACABELLA:</p> <pre><code>{\n    \"scheme_id\": \"mgz19\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_j + r * b_j\", \"b_j\"],\n    \"master_key\": \"alpha_j\",\n    \"unknown_vars\" :  [\"alpha_j\", \"b_j\", \"r\"],\n    \"corruption_model\" : \"mixed_CA_corr\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_CA\", \"var\":\"r\" }\n         ],\n    \"MPK_CA\": [\"r\"],\n    \"MPK_AA\": [\"alpha_j\", \"b_j\"],\n    \"MPK_vars\": [\"b_j\"],\n    \"GP_vars\": []\n}\n</code></pre> <p>ACABELLA finds an attack to recover the AA master key:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0[i][j] : alpha_j + b_j*r\n         k1[i][j] : b_j\n\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: [r]\n        Contents of the AA MPK encodings: [alpha_j, b_j]\n\nList of variables obtained via corruption:\n        r from MPK_CA\n\n[*] Master key attack with corruption found: 1*k0[i][j] + -r*k1[i][j]\n</code></pre>"},{"location":"master/#attacking-qlz13","title":"Attacking QLZ13","text":"<p>The QLZ13 scheme [^3] is a multi-authority ABE scheme consisting of only attribute-authorities AAs.</p> <p>During the AA setup algorithm, each authority  generates:</p> <ul> <li>For each attribute managed by the authority , it generates .</li> </ul> <p>Thus, the master public key of the AA is composed of: , , and . The master secret key of the AA consists of: , , and .</p> <p>The users are identified via a global identifier (GID) , generated .</p> <p>During key generation, the  generates random values , . We are interested in the following attribute-independent key components:</p> <ul> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"master/#obtaining-the-involved-encodings_2","title":"Obtaining the involved encodings","text":"<ul> <li>From every AA , we identify the encodings  and , the latter identified by  ( prime, since is related to a public key encoding and we use the letter  for those encodings as a convention). We don't consider the  encoding since it is not attribute-independent.</li> <li>From the key components generated during key generation, we associated the letter  to the user identifier . The  parameter is identified as  and the  parameter as . Random exponents  and  and identified by  and  respectively. Hence, we have the following key encodings: ,  and .</li> </ul>"},{"location":"master/#generating-inputs-for-acabella_2","title":"Generating inputs for ACABELLA","text":"<p>In this case, given the absence of CA and the structure of every AA, there is no much we can obtain via corruption. We can then specify all the encodings in a JSON input file for ACABELLA and try to find master key attacks:</p> <pre><code>{\n    \"scheme_id\": \"qlz13\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_i + r * b + b1 / (x + bp)\", \"r * b - rp * b1\", \"(rp + 1 / (x + bp)) * b1\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"b1\", \"bp\", \"r\", \"rp\", \"x\"],\n    \"corruption_model\" : \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_CA\": [],\n    \"MPK_AA\": [\"alpha_i\", \"bp\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>We finds the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0 : alpha_i + b*r + b1/(bp + x)\n         k1 : b*r - b1*rp\n         k2 : b1*(rp + 1/(bp + x))\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: []\n        Contents of the AA MPK encodings: [alpha_i, bp]\n\n[*] Master key attack found: 1*k0 + -1*k1 + -1*k2\n</code></pre>"},{"location":"master/#attacking-yj12","title":"Attacking YJ12","text":"<p>The MA-ABE YJ12 scheme [^4] consists of a CA and several AAs.</p> <ul> <li> <p>During the <code>Setup</code> algorithm, the CA generates the system parameters and registers AAs and users. Particularly for the users, it generates an UID  and a public key . The <code>OwnerSetup</code> algorithm generates the parameters  and  and obtains the so called  pair consisting of  and . This parameter is sent to every attribute-authority. The CA is fully trusted in the YJ12 scheme.</p> </li> <li> <p>Finally, every AA generates the public key of each attribute it manages. </p> </li> <li> <p>During the key generation algorithm, each AA generates an attribute-independent key part  which is equivalent to .</p> </li> </ul>"},{"location":"master/#obtaining-the-involved-encodings_3","title":"Obtaining the involved encodings","text":"<ul> <li>The CA has generated every public key for the users and contains the parameter u. However it is fully trusted and we don't consider the corruption of the CA.</li> <li>Each AA contains  and , which we rename to   and  respectively.</li> <li>The attribute-independent encodings from key generation are:  and .</li> </ul>"},{"location":"master/#generating-inputs-for-acabella_3","title":"Generating inputs for ACABELLA","text":"<p>In this case, the idea is to corrupt one AA  and use the obtained value  to attack another authority , using the mixed AA corruption model. In this case, we can use the following JSON input file:</p> <pre><code>{\n    \"scheme_id\": \"yj12\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"r * b / bp + alpha_i/bp\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\"],\n    \"corruption_model\" : \"mixed_AA_corr\",\n    \"corruptable_vars\": [ { \"type\":\"MPK_AA\", \"var\":\"b/bp\" }],\n    \"MPK_CA\": [\"r\"],\n    \"MPK_AA\": [\"alpha_i\", \"b/bp\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": [\"b\", \"bp\"]\n}\n</code></pre> <p>which produces the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0[i] : alpha_i/bp + b*r/bp\n         k1[i] : r\n         gp : b\n         gp : bp\n\nFor the corruption of an attribute authority AA[j] and attacking an attribute authority AA[i].\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: [r]\n        Contents of the AA MPK encodings: [alpha_i, b/bp]\n\nList of variables obtained via the corruption of AA[j]:\n        b/bp from MPK_AA\n\n[*] Master key attack with corruption found: bp*k0[i] + -b*k1[i]\n</code></pre>"},{"location":"master/#advice-on-finding-master-key-attacks-on-schemes","title":"Advice on finding master key attacks on schemes","text":"<ul> <li> <p>We are interested in the attribute-independent key components generated during the key generation algorithm. </p> </li> <li> <p>Schemes adding new capabilities such as traceability and outsourcing are typically prone to errors due to the number of exponents that are generated by the CAs/AAs that are not correctly validated.</p> </li> <li> <p>Sometimes, schemes that can be attacked via corruption are those where the CA generates exponents that are later utilized by AAs. In some cases, the CA can be corrupted and those values obtained and finally used to recover the master key of a AA. This is the case of the MGZ19 scheme.</p> </li> <li> <p>Other times, the CA can kept values that we can use to recover the master key of an AA via a linear combination of encodings. In those cases, it's worth trying to find master key attacks involving the corruption of those values stored by the CA. See for instance the attack against LXXH16.</p> </li> <li> <p>Finally, it is possible to corrupt an attribute-authority  and obtain certain parameter that can enable an attack on a second authority,  and that allow us to recover its master key . See for instance the YJ12 attack.</p> </li> </ul> <p>[^1]: Wei Li, Kaiping Xue, Yingjie Xue, and Jianan Hong. Tmacs: a robust and verifiable threshold multi-authority access control system in public cloud storage. IEEE Transactions on Parallel and Distributed Systems, 27(5):1484\u20131496, 2016. doi:10.1109/TPDS.2015.2448095. [^2]: Chuangui Ma, Aijun Ge, and Jie Zhang. Fully secure decentralized ciphertext-policy attribute-based encryption in standard model. In Fuchun Guo, Xinyi Huang, and Moti Yung, editors, Information Security and Cryptology, 427\u2013447. Cham, 2019. Springer International Publishing. [^3]: Huiling Qian, Jiguo Li, and Yichen Zhang. Privacy-preserving decentralized ciphertext-policy attribute-based encryption with fully hidden access structure. In Sihan Qing, Jianying Zhou, and Dongmei Liu, editors, Information and Communications Security, 363\u2013372. Cham, 2013. Springer International Publishing. [^4]: Kan Yang and Xiaohua Jia. Attributed-based access control for multi-authority systems in cloud storage. In 2012 IEEE 32nd International Conference on Distributed Computing Systems, volume, 536\u2013545. 2012. doi:10.1109/ICDCS.2012.42.</p>"},{"location":"reference/","title":"Reference API","text":"<p><code>ACABELLA</code> provides different functions and classes for analyzing the security of ABE schemes.</p>"},{"location":"reference/#classes-for-finding-attacks-in-abe-schemes","title":"Classes for finding attacks in ABE schemes","text":"<p>The base class for finding attacks is the <code>Attack</code> class:</p> <p>attack.py: Abstract class with format_solution method</p>"},{"location":"reference/#attack.Attack","title":"<code>Attack</code>","text":"<p>Base class for performing attacks. </p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>The attack is enabled.</p> <code>description</code> <code>str</code> <p>Description of the attack.</p> Source code in <code>attack.py</code> <pre><code>class Attack:\n\"\"\"\n    Base class for performing attacks. \n\n    Attributes:\n        enabled (bool): The attack is enabled.\n        description (str): Description of the attack.\n    \"\"\"\n    enabled = True\n    description = None\n\n    def format_solution(self, encoding_list: list, solution_list: list, msg: str) -&gt; str:\n\"\"\"\n        Given the solution of an attack e.g. if it has found an attack and the\n        description of the ABE scheme, it formats the output to be presented\n        to the user.\n\n        Parameters:\n            encoding_list (list): Descrition of the scheme encodings.\n            solution_list (sp.core.list.Symbol): Result of the attack.\n            msg (str): Base message to present to the user.\n\n        Returns:\n            Result of the attack (str): Well built string describing the attack result. \n        \"\"\"                                         \n        assert len(encoding_list) == len(                                              \n        solution_list                                                              \n        ), \"format_solution: mismatch in encoding and solution lists\"                  \n\n\n        mul_list = [                                                                   \n            simplify(Symbol(str(a)) * Symbol(str(b)))                                  \n            for a, b in zip(encoding_list, solution_list)                              \n            if b != 0                                                                  \n        ]                                                                              \n\n        if DEBUG:\n            print(encoding_list)\n            print(solution_list)\n\n        return(                                                                        \n            msg + \" + \".join(\"{}\".format(e) for e in mul_list)         ) \n\n    def init(self) -&gt; None:\n\"\"\"\n        Initialization function of the attack.\n        \"\"\"    \n        pass\n\n    def run(self) -&gt; None:\n\"\"\"\n        Function for running the attack.\n        \"\"\"    \n        pass\n\n    def show_solution(self) -&gt; None:\n\"\"\"\n        Shows the result of the attack.\n        \"\"\"    \n        pass\n</code></pre>"},{"location":"reference/#attack.Attack.format_solution","title":"<code>format_solution(encoding_list, solution_list, msg)</code>","text":"<p>Given the solution of an attack e.g. if it has found an attack and the description of the ABE scheme, it formats the output to be presented to the user.</p> <p>Parameters:</p> Name Type Description Default <code>encoding_list</code> <code>list</code> <p>Descrition of the scheme encodings.</p> required <code>solution_list</code> <code>sp.core.list.Symbol</code> <p>Result of the attack.</p> required <code>msg</code> <code>str</code> <p>Base message to present to the user.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Result of the attack (str): Well built string describing the attack result.</p> Source code in <code>attack.py</code> <pre><code>def format_solution(self, encoding_list: list, solution_list: list, msg: str) -&gt; str:\n\"\"\"\n    Given the solution of an attack e.g. if it has found an attack and the\n    description of the ABE scheme, it formats the output to be presented\n    to the user.\n\n    Parameters:\n        encoding_list (list): Descrition of the scheme encodings.\n        solution_list (sp.core.list.Symbol): Result of the attack.\n        msg (str): Base message to present to the user.\n\n    Returns:\n        Result of the attack (str): Well built string describing the attack result. \n    \"\"\"                                         \n    assert len(encoding_list) == len(                                              \n    solution_list                                                              \n    ), \"format_solution: mismatch in encoding and solution lists\"                  \n\n\n    mul_list = [                                                                   \n        simplify(Symbol(str(a)) * Symbol(str(b)))                                  \n        for a, b in zip(encoding_list, solution_list)                              \n        if b != 0                                                                  \n    ]                                                                              \n\n    if DEBUG:\n        print(encoding_list)\n        print(solution_list)\n\n    return(                                                                        \n        msg + \" + \".join(\"{}\".format(e) for e in mul_list)         ) \n</code></pre>"},{"location":"reference/#attack.Attack.init","title":"<code>init()</code>","text":"<p>Initialization function of the attack.</p> Source code in <code>attack.py</code> <pre><code>def init(self) -&gt; None:\n\"\"\"\n    Initialization function of the attack.\n    \"\"\"    \n    pass\n</code></pre>"},{"location":"reference/#attack.Attack.run","title":"<code>run()</code>","text":"<p>Function for running the attack.</p> Source code in <code>attack.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    Function for running the attack.\n    \"\"\"    \n    pass\n</code></pre>"},{"location":"reference/#attack.Attack.show_solution","title":"<code>show_solution()</code>","text":"<p>Shows the result of the attack.</p> Source code in <code>attack.py</code> <pre><code>def show_solution(self) -&gt; None:\n\"\"\"\n    Shows the result of the attack.\n    \"\"\"    \n    pass\n</code></pre>"},{"location":"reference/#master-key-attacks","title":"Master key attacks","text":""},{"location":"reference/#master_key.MasterKeyAttack","title":"<code>MasterKeyAttack</code>","text":"<p>             Bases: <code>Attack</code></p> <p>Finds master key attacks in ABE schemes, optionally assuming the corruption of Central Authorities (CAs) and Attribute Authorities (AAs).</p> <p>Attributes:</p> Name Type Description <code>SOL_MSG</code> <code>str</code> <p>Message to report if a master key attack is found.</p> <code>NOT_FOUND_MSG</code> <code>str</code> <p>Message to report if a master key attack is not found.</p> <code>corr_model</code> <code>str</code> <p>Corruption model involved in the attack.</p> <code>masterkey</code> <code>sp.core.symbol.Symbol</code> <p>Master key to recover. </p> <code>keyenco(list)</code> <code>sp.core.symbol.Symbol</code> <p>Key encodings as a list of sp.core.symbol.Symbol elements. Each element, k_i, is related to a key encoding involved in the attack. However, we must note that it can be related to a mpk element or to a gp element.</p> <code>unknown(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of unknown elements (sp.core.symbol.Symbol). These are the elements that in theory unknown for the attacker. However, they can be disclosed by corrupting an authority for instance.</p> <code>solution(str)</code> <code>sp.core.symbol.Symbol</code> <p>Solution of the attack, if found.</p> <code>description(str)</code> <code>sp.core.symbol.Symbol</code> <p>Description of the attack, by default MasterKeyAttack.</p> <code>c(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of ciphertext encodings. Not used.</p> <code>mpk(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of mpk related variables.</p> <code>gp(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of global parameter related variables.</p> <code>translation_table(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of mappings variable -&gt; mpk or variable -&gt; gp to improve the details of an attack when printing the solution.</p> <code>MPK_CA(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of mpk variables that belong to the CA.</p> <code>MSK_CA(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of msk variables that belong to the CA.</p> <code>MPK_AA(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of mpk variables that belong to the AA.</p> <code>MSK_AA(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of msk variables that belong to the AA.</p> Source code in <code>master_key.py</code> <pre><code>class MasterKeyAttack(Attack):\n\"\"\"\n    Finds master key attacks in ABE schemes, optionally\n    assuming the corruption of Central Authorities (CAs)\n    and Attribute Authorities (AAs).\n\n    Attributes:\n        SOL_MSG (str): Message to report if a master key attack is found.\n        NOT_FOUND_MSG (str): Message to report if a master key attack is not found.\n        corr_model (str): Corruption model involved in the attack.\n        masterkey (sp.core.symbol.Symbol): Master key to recover. \n        keyenco(list): Key encodings as a list of sp.core.symbol.Symbol elements. Each\n            element, k_i, is related to a key encoding involved in the attack. However, we\n            must note that it can be related to a mpk element or to a gp element.\n        unknown(list): List of unknown elements (sp.core.symbol.Symbol). These are the elements\n            that in theory unknown for the attacker. However, they can be disclosed by corrupting\n            an authority for instance.\n        solution(str): Solution of the attack, if found.\n        description(str): Description of the attack, by default MasterKeyAttack.\n        c(list): List of ciphertext encodings. Not used.\n        mpk(list): List of mpk related variables.\n        gp(list): List of global parameter related variables.\n        translation_table(list): List of mappings variable -&gt; mpk or variable -&gt; gp to improve\n            the details of an attack when printing the solution.\n        MPK_CA(list): List of mpk variables that belong to the CA.\n        MSK_CA(list): List of msk variables that belong to the CA.\n        MPK_AA(list): List of mpk variables that belong to the AA.\n        MSK_AA(list): List of msk variables that belong to the AA.\n    \"\"\"\n\n    SOL_MSG = \"[*] Master key attack found: \"\n    NOT_FOUND_MSG = \"[!] No Master key attack found\"\n    corr_model = MasterKeyCorruptionModel.NoCorruption\n    masterkey = None \n    keyenco = None\n    unknown = None\n    solution = None\n    description = \"MasterKeyAttack\"\n    c = [] \n    mpk = [] \n    gp = [] \n    translation_table = []\n\n    # for output improvement\n    # in corruption cases\n\n    MPK_CA = []\n    MSK_CA = []\n    MPK_AA = []\n    MSK_AA = []\n\n    # utilized for keeping track of the type\n    # of variables that enters the attack\n    # via corruption of CA or AA\n\n    # a corruption map contains dictionary entries\n    # of the form {\"name\", \"origin\"} where origins\n    # corresponds to one of the entries of the\n    # `MasterKeyCorruptedVariable enumeration\n\n    corruption_map = []\n\n    def __init__(self) -&gt; None:\n\"\"\"\n        The constructor for MasterKeyAttack class. \n        \"\"\"\n        self.masterkey = None \n        self.keyenco = None\n\n        # master key attacks relies on the\n        # decryption key attack class\n        # we save in keyenco_mk the original\n        # encoding that initialized the master\n        # key attack\n        self.keyenco_mk = None\n\n        self.unknown = None\n        self.solution = None\n        self.description = \"MasterKeyAttack\"\n\n        self.c = [] \n        self.mpk = [] \n        self.gp = [] \n        self.translation_table = []\n\n        self.MPK_CA = []\n        self.MSK_CA = []\n        self.MPK_AA = []\n        self.MSK_AA = []\n\n        self.corruption_map = []\n\n    def init(self, masterkey: list, keyenco: list, unknown: list) -&gt; None:\n\"\"\"\n        Initializes a master key attack based on:\n\n        Parameters:\n            masterkey (list): The master key to find.\n            keyenco (list): The key encodings.\n            unknown (list): The list of not known variables of the ABE scheme.\n        \"\"\"\n        self.masterkey = masterkey\n        self.keyenco = keyenco\n        self.unknown = unknown\n\n    def run(self) -&gt; None:\n\"\"\"\n        Tries to find a master key attack on the given ABE scheme.\n        It reuses the implementation of the decryption attack with the\n        flag master_key_attack_only set as True.\n        \"\"\"\n        decryption_attack = DecryptionAttack()\n\n        self.keyenco = self.gen_dict(self.keyenco)\n\n        # save encodings here before passing them\n        # to decryption class. It will be used for\n        # printing pourposes in format_encodings\n        self.keyenco_mk = copy.deepcopy(self.keyenco)\n\n        decryption_attack.init(self.masterkey, self.keyenco, self.c, self.mpk, self.gp, self.unknown, master_key_attack_only=True)                            \n        decryption_attack.set_sol_msg(self.SOL_MSG)\n        decryption_attack.set_not_found_msg(self.NOT_FOUND_MSG)\n\n        decryption_attack.run()                                                            \n        self.solution = decryption_attack.show_solution()          \n\n    def format_encodings(self) -&gt; None:\n\"\"\"\n        Prints the involved encodings in the given ABE scheme.\n        \"\"\"\n\n        if self.keyenco_mk:\n            print(\"\\nList of encodings:\")\n            for elem in self.keyenco_mk:\n                print(\"\\t\", elem[\"dsc\"], \":\", elem[\"op\"])\n\n        # Give details about the corruption model in relation to the\n        # attack\n\n        if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n            print(\"\\nFor the corruption of an attribute authority AA[j] and attacking an attribute authority AA[i].\")          \n\n        if self.corr_model == MasterKeyCorruptionModel.CA:\n            print(\"\\nFor the corruption of the Central Authority.\")                       \n\n        if self.corr_model == MasterKeyCorruptionModel.mixed_CA:\n            print(\"\\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\")    \n\n\n\n        if self.translation_table:\n            dict_index = 0\n            print(\"\\nInformation on additional encodings:\")\n            for elem in self.translation_table:\n                print(f'\\t[*] {elem[\"name\"]} corresponds to {elem[\"type\"]}{dict_index}')\n                dict_index = dict_index + 1\n            print(\"\\nNOTE: Global parameters gp[i] are added to the matrix as key encodings and could appear as k[i] elements.\")\n\n        # Print the contents of the master key pairs according to the\n        # corruption model:\n\n        if self.MPK_AA or self.MSK_AA or self.MPK_CA or self.MSK_CA:\n\n            print(\"\\nStructure of CA/AAs:\")\n\n            match self.corr_model:\n                case MasterKeyCorruptionModel.NoCorruption:\n                    print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                    print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case MasterKeyCorruptionModel.CA:\n                    print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                case MasterKeyCorruptionModel.AA:\n                    print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case MasterKeyCorruptionModel.mixed_CA:\n                    print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                    print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case MasterKeyCorruptionModel.mixed_AA:\n                    print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                    print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case _:\n                    pass\n\n        # Print corruption map \n\n        if self.corr_model != MasterKeyCorruptionModel.NoCorruption:\n            if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n                print(\"\\nList of variables obtained via the corruption of AA[j]:\")    \n            else:\n                print(\"\\nList of variables obtained via corruption:\")\n            for elem in self.corruption_map:\n                print(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n\n    def format_encodings_string(self) -&gt; str:\n\"\"\"\n        Return a string with the involved encodings in the given ABE scheme.\n        \"\"\"\n\n        ret_string = []\n\n        if self.keyenco_mk:\n            ret_string.append(\"\\nList of encodings:\")\n            for elem in self.keyenco_mk:\n                ret_string.append(\"\\t \" + str(elem[\"dsc\"]) + \" : \" + str(elem[\"op\"]))\n\n        # Give details about the corruption model in relation to the\n        # attack\n\n        if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n            ret_string.append(\"\\nFor the corruption of an attribute authority AA[j] and attacking an attribute authority AA[i].\")          \n\n        if self.corr_model == MasterKeyCorruptionModel.CA:\n            ret_string.append(\"\\nFor the corruption of the Central Authority.\")                       \n\n        if self.corr_model == MasterKeyCorruptionModel.mixed_CA:\n            ret_string.append(\"\\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\")    \n\n\n\n        if self.translation_table:\n            dict_index = 0\n            ret_string.append(\"\\nInformation on additional encodings:\")\n            for elem in self.translation_table:\n                ret_string.append(f'\\t[*] {elem[\"name\"]} corresponds to {elem[\"type\"]}{dict_index}')\n                dict_index = dict_index + 1\n            ret_string.append(\"\\nNOTE: Global parameters gp[i] are added to the matrix as key encodings and could appear as k[i] elements.\")\n\n        # Print the contents of the master key pairs according to the\n        # corruption model:\n\n        if self.MPK_AA or self.MSK_AA or self.MPK_CA or self.MSK_CA:\n\n            ret_string.append(\"\\nStructure of CA/AAs:\\n\")\n\n            match self.corr_model:\n                case MasterKeyCorruptionModel.NoCorruption:\n                    ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                    ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case MasterKeyCorruptionModel.CA:\n                    ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                case MasterKeyCorruptionModel.AA:\n                    ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case MasterKeyCorruptionModel.mixed_CA:\n                    ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                    ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case MasterKeyCorruptionModel.mixed_AA:\n                    ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                    ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n                case _:\n                    pass\n\n        # Print corruption map \n\n        if self.corr_model != MasterKeyCorruptionModel.NoCorruption:\n            if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n                ret_string.append(\"\\nList of variables obtained via the corruption of AA[j]:\")    \n            else:\n                ret_string.append(\"\\nList of variables obtained via corruption:\")\n            for elem in self.corruption_map:\n                ret_string.append(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n\n        return '\\n'.join(ret_string)\n\n    def show_solution(self) -&gt; str:\n\"\"\"\n        Returns the result of the attack.\n\n        Returns:\n            solution (str): The result of the attack.\n        \"\"\"\n        return '\\n' + self.solution + '\\n'\n\n    def add_corruptable_var(self, origin: MasterKeyCorruptedVariable, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds a corruptable var from the master pair of CA or AA.\n        Then, calls either add_corruptable_variable_from_CA or\n        add_corruptable_variable_from_AA accordingly.\n        Finally, it adds an entry to the corruption map (`self.corruption_map`)\n\n        Parameters:\n            origin (MasterKeyCorruptedVariable): MSK/MPK_CA or MSK/PK_AA (Enum)\n            corr (sp.core.symbol.Symbol): Corruptable variable.\n        \"\"\"\n\n        # ensure origin belongs to MSK/MPK_CA or MSK/MPK_AA\n\n        corr_belongs = corr in self.MPK_CA or corr in self.MPK_AA or corr in self.MSK_CA or corr in self.MSK_AA\n        entry = None\n\n        if corr_belongs:\n            match origin:\n                case MasterKeyCorruptedVariable.MPK_CA:\n                    self.add_corruptable_variable_generic(corr)\n                    entry = {\"name\":corr, \"origin\":\"MPK_CA\"}\n\n                case MasterKeyCorruptedVariable.MPK_AA:\n                    self.add_corruptable_variable_generic(corr)\n                    entry = {\"name\":corr, \"origin\":\"MPK_AA\"}\n\n                case _:\n                    print(f\"Origin in MasterKeyCorruptedVariable not defined\")\n\n            if entry is not None:\n                self.corruption_map.append(entry)\n\n    def add_corruptable_variable_generic(self, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds CA variables that can be obtained by corruption.\n\n        Parameters:\n            corr (sp.core.symbol.Symbol): Corruptable variable.\n        \"\"\"\n        if self.unknown is not None:\n            self.unknown = list(filter((corr).__ne__, self.unknown))\n\n    def add_gp_variable(self, gpv: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds a global parameter to the attack.\n\n        Parameters:\n            gpv (symbol): global parameter variable.\n        \"\"\"\n        if self.keyenco is not None:\n            self.keyenco.append(gpv)\n\n        # add entry to translation table\n\n        table_entry = {\"name\":gpv.name, \"type\":\"gp\"}\n        self.translation_table.append(table_entry)\n\n    def add_mpk(self, mpkv: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds a master public key to the attack.\n\n        Parameters:\n            mpkv (sp.core.symbol.Symbol): mpk variable.\n        \"\"\"\n\n        if self.keyenco is not None:\n            self.keyenco.append(mpkv)\n\n         # add entry to translation table\n\n        if self.corr_model == (MasterKeyCorruptionModel.mixed_CA or MasterKeyCorruptionModel.mixed_AA):\n            table_entry = {\"name\":mpkv.name, \"type\":\"mpk_i_j\"}            \n        else:\n            table_entry = {\"name\":mpkv.name, \"type\":\"mpk\"}\n\n        self.translation_table.append(table_entry)\n\n    def add_mpk_CA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds a CA master public key.\n\n        Parameters:\n            elem (sp.core.symbol.Symbol): mpk CA variable.\n        \"\"\"\n        self.MPK_CA.append(elem)\n\n    def add_msk_CA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds a CA master secret key.\n\n        Parameters:\n            elem (sp.core.symbol.Symbol): msk CA variable.\n        \"\"\"\n        self.MSK_CA.append(elem)\n\n\n    def add_mpk_AA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds an AA master public key.\n\n        Parameters:\n            elem (sp.core.symbol.Symbol): mpk AA variable.\n        \"\"\"\n        self.MPK_AA.append(elem)\n\n    def add_msk_AA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds an AA master secret key.\n\n        Parameters:\n            elem (sp.core.symbol.Symbol): msk AA variable.\n        \"\"\"\n        self.MSK_AA.append(elem)\n\n    def set_corruption_model(self, corr_m) -&gt; None:\n\"\"\"\n        Sets the corruption model involved in the attack. By\n        the default the corruption model is MasterKeyCorruptionModel.NoCorruption.\n\n        Parameters:\n            corr_m (MasterKeyCorruptionModel): Corruption model.\n        \"\"\"\n        self.corr_model = corr_m\n\n    def gen_dict(self, k: list) -&gt; list:\n\"\"\"\n        Generates an annotated dictionary based on the encodings\n        of the given ABE scheme:\n\n        Parameters:\n            k (list): Key encodings of the ABE scheme.\n\n        Returns:\n            Annotated dictionary (list): Annotated dictionary of the ABE scheme with descriptions. \n        \"\"\"\n\n        if self.corr_model == MasterKeyCorruptionModel.mixed_AA or self.corr_model == MasterKeyCorruptionModel.mixed_CA:\n            all_k = []                                                               \n            for i in k:\n                if self.corr_model == MasterKeyCorruptionModel.mixed_CA:                                                                 \n                    entry = {\"op\": i,  \"dsc\": \"k\" + str(k.index(i)) + \"[i][j]\"}\n                else:\n                    entry = {\"op\": i,  \"dsc\": \"k\" + str(k.index(i)) + \"[i]\"}\n\n                for e in self.translation_table:\n                    if str(i) == e[\"name\"]:\n                        entry[\"dsc\"] =  e[\"type\"] # + str(k.index(i))\n\n                all_k.append(entry)                                              \n        else:\n            all_k = []                                                               \n            for i in k:                                                                \n                entry = {\"op\": i,  \"dsc\": \"k\" + str(k.index(i))}\n                all_k.append(entry)                                              \n\n        return all_k\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.__init__","title":"<code>__init__()</code>","text":"<p>The constructor for MasterKeyAttack class.</p> Source code in <code>master_key.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    The constructor for MasterKeyAttack class. \n    \"\"\"\n    self.masterkey = None \n    self.keyenco = None\n\n    # master key attacks relies on the\n    # decryption key attack class\n    # we save in keyenco_mk the original\n    # encoding that initialized the master\n    # key attack\n    self.keyenco_mk = None\n\n    self.unknown = None\n    self.solution = None\n    self.description = \"MasterKeyAttack\"\n\n    self.c = [] \n    self.mpk = [] \n    self.gp = [] \n    self.translation_table = []\n\n    self.MPK_CA = []\n    self.MSK_CA = []\n    self.MPK_AA = []\n    self.MSK_AA = []\n\n    self.corruption_map = []\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_corruptable_var","title":"<code>add_corruptable_var(origin, corr)</code>","text":"<p>Adds a corruptable var from the master pair of CA or AA. Then, calls either add_corruptable_variable_from_CA or add_corruptable_variable_from_AA accordingly. Finally, it adds an entry to the corruption map (<code>self.corruption_map</code>)</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>MasterKeyCorruptedVariable</code> <p>MSK/MPK_CA or MSK/PK_AA (Enum)</p> required <code>corr</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_corruptable_var(self, origin: MasterKeyCorruptedVariable, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds a corruptable var from the master pair of CA or AA.\n    Then, calls either add_corruptable_variable_from_CA or\n    add_corruptable_variable_from_AA accordingly.\n    Finally, it adds an entry to the corruption map (`self.corruption_map`)\n\n    Parameters:\n        origin (MasterKeyCorruptedVariable): MSK/MPK_CA or MSK/PK_AA (Enum)\n        corr (sp.core.symbol.Symbol): Corruptable variable.\n    \"\"\"\n\n    # ensure origin belongs to MSK/MPK_CA or MSK/MPK_AA\n\n    corr_belongs = corr in self.MPK_CA or corr in self.MPK_AA or corr in self.MSK_CA or corr in self.MSK_AA\n    entry = None\n\n    if corr_belongs:\n        match origin:\n            case MasterKeyCorruptedVariable.MPK_CA:\n                self.add_corruptable_variable_generic(corr)\n                entry = {\"name\":corr, \"origin\":\"MPK_CA\"}\n\n            case MasterKeyCorruptedVariable.MPK_AA:\n                self.add_corruptable_variable_generic(corr)\n                entry = {\"name\":corr, \"origin\":\"MPK_AA\"}\n\n            case _:\n                print(f\"Origin in MasterKeyCorruptedVariable not defined\")\n\n        if entry is not None:\n            self.corruption_map.append(entry)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_corruptable_variable_generic","title":"<code>add_corruptable_variable_generic(corr)</code>","text":"<p>Adds CA variables that can be obtained by corruption.</p> <p>Parameters:</p> Name Type Description Default <code>corr</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_corruptable_variable_generic(self, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds CA variables that can be obtained by corruption.\n\n    Parameters:\n        corr (sp.core.symbol.Symbol): Corruptable variable.\n    \"\"\"\n    if self.unknown is not None:\n        self.unknown = list(filter((corr).__ne__, self.unknown))\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_gp_variable","title":"<code>add_gp_variable(gpv)</code>","text":"<p>Adds a global parameter to the attack.</p> <p>Parameters:</p> Name Type Description Default <code>gpv</code> <code>symbol</code> <p>global parameter variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_gp_variable(self, gpv: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds a global parameter to the attack.\n\n    Parameters:\n        gpv (symbol): global parameter variable.\n    \"\"\"\n    if self.keyenco is not None:\n        self.keyenco.append(gpv)\n\n    # add entry to translation table\n\n    table_entry = {\"name\":gpv.name, \"type\":\"gp\"}\n    self.translation_table.append(table_entry)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_mpk","title":"<code>add_mpk(mpkv)</code>","text":"<p>Adds a master public key to the attack.</p> <p>Parameters:</p> Name Type Description Default <code>mpkv</code> <code>sp.core.symbol.Symbol</code> <p>mpk variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_mpk(self, mpkv: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds a master public key to the attack.\n\n    Parameters:\n        mpkv (sp.core.symbol.Symbol): mpk variable.\n    \"\"\"\n\n    if self.keyenco is not None:\n        self.keyenco.append(mpkv)\n\n     # add entry to translation table\n\n    if self.corr_model == (MasterKeyCorruptionModel.mixed_CA or MasterKeyCorruptionModel.mixed_AA):\n        table_entry = {\"name\":mpkv.name, \"type\":\"mpk_i_j\"}            \n    else:\n        table_entry = {\"name\":mpkv.name, \"type\":\"mpk\"}\n\n    self.translation_table.append(table_entry)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_mpk_AA","title":"<code>add_mpk_AA(elem)</code>","text":"<p>Adds an AA master public key.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>mpk AA variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_mpk_AA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds an AA master public key.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): mpk AA variable.\n    \"\"\"\n    self.MPK_AA.append(elem)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_mpk_CA","title":"<code>add_mpk_CA(elem)</code>","text":"<p>Adds a CA master public key.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>mpk CA variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_mpk_CA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds a CA master public key.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): mpk CA variable.\n    \"\"\"\n    self.MPK_CA.append(elem)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_msk_AA","title":"<code>add_msk_AA(elem)</code>","text":"<p>Adds an AA master secret key.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>msk AA variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_msk_AA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds an AA master secret key.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): msk AA variable.\n    \"\"\"\n    self.MSK_AA.append(elem)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.add_msk_CA","title":"<code>add_msk_CA(elem)</code>","text":"<p>Adds a CA master secret key.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>msk CA variable.</p> required Source code in <code>master_key.py</code> <pre><code>def add_msk_CA(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds a CA master secret key.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): msk CA variable.\n    \"\"\"\n    self.MSK_CA.append(elem)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.format_encodings","title":"<code>format_encodings()</code>","text":"<p>Prints the involved encodings in the given ABE scheme.</p> Source code in <code>master_key.py</code> <pre><code>def format_encodings(self) -&gt; None:\n\"\"\"\n    Prints the involved encodings in the given ABE scheme.\n    \"\"\"\n\n    if self.keyenco_mk:\n        print(\"\\nList of encodings:\")\n        for elem in self.keyenco_mk:\n            print(\"\\t\", elem[\"dsc\"], \":\", elem[\"op\"])\n\n    # Give details about the corruption model in relation to the\n    # attack\n\n    if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n        print(\"\\nFor the corruption of an attribute authority AA[j] and attacking an attribute authority AA[i].\")          \n\n    if self.corr_model == MasterKeyCorruptionModel.CA:\n        print(\"\\nFor the corruption of the Central Authority.\")                       \n\n    if self.corr_model == MasterKeyCorruptionModel.mixed_CA:\n        print(\"\\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\")    \n\n\n\n    if self.translation_table:\n        dict_index = 0\n        print(\"\\nInformation on additional encodings:\")\n        for elem in self.translation_table:\n            print(f'\\t[*] {elem[\"name\"]} corresponds to {elem[\"type\"]}{dict_index}')\n            dict_index = dict_index + 1\n        print(\"\\nNOTE: Global parameters gp[i] are added to the matrix as key encodings and could appear as k[i] elements.\")\n\n    # Print the contents of the master key pairs according to the\n    # corruption model:\n\n    if self.MPK_AA or self.MSK_AA or self.MPK_CA or self.MSK_CA:\n\n        print(\"\\nStructure of CA/AAs:\")\n\n        match self.corr_model:\n            case MasterKeyCorruptionModel.NoCorruption:\n                print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case MasterKeyCorruptionModel.CA:\n                print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n            case MasterKeyCorruptionModel.AA:\n                print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case MasterKeyCorruptionModel.mixed_CA:\n                print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case MasterKeyCorruptionModel.mixed_AA:\n                print(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                print(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case _:\n                pass\n\n    # Print corruption map \n\n    if self.corr_model != MasterKeyCorruptionModel.NoCorruption:\n        if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n            print(\"\\nList of variables obtained via the corruption of AA[j]:\")    \n        else:\n            print(\"\\nList of variables obtained via corruption:\")\n        for elem in self.corruption_map:\n            print(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.format_encodings_string","title":"<code>format_encodings_string()</code>","text":"<p>Return a string with the involved encodings in the given ABE scheme.</p> Source code in <code>master_key.py</code> <pre><code>def format_encodings_string(self) -&gt; str:\n\"\"\"\n    Return a string with the involved encodings in the given ABE scheme.\n    \"\"\"\n\n    ret_string = []\n\n    if self.keyenco_mk:\n        ret_string.append(\"\\nList of encodings:\")\n        for elem in self.keyenco_mk:\n            ret_string.append(\"\\t \" + str(elem[\"dsc\"]) + \" : \" + str(elem[\"op\"]))\n\n    # Give details about the corruption model in relation to the\n    # attack\n\n    if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n        ret_string.append(\"\\nFor the corruption of an attribute authority AA[j] and attacking an attribute authority AA[i].\")          \n\n    if self.corr_model == MasterKeyCorruptionModel.CA:\n        ret_string.append(\"\\nFor the corruption of the Central Authority.\")                       \n\n    if self.corr_model == MasterKeyCorruptionModel.mixed_CA:\n        ret_string.append(\"\\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\")    \n\n\n\n    if self.translation_table:\n        dict_index = 0\n        ret_string.append(\"\\nInformation on additional encodings:\")\n        for elem in self.translation_table:\n            ret_string.append(f'\\t[*] {elem[\"name\"]} corresponds to {elem[\"type\"]}{dict_index}')\n            dict_index = dict_index + 1\n        ret_string.append(\"\\nNOTE: Global parameters gp[i] are added to the matrix as key encodings and could appear as k[i] elements.\")\n\n    # Print the contents of the master key pairs according to the\n    # corruption model:\n\n    if self.MPK_AA or self.MSK_AA or self.MPK_CA or self.MSK_CA:\n\n        ret_string.append(\"\\nStructure of CA/AAs:\\n\")\n\n        match self.corr_model:\n            case MasterKeyCorruptionModel.NoCorruption:\n                ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case MasterKeyCorruptionModel.CA:\n                ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n            case MasterKeyCorruptionModel.AA:\n                ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case MasterKeyCorruptionModel.mixed_CA:\n                ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case MasterKeyCorruptionModel.mixed_AA:\n                ret_string.append(f\"\\tContents of the CA MPK encodings: {self.MPK_CA}\")\n                ret_string.append(f\"\\tContents of the AA MPK encodings: {self.MPK_AA}\")\n            case _:\n                pass\n\n    # Print corruption map \n\n    if self.corr_model != MasterKeyCorruptionModel.NoCorruption:\n        if self.corr_model == MasterKeyCorruptionModel.mixed_AA:\n            ret_string.append(\"\\nList of variables obtained via the corruption of AA[j]:\")    \n        else:\n            ret_string.append(\"\\nList of variables obtained via corruption:\")\n        for elem in self.corruption_map:\n            ret_string.append(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n\n    return '\\n'.join(ret_string)\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.gen_dict","title":"<code>gen_dict(k)</code>","text":"<p>Generates an annotated dictionary based on the encodings of the given ABE scheme:</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>list</code> <p>Key encodings of the ABE scheme.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Annotated dictionary (list): Annotated dictionary of the ABE scheme with descriptions.</p> Source code in <code>master_key.py</code> <pre><code>def gen_dict(self, k: list) -&gt; list:\n\"\"\"\n    Generates an annotated dictionary based on the encodings\n    of the given ABE scheme:\n\n    Parameters:\n        k (list): Key encodings of the ABE scheme.\n\n    Returns:\n        Annotated dictionary (list): Annotated dictionary of the ABE scheme with descriptions. \n    \"\"\"\n\n    if self.corr_model == MasterKeyCorruptionModel.mixed_AA or self.corr_model == MasterKeyCorruptionModel.mixed_CA:\n        all_k = []                                                               \n        for i in k:\n            if self.corr_model == MasterKeyCorruptionModel.mixed_CA:                                                                 \n                entry = {\"op\": i,  \"dsc\": \"k\" + str(k.index(i)) + \"[i][j]\"}\n            else:\n                entry = {\"op\": i,  \"dsc\": \"k\" + str(k.index(i)) + \"[i]\"}\n\n            for e in self.translation_table:\n                if str(i) == e[\"name\"]:\n                    entry[\"dsc\"] =  e[\"type\"] # + str(k.index(i))\n\n            all_k.append(entry)                                              \n    else:\n        all_k = []                                                               \n        for i in k:                                                                \n            entry = {\"op\": i,  \"dsc\": \"k\" + str(k.index(i))}\n            all_k.append(entry)                                              \n\n    return all_k\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.init","title":"<code>init(masterkey, keyenco, unknown)</code>","text":"<p>Initializes a master key attack based on:</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>list</code> <p>The master key to find.</p> required <code>keyenco</code> <code>list</code> <p>The key encodings.</p> required <code>unknown</code> <code>list</code> <p>The list of not known variables of the ABE scheme.</p> required Source code in <code>master_key.py</code> <pre><code>def init(self, masterkey: list, keyenco: list, unknown: list) -&gt; None:\n\"\"\"\n    Initializes a master key attack based on:\n\n    Parameters:\n        masterkey (list): The master key to find.\n        keyenco (list): The key encodings.\n        unknown (list): The list of not known variables of the ABE scheme.\n    \"\"\"\n    self.masterkey = masterkey\n    self.keyenco = keyenco\n    self.unknown = unknown\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.run","title":"<code>run()</code>","text":"<p>Tries to find a master key attack on the given ABE scheme. It reuses the implementation of the decryption attack with the flag master_key_attack_only set as True.</p> Source code in <code>master_key.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    Tries to find a master key attack on the given ABE scheme.\n    It reuses the implementation of the decryption attack with the\n    flag master_key_attack_only set as True.\n    \"\"\"\n    decryption_attack = DecryptionAttack()\n\n    self.keyenco = self.gen_dict(self.keyenco)\n\n    # save encodings here before passing them\n    # to decryption class. It will be used for\n    # printing pourposes in format_encodings\n    self.keyenco_mk = copy.deepcopy(self.keyenco)\n\n    decryption_attack.init(self.masterkey, self.keyenco, self.c, self.mpk, self.gp, self.unknown, master_key_attack_only=True)                            \n    decryption_attack.set_sol_msg(self.SOL_MSG)\n    decryption_attack.set_not_found_msg(self.NOT_FOUND_MSG)\n\n    decryption_attack.run()                                                            \n    self.solution = decryption_attack.show_solution()          \n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.set_corruption_model","title":"<code>set_corruption_model(corr_m)</code>","text":"<p>Sets the corruption model involved in the attack. By the default the corruption model is MasterKeyCorruptionModel.NoCorruption.</p> <p>Parameters:</p> Name Type Description Default <code>corr_m</code> <code>MasterKeyCorruptionModel</code> <p>Corruption model.</p> required Source code in <code>master_key.py</code> <pre><code>def set_corruption_model(self, corr_m) -&gt; None:\n\"\"\"\n    Sets the corruption model involved in the attack. By\n    the default the corruption model is MasterKeyCorruptionModel.NoCorruption.\n\n    Parameters:\n        corr_m (MasterKeyCorruptionModel): Corruption model.\n    \"\"\"\n    self.corr_model = corr_m\n</code></pre>"},{"location":"reference/#master_key.MasterKeyAttack.show_solution","title":"<code>show_solution()</code>","text":"<p>Returns the result of the attack.</p> <p>Returns:</p> Name Type Description <code>solution</code> <code>str</code> <p>The result of the attack.</p> Source code in <code>master_key.py</code> <pre><code>def show_solution(self) -&gt; str:\n\"\"\"\n    Returns the result of the attack.\n\n    Returns:\n        solution (str): The result of the attack.\n    \"\"\"\n    return '\\n' + self.solution + '\\n'\n</code></pre>"},{"location":"reference/#master_key.MasterKeyCorruptedVariable","title":"<code>MasterKeyCorruptedVariable</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Describes the origin of corruptable variables in master key attacks.</p> <p>Attributes:</p> Name Type Description <code>MPK_CA</code> <code>int</code> <p>The variable is part of the corruption of the Central Authority (CA).</p> <code>MPK_AA</code> <code>int</code> <p>The variable belongs to an Attribute Authority j. It will be used to obtain the master key of an AA[i].</p> Source code in <code>master_key.py</code> <pre><code>class MasterKeyCorruptedVariable(Enum):\n\"\"\"\n    Describes the origin of corruptable variables in master key attacks.\n\n    Attributes:\n        MPK_CA (int): The variable is part of the corruption of the Central Authority (CA).\n        MPK_AA (int): The variable belongs to an Attribute Authority j. It will be used to obtain the master key of an AA[i].\n    \"\"\"\n\n    MPK_CA = 1\n    MPK_AA = 2\n</code></pre>"},{"location":"reference/#master_key.MasterKeyCorruptionModel","title":"<code>MasterKeyCorruptionModel</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Allowed corruption models in master key attacks.</p> <p>Attributes:</p> Name Type Description <code>NoCorruption</code> <code>int</code> <p>Corruption is not possible.</p> <code>CA</code> <code>int</code> <p>Corruption of the Central Authority (CA).</p> <code>AA</code> <code>int</code> <p>Simple corruption of the Attribute Authority (AA).</p> <code>mixed_CA</code> <code>int</code> <p>CA/CAs and AAs are involved. However only CA/CAs are corruptable.</p> <code>mixed_AA</code> <code>int</code> <p>CA/CAs and AAs are involved. However only AAs are corruptable.</p> Source code in <code>master_key.py</code> <pre><code>class MasterKeyCorruptionModel(Enum):\n\"\"\"\n    Allowed corruption models in master key attacks.\n\n    Attributes:\n        NoCorruption (int): Corruption is not possible.\n        CA (int): Corruption of the Central Authority (CA).\n        AA (int): Simple corruption of the Attribute Authority (AA).\n        mixed_CA (int): CA/CAs and AAs are involved. However only CA/CAs are corruptable.\n        mixed_AA (int): CA/CAs and AAs are involved. However only AAs are corruptable.\n    \"\"\"\n    NoCorruption = 1\n    CA = 2\n    AA = 3\n    mixed_CA = 4\n    mixed_AA = 5\n</code></pre>"},{"location":"reference/#decryption-key-attacks","title":"Decryption key attacks","text":""},{"location":"reference/#decryption.DecryptionAttack","title":"<code>DecryptionAttack</code>","text":"<p>             Bases: <code>Attack</code></p> <p>Finds master key attacks in ABE schemes, optionally assuming the corruption of the central authority (CA).</p> <p>Attributes:</p> Name Type Description <code>SOL_MSG</code> <code>str</code> <p>Message to report if a decryption key attack is found.</p> <code>NOT_FOUND_MSG</code> <code>str</code> <p>Message to report if a decryption key attack is not found.</p> <code>corr_model</code> <code>int</code> <p>Corruption model involved in the attack.</p> <code>key</code> <code>sp.core.symbol.Symbol</code> <p>Key to recover. </p> <code>all_p(list)</code> <code>sp.core.symbol.Symbol</code> <p>All the possible combinations of the supplied encodings (of type sp.core.symbol.Symbol) related to key, ciphertext, global parameters and master public key components.</p> <code>unknown(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of variables (of type sp.core.symbol.Symbol) that are supposed to be unknown to the attacker.</p> <code>sol(string)</code> <code>sp.core.symbol.Symbol</code> <p>Solution of the attack, if found.</p> <code>k_encodings(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of sp.core.symbol.Symbol types representing the key encodings.</p> <code>c_encodings(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of sp.core.symbol.Symbol types representing the ciphertext components.</p> <code>mpk_encodings(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of sp.core.symbol.Symbol types representing the  master public key components involved in the attack (they could be related to corruption of the authorities). </p> <code>gp_encodings(list)</code> <code>sp.core.symbol.Symbol</code> <p>List of sp.core.symbol.Symbol types representing the  global parameter components involved in the attack (they could be related to corruption of the authorities).</p> Source code in <code>decryption.py</code> <pre><code>class DecryptionAttack(Attack):\n\"\"\"\n        Finds master key attacks in ABE schemes, optionally\n        assuming the corruption of the central authority (CA).\n\n        Attributes:\n            SOL_MSG (str): Message to report if a decryption key attack is found.\n            NOT_FOUND_MSG (str): Message to report if a decryption key attack is not found.\n            corr_model (int): Corruption model involved in the attack.\n            key (sp.core.symbol.Symbol): Key to recover. \n            all_p(list): All the possible combinations of the supplied encodings (of type\n                sp.core.symbol.Symbol) related to key, ciphertext, global parameters and master public key components.\n            unknown(list): List of variables (of type sp.core.symbol.Symbol) that are\n                supposed to be unknown to the attacker.\n            sol(string): Solution of the attack, if found.\n            k_encodings(list): List of sp.core.symbol.Symbol types representing the key\n                encodings.\n            c_encodings(list): List of sp.core.symbol.Symbol types representing the\n                ciphertext components.\n            mpk_encodings(list): List of sp.core.symbol.Symbol types representing the \n                master public key components involved in the attack (they could be related\n                to corruption of the authorities). \n            gp_encodings(list): List of sp.core.symbol.Symbol types representing the \n                global parameter components involved in the attack (they could be related\n                to corruption of the authorities).    \n        \"\"\"\n\n        SOL_MSG = \"[*] Decryption attack found: \"\n        NOT_FOUND_MSG = \"[!] No decryption attack found\"\n        corr_model = DecryptionKeyCorruptionModel.NoCorruption\n        key = None\n        all_p =  None\n        unknown = None\n        sol = None\n        k_encodings = None\n        c_encodings = None\n        mpk_encodings = None\n        gp_encodings = None\n        is_master_key_attack = False\n\n        MPK_AAi = []\n        MSK_AAi= []\n        MPK_AAj = []\n        MSK_AAj= []\n        misc = []\n\n        # utilized for keeping track of the type\n        # of variables that enters the attack\n        # via corruption of CA or AA\n\n        # a corruption map contains dictionary entries\n        # of the form {\"name\", \"origin\"} where origins\n        # corresponds to one of the entries of the\n        # `DecryptionKeyCorruptedVariable enumeration\n\n        corruption_map = []\n\n        def init(self, key, k_encodings, c_encodings, mpk_encodings, gp_encodings, unknown, master_key_attack_only = False) -&gt; None:\n            self.key = key\n            self.unknown = unknown\n            self.description = \"DecryptionAttack\"\n\n            self.k_encodings = k_encodings\n            self.c_encodings = c_encodings\n            self.mpk_encodings = mpk_encodings\n            self.gp_encodings = gp_encodings\n            self.is_master_key_attack = master_key_attack_only\n\n            if master_key_attack_only == False:\n                self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n            else:\n                self.all_p = self.k_encodings\n\n        def __init__(self) -&gt; None:\n\"\"\"\n            The constructor for DecryptionAttack class. \n            \"\"\"\n            self.key = None\n            self.all_p =  None\n            self.unknown = None\n            self.sol = None\n            self.k_encodings = None\n            self.c_encodings = None\n            self.mpk_encodings = None\n            self.gp_encodings = None\n            self.is_master_key_attack = False\n\n            self.MPK_AAi = []\n            self.MSK_AAi = []\n            self.MPK_AAj= []\n            self.MSK_AAj= []\n\n            self.misc = []\n\n            self.corruption_map = []\n\n        def show_solution(self) -&gt; str:\n\"\"\"\n            Returns the result of the attack.\n\n            Returns:\n                solution (str): The result of the attack.\n            \"\"\"\n            return '\\n' + self.sol + '\\n'\n\n        def format_encodings(self) -&gt; None:\n\"\"\"\n            Prints the involved encodings in the given ABE scheme.\n            \"\"\"\n            if self.all_p:\n                print(\"List of encodings:\")\n                for elem in self.all_p:\n                    print(\"\\t\", elem[\"dsc\"], \":\", elem[\"op\"])        \n\n            if self.k_encodings:\n                for elem in self.k_encodings:\n                    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                        print(\"\\t\", \"k\" + \"[i]\" + str(self.k_encodings.index(elem)), \":\",  elem)       \n                    else:\n                        print(\"\\t\", \"k\" + str(self.k_encodings.index(elem)), \":\",  elem)       \n\n\n            if self.c_encodings:\n                for elem in self.c_encodings:\n                    print(\"\\t\", \"c\" + str(self.c_encodings.index(elem)), \":\",  elem)                        \n\n            if self.mpk_encodings:\n                for elem in self.mpk_encodings:\n                    print(\"\\t\", \"mpk\" + str(self.mpk_encodings.index(elem)), \":\",  elem)                        \n\n            if self.gp_encodings:\n                for elem in self.gp_encodings:\n                    print(\"\\t\", \"gp\" + str(self.gp_encodings.index(elem)), \":\",  elem)\n\n            # Give details about the corruption model in relation to the\n            # attack\n\n            if self.corr_model == DecryptionKeyCorruptionModel.AA:\n                print(\"\\nFor the corruption of an attribute authority AA[i].\")          \n\n            if self.corr_model == DecryptionKeyCorruptionModel.AA_extended:\n                print(\"\\nFor the corruption of an attribute authority AA[i] where c0 and c1 are obtained from different attribute authorities.\")                                    \n\n            # Print the contents of the master key pairs according to the\n            # corruption model:\n\n            if self.MPK_AAi or self.MSK_AAi or self.MPK_AAj or self.MSK_AAj:\n\n                print(\"\\nStructure of CA/AAs:\")\n\n                match self.corr_model:\n                    case DecryptionKeyCorruptionModel.AA:\n                        print(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n                    case DecryptionKeyCorruptionModel.AA_extended:\n                        print(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n                        print(f\"\\tMaster key pair of AA[j]: mpk[j]: {self.MPK_AAj}\")\n                    case _:\n                        pass\n\n            # Print corruption map \n\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                print(\"\\nList of variables obtained via corruption:\")\n                for elem in self.corruption_map:\n                    print(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n\n\n        def format_encodings_string(self) -&gt; str:\n\"\"\"\n            Return a string with the involved encodings in the given ABE scheme.\n            \"\"\"\n\n            ret_string = []\n\n            if self.all_p:\n                ret_string.append(\"List of encodings:\")\n                for elem in self.all_p:\n                    ret_string.append(\"\\t \" + str(elem[\"dsc\"]) + \" : \" + str(elem[\"op\"]))\n\n            if self.k_encodings:\n                for elem in self.k_encodings:\n                    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                        ret_string.append(\"\\t\" + \" k\" + \"[i]\" + str(self.k_encodings.index(elem)) + \" : \" + str(elem))       \n                    else:\n                        ret_string.append(\"\\t\" + \"k\" + str(self.k_encodings.index(elem)) + \" : \" + str(elem))       \n\n\n            if self.c_encodings:\n                for elem in self.c_encodings:\n                    ret_string.append(\"\\t\" + \"c\" + str(self.c_encodings.index(elem)) + \" : \" + str(elem))                        \n\n            if self.mpk_encodings:\n                for elem in self.mpk_encodings:\n                    ret_string.append(\"\\t\" + \"mpk\" + str(self.mpk_encodings.index(elem)) + \" : \" + str(elem))                        \n\n            if self.gp_encodings:\n                for elem in self.gp_encodings:\n                    ret_string.append(\"\\t\" + \"gp\" + str(self.gp_encodings.index(elem)) + \" : \"  + str(elem))\n\n            # Give details about the corruption model in relation to the\n            # attack\n\n            if self.corr_model == DecryptionKeyCorruptionModel.AA:\n                ret_string.append(\"\\nFor the corruption of an attribute authority AA[i].\")          \n\n            if self.corr_model == DecryptionKeyCorruptionModel.AA_extended:\n                ret_string.append(\"\\nFor the corruption of an attribute authority AA[i] where c0 and c1 are obtained from different attribute authorities.\")                                    \n\n            # Print the contents of the master key pairs according to the\n            # corruption model:\n\n            if self.MPK_AAi or self.MSK_AAi or self.MPK_AAj or self.MSK_AAj:\n\n                ret_string.append(\"\\nStructure of CA/AAs:\")\n\n                match self.corr_model:\n                    case DecryptionKeyCorruptionModel.AA:\n                        ret_string.append(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n                    case DecryptionKeyCorruptionModel.AA_extended:\n                        ret_string.append(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n                        ret_string.append(f\"\\tMaster key pair of AA[j]: mpk[j]: {self.MPK_AAj}\")\n                    case _:\n                        pass\n\n            # Print corruption map \n\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                ret_string.append(\"\\nList of variables obtained via corruption:\")\n                for elem in self.corruption_map:\n                    ret_string.append(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n\n            return '\\n'.join(ret_string)\n\n        def add_corruptable_var_generic(self, corr: sp.core.symbol.Symbol):\n\"\"\"\n            Adds CA variables that can be obtained by corruption.\n\n            Parameters:\n                corr (sp.core.symbol.Symbol): Corruptable variable.\n            \"\"\"\n            if self.unknown is not None:\n                self.unknown = list(filter((corr).__ne__, self.unknown))\n\n            if self.is_master_key_attack == False:\n                self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n            else:\n                self.all_p = self.k_encodings\n\n        def add_mpk_variable(self, mpkv: sp.core.symbol.Symbol):\n\"\"\"\n            Adds mpk variables that could be obtained by corruption.\n\n            Parameters:\n                mpkv (sp.core.symbol.Symbol): Corruptable variable.\n            \"\"\"\n            if self.mpk_encodings is not None:\n                self.mpk_encodings.append(mpkv)\n\n            # regenerate encodings\n\n            self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n\n\n        def add_gp_variable(self, gpv: list):\n\"\"\"\n            Adds gp variables that could be obtained by corruption.\n\n            Parameters:\n                gpv (sp.core.symbol.Symbol): Corruptable variable.\n            \"\"\"\n            if self.gp_encodings is not None:\n                self.gp_encodings.append(gpv)\n\n            # regenerate encodings\n\n            self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n\n\n        def set_sol_msg(self, msg: str) -&gt; None:\n\"\"\"\n            Allows to set the found solution message.\n\n            Parameters:\n                msg (str): Message.\n            \"\"\"\n            self.SOL_MSG = msg\n\n        def set_not_found_msg(self, msg: str) -&gt; None:\n\"\"\"\n            Allows to set the not found solution message.\n\n            Parameters:\n                msg (str): Message.\n            \"\"\"\n            self.NOT_FOUND_MSG = msg\n\n        def transform_encoding_list(self, denomprod, p):\n\"\"\"\n            Function that 'normalizes' the encodings\n            (by multiplying everything with the product of\n            denominators^2 (because each element in p is paired already))\n            (master key is multiplied by the product^2).\n\n            Parameters:\n                denomprod (sp.core.symbol.Symbo): product of denominators.\n                 p (list): list of all possible combinations between the encodings.\n            \"\"\"\n            pcpy = []\n\n            for pp in p:\n                pcpy.append(cancel(pp * denomprod))\n\n            return canonical(pcpy)\n\n        def decryption_attack_generalized_alt(self, masterkey, p, unknown):\n\"\"\"\n            Tries to find a decryption attack in the supplied parameters of\n            a particular ABE scheme.\n\n            Parameters:\n                masterkey (sp.core.symbol.Symbo): Master key to find.\n                p (list): list of all possible combinations between the encodings (sp.core.symbol.Symbo).\n                unkonwn (list): list of unkown components for the attacker (sp.core.symbol.Symbo).\n            \"\"\"\n            p = canonical(p)\n\n            # function to select all denoms\n            denoms = collect_denoms(p, unknown)\n            denomprod = denoms_prod(denoms)\n\n            # function that 'normalizes' the encodings\n            # (by multiplying everything with the product of\n            # denominators**2 (because each element in p is paired already))\n            # (master key is multiplied by the product**2)\n            p = self.transform_encoding_list(denomprod**2, p)\n            masterkey = canonical([cancel(masterkey * denomprod**2)])[0]\n\n            (mat, uvector) = writeencodingasprod(p, unknown)\n            # could run either of the following lines - using 'new' here for certainty\n            # (mat,uvector) = reordermatuvec_new(masterkey,mat,uvector)\n            # (mat, uvector) = reorder_mat_uvec_with_alpha(masterkey, mat, uvector)\n\n            m1 = mat\n            m2 = uvector\n\n            m1_m = Matrix(mat)\n            m2_m = Matrix(uvector)\n\n            mat = Matrix(mat)\n\n            # attack target_vector\n            # use here the function from find_solution or something\n            luvec1 = len(uvector)\n            target_vector = Matrix([writepolyasprod(masterkey, uvector, unknown)])\n            luvec2 = len(uvector)\n            if luvec1 != luvec2:\n                return False, None, None, None\n\n            mat2 = mat.row_insert(shape(mat)[0], target_vector)\n\n            ## testing code\n            # \"\"\"\n            (mat2, uvector, lis_del_rows, lis_del_cols) = trim_matrix_and_uvector(mat2, uvector)\n            m2_m = Matrix(uvector)\n\n            for ind in lis_del_cols:\n                target_vector.col_del(ind)\n                m1_m.col_del(ind)\n\n            for ind in lis_del_rows:\n                del self.all_p[ind]\n                m1_m.row_del(ind)\n            # \"\"\"\n            ## testing code\n\n            ns = mat2.transpose().nullspace()\n\n            matns = Matrix([v.transpose() for v in ns])\n\n            err, f_sol = find_attack_row(matns)\n            if err:\n                return False, None, None, None\n\n            n_l = shape(m2_m)[0]\n            n_d = shape(mat)[1]\n            check_v = zeros(1, n_l)\n\n            for i in range(0, len(f_sol)):\n                check_v += f_sol[i] * mat2.row(i)\n\n            ctr = 0\n            for ind in check_v:\n                check_v[ctr] = cancel(check_v[ctr])\n                ctr += 1\n\n            m1 = m1_m.tolist()\n            m2 = m2_m.tolist()\n\n            if check_v == target_vector:\n                return True, m1, m2, f_sol\n            else:\n                return False, None, None, None\n\n\n        # version of the super_matrix algorithm with\n        # decryption_attack_generalized\n\n        def run(self) -&gt; None:\n\"\"\"\n            Tries to find a decryption attack with the supplied\n            ABE scheme parameters.\n            \"\"\"\n            op = [a_dict[\"op\"] for a_dict in self.all_p]\n            dsc = [a_dict[\"dsc\"] for a_dict in self.all_p]\n\n            result, m, v, sol = self.decryption_attack_generalized_alt(self.key, op, self.unknown)\n            if result == True:\n                dsc = [a_dict[\"dsc\"] for a_dict in self.all_p]\n                self.sol = super().format_solution(dsc, sol, self.SOL_MSG)\n            else:\n                self.sol =  self.NOT_FOUND_MSG\n\n        def set_corruption_model(self, corr_m) -&gt; None:\n\"\"\"\n            Sets the corruption model involved in the attack. By\n            the default the corruption model is DecryptionKeyCorruptionModel.NoCorruption.\n\n            Parameters:\n                corr_m (DecryptionKeyCorruptionModel): Corruption model.\n            \"\"\"\n            self.corr_model = corr_m\n\n        def gen_all_p_ex_dict(self, k: list, c: list, mpk: list, gp: list) -&gt; list:\n\"\"\"\n            Generates all the possible combinations given key, ciphertext, mpk\n            and global parameter related encodings.\n\n            Parameters:\n                k (list): Key encodings of type sp.core.symbol.Symbol.\n                c (list): Ciphertext encodings of type sp.core.symbol.Symbol.\n                mpk (list): mpk encodings of type sp.core.symbol.Symbol.\n                gp (list): gp encodings of type sp.core.symbol.Symbol.\n            \"\"\"   \n\n            # k*c\n\n            all_k_c = []\n            for i in k:\n                for j in c:\n                    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                        entry = {\"op\": i * j, \"dsc\": \"k\" + str(k.index(i)) + \"[i]\" + \"*c\" + str(c.index(j))}\n                    else:\n                        entry = {\"op\": i * j, \"dsc\": \"k\" + str(k.index(i)) + \"*c\" + str(c.index(j))}\n\n                    all_k_c.append(entry)\n\n            # k*mpk\n\n            all_k_mpk = []\n            for i in k:\n                for j in mpk:\n                    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                        entry = {\n                            \"op\": i * j,\n                            \"dsc\": \"k\" + str(k.index(i)) + \"[i]\" + \"*mpk\" + str(mpk.index(j)),\n                        }\n                    else:\n                        entry = {\n                            \"op\": i * j,\n                            \"dsc\": \"k\" + str(k.index(i)) + \"*mpk\" + str(mpk.index(j)),\n                        }                        \n                    all_k_mpk.append(entry)\n\n            # c*mpk\n\n            all_mpk_c = []\n            for i in c:\n                for j in mpk:\n                    entry = {\n                        \"op\": i * j,\n                        \"dsc\": \"c\" + str(c.index(i)) + \"*mpk\" + str(mpk.index(j)),\n                    }\n                    all_mpk_c.append(entry)\n\n            # c*gp\n\n            all_gp_c = []\n            for i in c:\n                for j in gp:\n                    entry = {\n                        \"op\": i * j,\n                        \"dsc\": \"c\" + str(c.index(i)) + \"*gp\" + str(gp.index(j)),\n                    }\n                    all_gp_c.append(entry)\n\n            # k*gp\n\n            all_gp_k = []\n            for i in k:\n                for j in gp:\n                    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                        entry = {\n                            \"op\": i * j,\n                            \"dsc\": \"k\" + str(k.index(i)) + \"[i]\" + \"*gp\" + str(gp.index(j)),\n                        }\n                    else:\n                        entry = {\n                            \"op\": i * j,\n                            \"dsc\": \"k\" + str(k.index(i)) + \"*gp\" + str(gp.index(j)),\n                        }                    \n                    all_gp_k.append(entry)\n\n            return all_k_c + all_k_mpk + all_mpk_c + all_gp_c + all_gp_k\n\n        def add_corruptable_var(self, origin: DecryptionKeyCorruptionModel, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n                Adds a corruptable var from the master pair of a AA[i]\n                or another related variable obtained via corruption.\n                Then, it calls the correspondent function.\n                Finally, it adds an entry to the corruption map (`self.corruption_map`)\n\n                Parameters:\n                    origin (DecryptionKeyCorruptedVariable): MSK/MPK_AAi or misc(Enum)\n                    corr (sp.core.symbol.Symbol): Corruptable variable.\n                \"\"\"\n\n                # ensure origin belongs to possible values\n\n                corr_belongs = corr in self.MPK_AAi or corr in self.misc\n                entry = None\n\n                if corr_belongs:\n                    match origin:\n                        case DecryptionKeyCorruptedVariable.MPK_AAi:\n                            self.add_corruptable_var_generic(corr)\n                            entry = {\"name\":corr, \"origin\":\"MPK_AAi\"}\n\n                        case DecryptionKeyCorruptedVariable.misc:\n                            self.add_corruptable_var_generic(corr)\n                            entry = {\"name\":corr, \"origin\":\"AAi\"}\n\n                        case _:\n                            print(f\"Origin in DecryptionKeyCorruptedVariable not defined\")\n\n                    if entry is not None:\n                        self.corruption_map.append(entry)\n\n        def add_mpk_AAi(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n            Describes the structure of AAi in the AA_extended corruption\n            model. It is related to the encoding of MPK_i, for the\n            corrupted A_i authority.\n\n            Parameters:\n                elem (sp.core.symbol.Symbol): mpk AA variable.\n            \"\"\"\n            self.MPK_AAi.append(elem)\n\n        def add_mpk_AAj(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n            Describes the structure of AAj in the AA_extended corruption\n            model. It is related to the encoding of MPK_j, for the\n            honest A_j authority.\n\n            Parameters:\n                elem (sp.core.symbol.Symbol): mpk AA variable.\n            \"\"\"\n            self.MPK_AAj.append(elem)\n\n        def add_misc(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n            Adds an AA master secret key.\n\n            Parameters:\n                elem (sp.core.symbol.Symbol): msk AA variable.\n            \"\"\"\n            self.misc.append(elem)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.__init__","title":"<code>__init__()</code>","text":"<p>The constructor for DecryptionAttack class.</p> Source code in <code>decryption.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    The constructor for DecryptionAttack class. \n    \"\"\"\n    self.key = None\n    self.all_p =  None\n    self.unknown = None\n    self.sol = None\n    self.k_encodings = None\n    self.c_encodings = None\n    self.mpk_encodings = None\n    self.gp_encodings = None\n    self.is_master_key_attack = False\n\n    self.MPK_AAi = []\n    self.MSK_AAi = []\n    self.MPK_AAj= []\n    self.MSK_AAj= []\n\n    self.misc = []\n\n    self.corruption_map = []\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_corruptable_var","title":"<code>add_corruptable_var(origin, corr)</code>","text":"<p>Adds a corruptable var from the master pair of a AA[i] or another related variable obtained via corruption. Then, it calls the correspondent function. Finally, it adds an entry to the corruption map (<code>self.corruption_map</code>)</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>DecryptionKeyCorruptedVariable</code> <p>MSK/MPK_AAi or misc(Enum)</p> required <code>corr</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_corruptable_var(self, origin: DecryptionKeyCorruptionModel, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n        Adds a corruptable var from the master pair of a AA[i]\n        or another related variable obtained via corruption.\n        Then, it calls the correspondent function.\n        Finally, it adds an entry to the corruption map (`self.corruption_map`)\n\n        Parameters:\n            origin (DecryptionKeyCorruptedVariable): MSK/MPK_AAi or misc(Enum)\n            corr (sp.core.symbol.Symbol): Corruptable variable.\n        \"\"\"\n\n        # ensure origin belongs to possible values\n\n        corr_belongs = corr in self.MPK_AAi or corr in self.misc\n        entry = None\n\n        if corr_belongs:\n            match origin:\n                case DecryptionKeyCorruptedVariable.MPK_AAi:\n                    self.add_corruptable_var_generic(corr)\n                    entry = {\"name\":corr, \"origin\":\"MPK_AAi\"}\n\n                case DecryptionKeyCorruptedVariable.misc:\n                    self.add_corruptable_var_generic(corr)\n                    entry = {\"name\":corr, \"origin\":\"AAi\"}\n\n                case _:\n                    print(f\"Origin in DecryptionKeyCorruptedVariable not defined\")\n\n            if entry is not None:\n                self.corruption_map.append(entry)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_corruptable_var_generic","title":"<code>add_corruptable_var_generic(corr)</code>","text":"<p>Adds CA variables that can be obtained by corruption.</p> <p>Parameters:</p> Name Type Description Default <code>corr</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_corruptable_var_generic(self, corr: sp.core.symbol.Symbol):\n\"\"\"\n    Adds CA variables that can be obtained by corruption.\n\n    Parameters:\n        corr (sp.core.symbol.Symbol): Corruptable variable.\n    \"\"\"\n    if self.unknown is not None:\n        self.unknown = list(filter((corr).__ne__, self.unknown))\n\n    if self.is_master_key_attack == False:\n        self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n    else:\n        self.all_p = self.k_encodings\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_gp_variable","title":"<code>add_gp_variable(gpv)</code>","text":"<p>Adds gp variables that could be obtained by corruption.</p> <p>Parameters:</p> Name Type Description Default <code>gpv</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_gp_variable(self, gpv: list):\n\"\"\"\n    Adds gp variables that could be obtained by corruption.\n\n    Parameters:\n        gpv (sp.core.symbol.Symbol): Corruptable variable.\n    \"\"\"\n    if self.gp_encodings is not None:\n        self.gp_encodings.append(gpv)\n\n    # regenerate encodings\n\n    self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_misc","title":"<code>add_misc(elem)</code>","text":"<p>Adds an AA master secret key.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>msk AA variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_misc(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds an AA master secret key.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): msk AA variable.\n    \"\"\"\n    self.misc.append(elem)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_mpk_AAi","title":"<code>add_mpk_AAi(elem)</code>","text":"<p>Describes the structure of AAi in the AA_extended corruption model. It is related to the encoding of MPK_i, for the corrupted A_i authority.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>mpk AA variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_mpk_AAi(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Describes the structure of AAi in the AA_extended corruption\n    model. It is related to the encoding of MPK_i, for the\n    corrupted A_i authority.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): mpk AA variable.\n    \"\"\"\n    self.MPK_AAi.append(elem)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_mpk_AAj","title":"<code>add_mpk_AAj(elem)</code>","text":"<p>Describes the structure of AAj in the AA_extended corruption model. It is related to the encoding of MPK_j, for the honest A_j authority.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>sp.core.symbol.Symbol</code> <p>mpk AA variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_mpk_AAj(self, elem: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Describes the structure of AAj in the AA_extended corruption\n    model. It is related to the encoding of MPK_j, for the\n    honest A_j authority.\n\n    Parameters:\n        elem (sp.core.symbol.Symbol): mpk AA variable.\n    \"\"\"\n    self.MPK_AAj.append(elem)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.add_mpk_variable","title":"<code>add_mpk_variable(mpkv)</code>","text":"<p>Adds mpk variables that could be obtained by corruption.</p> <p>Parameters:</p> Name Type Description Default <code>mpkv</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>decryption.py</code> <pre><code>def add_mpk_variable(self, mpkv: sp.core.symbol.Symbol):\n\"\"\"\n    Adds mpk variables that could be obtained by corruption.\n\n    Parameters:\n        mpkv (sp.core.symbol.Symbol): Corruptable variable.\n    \"\"\"\n    if self.mpk_encodings is not None:\n        self.mpk_encodings.append(mpkv)\n\n    # regenerate encodings\n\n    self.all_p = self.gen_all_p_ex_dict(self.k_encodings, self.c_encodings, self.mpk_encodings, self.gp_encodings)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.decryption_attack_generalized_alt","title":"<code>decryption_attack_generalized_alt(masterkey, p, unknown)</code>","text":"<p>Tries to find a decryption attack in the supplied parameters of a particular ABE scheme.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.symbol.Symbo</code> <p>Master key to find.</p> required <code>p</code> <code>list</code> <p>list of all possible combinations between the encodings (sp.core.symbol.Symbo).</p> required <code>unkonwn</code> <code>list</code> <p>list of unkown components for the attacker (sp.core.symbol.Symbo).</p> required Source code in <code>decryption.py</code> <pre><code>def decryption_attack_generalized_alt(self, masterkey, p, unknown):\n\"\"\"\n    Tries to find a decryption attack in the supplied parameters of\n    a particular ABE scheme.\n\n    Parameters:\n        masterkey (sp.core.symbol.Symbo): Master key to find.\n        p (list): list of all possible combinations between the encodings (sp.core.symbol.Symbo).\n        unkonwn (list): list of unkown components for the attacker (sp.core.symbol.Symbo).\n    \"\"\"\n    p = canonical(p)\n\n    # function to select all denoms\n    denoms = collect_denoms(p, unknown)\n    denomprod = denoms_prod(denoms)\n\n    # function that 'normalizes' the encodings\n    # (by multiplying everything with the product of\n    # denominators**2 (because each element in p is paired already))\n    # (master key is multiplied by the product**2)\n    p = self.transform_encoding_list(denomprod**2, p)\n    masterkey = canonical([cancel(masterkey * denomprod**2)])[0]\n\n    (mat, uvector) = writeencodingasprod(p, unknown)\n    # could run either of the following lines - using 'new' here for certainty\n    # (mat,uvector) = reordermatuvec_new(masterkey,mat,uvector)\n    # (mat, uvector) = reorder_mat_uvec_with_alpha(masterkey, mat, uvector)\n\n    m1 = mat\n    m2 = uvector\n\n    m1_m = Matrix(mat)\n    m2_m = Matrix(uvector)\n\n    mat = Matrix(mat)\n\n    # attack target_vector\n    # use here the function from find_solution or something\n    luvec1 = len(uvector)\n    target_vector = Matrix([writepolyasprod(masterkey, uvector, unknown)])\n    luvec2 = len(uvector)\n    if luvec1 != luvec2:\n        return False, None, None, None\n\n    mat2 = mat.row_insert(shape(mat)[0], target_vector)\n\n    ## testing code\n    # \"\"\"\n    (mat2, uvector, lis_del_rows, lis_del_cols) = trim_matrix_and_uvector(mat2, uvector)\n    m2_m = Matrix(uvector)\n\n    for ind in lis_del_cols:\n        target_vector.col_del(ind)\n        m1_m.col_del(ind)\n\n    for ind in lis_del_rows:\n        del self.all_p[ind]\n        m1_m.row_del(ind)\n    # \"\"\"\n    ## testing code\n\n    ns = mat2.transpose().nullspace()\n\n    matns = Matrix([v.transpose() for v in ns])\n\n    err, f_sol = find_attack_row(matns)\n    if err:\n        return False, None, None, None\n\n    n_l = shape(m2_m)[0]\n    n_d = shape(mat)[1]\n    check_v = zeros(1, n_l)\n\n    for i in range(0, len(f_sol)):\n        check_v += f_sol[i] * mat2.row(i)\n\n    ctr = 0\n    for ind in check_v:\n        check_v[ctr] = cancel(check_v[ctr])\n        ctr += 1\n\n    m1 = m1_m.tolist()\n    m2 = m2_m.tolist()\n\n    if check_v == target_vector:\n        return True, m1, m2, f_sol\n    else:\n        return False, None, None, None\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.format_encodings","title":"<code>format_encodings()</code>","text":"<p>Prints the involved encodings in the given ABE scheme.</p> Source code in <code>decryption.py</code> <pre><code>def format_encodings(self) -&gt; None:\n\"\"\"\n    Prints the involved encodings in the given ABE scheme.\n    \"\"\"\n    if self.all_p:\n        print(\"List of encodings:\")\n        for elem in self.all_p:\n            print(\"\\t\", elem[\"dsc\"], \":\", elem[\"op\"])        \n\n    if self.k_encodings:\n        for elem in self.k_encodings:\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                print(\"\\t\", \"k\" + \"[i]\" + str(self.k_encodings.index(elem)), \":\",  elem)       \n            else:\n                print(\"\\t\", \"k\" + str(self.k_encodings.index(elem)), \":\",  elem)       \n\n\n    if self.c_encodings:\n        for elem in self.c_encodings:\n            print(\"\\t\", \"c\" + str(self.c_encodings.index(elem)), \":\",  elem)                        \n\n    if self.mpk_encodings:\n        for elem in self.mpk_encodings:\n            print(\"\\t\", \"mpk\" + str(self.mpk_encodings.index(elem)), \":\",  elem)                        \n\n    if self.gp_encodings:\n        for elem in self.gp_encodings:\n            print(\"\\t\", \"gp\" + str(self.gp_encodings.index(elem)), \":\",  elem)\n\n    # Give details about the corruption model in relation to the\n    # attack\n\n    if self.corr_model == DecryptionKeyCorruptionModel.AA:\n        print(\"\\nFor the corruption of an attribute authority AA[i].\")          \n\n    if self.corr_model == DecryptionKeyCorruptionModel.AA_extended:\n        print(\"\\nFor the corruption of an attribute authority AA[i] where c0 and c1 are obtained from different attribute authorities.\")                                    \n\n    # Print the contents of the master key pairs according to the\n    # corruption model:\n\n    if self.MPK_AAi or self.MSK_AAi or self.MPK_AAj or self.MSK_AAj:\n\n        print(\"\\nStructure of CA/AAs:\")\n\n        match self.corr_model:\n            case DecryptionKeyCorruptionModel.AA:\n                print(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n            case DecryptionKeyCorruptionModel.AA_extended:\n                print(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n                print(f\"\\tMaster key pair of AA[j]: mpk[j]: {self.MPK_AAj}\")\n            case _:\n                pass\n\n    # Print corruption map \n\n    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n        print(\"\\nList of variables obtained via corruption:\")\n        for elem in self.corruption_map:\n            print(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.format_encodings_string","title":"<code>format_encodings_string()</code>","text":"<p>Return a string with the involved encodings in the given ABE scheme.</p> Source code in <code>decryption.py</code> <pre><code>def format_encodings_string(self) -&gt; str:\n\"\"\"\n    Return a string with the involved encodings in the given ABE scheme.\n    \"\"\"\n\n    ret_string = []\n\n    if self.all_p:\n        ret_string.append(\"List of encodings:\")\n        for elem in self.all_p:\n            ret_string.append(\"\\t \" + str(elem[\"dsc\"]) + \" : \" + str(elem[\"op\"]))\n\n    if self.k_encodings:\n        for elem in self.k_encodings:\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                ret_string.append(\"\\t\" + \" k\" + \"[i]\" + str(self.k_encodings.index(elem)) + \" : \" + str(elem))       \n            else:\n                ret_string.append(\"\\t\" + \"k\" + str(self.k_encodings.index(elem)) + \" : \" + str(elem))       \n\n\n    if self.c_encodings:\n        for elem in self.c_encodings:\n            ret_string.append(\"\\t\" + \"c\" + str(self.c_encodings.index(elem)) + \" : \" + str(elem))                        \n\n    if self.mpk_encodings:\n        for elem in self.mpk_encodings:\n            ret_string.append(\"\\t\" + \"mpk\" + str(self.mpk_encodings.index(elem)) + \" : \" + str(elem))                        \n\n    if self.gp_encodings:\n        for elem in self.gp_encodings:\n            ret_string.append(\"\\t\" + \"gp\" + str(self.gp_encodings.index(elem)) + \" : \"  + str(elem))\n\n    # Give details about the corruption model in relation to the\n    # attack\n\n    if self.corr_model == DecryptionKeyCorruptionModel.AA:\n        ret_string.append(\"\\nFor the corruption of an attribute authority AA[i].\")          \n\n    if self.corr_model == DecryptionKeyCorruptionModel.AA_extended:\n        ret_string.append(\"\\nFor the corruption of an attribute authority AA[i] where c0 and c1 are obtained from different attribute authorities.\")                                    \n\n    # Print the contents of the master key pairs according to the\n    # corruption model:\n\n    if self.MPK_AAi or self.MSK_AAi or self.MPK_AAj or self.MSK_AAj:\n\n        ret_string.append(\"\\nStructure of CA/AAs:\")\n\n        match self.corr_model:\n            case DecryptionKeyCorruptionModel.AA:\n                ret_string.append(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n            case DecryptionKeyCorruptionModel.AA_extended:\n                ret_string.append(f\"\\tMaster key pair of AA[i]: mpk[i]: {self.MPK_AAi}\")\n                ret_string.append(f\"\\tMaster key pair of AA[j]: mpk[j]: {self.MPK_AAj}\")\n            case _:\n                pass\n\n    # Print corruption map \n\n    if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n        ret_string.append(\"\\nList of variables obtained via corruption:\")\n        for elem in self.corruption_map:\n            ret_string.append(f'\\t{elem[\"name\"]} from {elem[\"origin\"]}')\n\n    return '\\n'.join(ret_string)\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.gen_all_p_ex_dict","title":"<code>gen_all_p_ex_dict(k, c, mpk, gp)</code>","text":"<p>Generates all the possible combinations given key, ciphertext, mpk and global parameter related encodings.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>list</code> <p>Key encodings of type sp.core.symbol.Symbol.</p> required <code>c</code> <code>list</code> <p>Ciphertext encodings of type sp.core.symbol.Symbol.</p> required <code>mpk</code> <code>list</code> <p>mpk encodings of type sp.core.symbol.Symbol.</p> required <code>gp</code> <code>list</code> <p>gp encodings of type sp.core.symbol.Symbol.</p> required Source code in <code>decryption.py</code> <pre><code>def gen_all_p_ex_dict(self, k: list, c: list, mpk: list, gp: list) -&gt; list:\n\"\"\"\n    Generates all the possible combinations given key, ciphertext, mpk\n    and global parameter related encodings.\n\n    Parameters:\n        k (list): Key encodings of type sp.core.symbol.Symbol.\n        c (list): Ciphertext encodings of type sp.core.symbol.Symbol.\n        mpk (list): mpk encodings of type sp.core.symbol.Symbol.\n        gp (list): gp encodings of type sp.core.symbol.Symbol.\n    \"\"\"   \n\n    # k*c\n\n    all_k_c = []\n    for i in k:\n        for j in c:\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                entry = {\"op\": i * j, \"dsc\": \"k\" + str(k.index(i)) + \"[i]\" + \"*c\" + str(c.index(j))}\n            else:\n                entry = {\"op\": i * j, \"dsc\": \"k\" + str(k.index(i)) + \"*c\" + str(c.index(j))}\n\n            all_k_c.append(entry)\n\n    # k*mpk\n\n    all_k_mpk = []\n    for i in k:\n        for j in mpk:\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                entry = {\n                    \"op\": i * j,\n                    \"dsc\": \"k\" + str(k.index(i)) + \"[i]\" + \"*mpk\" + str(mpk.index(j)),\n                }\n            else:\n                entry = {\n                    \"op\": i * j,\n                    \"dsc\": \"k\" + str(k.index(i)) + \"*mpk\" + str(mpk.index(j)),\n                }                        \n            all_k_mpk.append(entry)\n\n    # c*mpk\n\n    all_mpk_c = []\n    for i in c:\n        for j in mpk:\n            entry = {\n                \"op\": i * j,\n                \"dsc\": \"c\" + str(c.index(i)) + \"*mpk\" + str(mpk.index(j)),\n            }\n            all_mpk_c.append(entry)\n\n    # c*gp\n\n    all_gp_c = []\n    for i in c:\n        for j in gp:\n            entry = {\n                \"op\": i * j,\n                \"dsc\": \"c\" + str(c.index(i)) + \"*gp\" + str(gp.index(j)),\n            }\n            all_gp_c.append(entry)\n\n    # k*gp\n\n    all_gp_k = []\n    for i in k:\n        for j in gp:\n            if self.corr_model != DecryptionKeyCorruptionModel.NoCorruption:\n                entry = {\n                    \"op\": i * j,\n                    \"dsc\": \"k\" + str(k.index(i)) + \"[i]\" + \"*gp\" + str(gp.index(j)),\n                }\n            else:\n                entry = {\n                    \"op\": i * j,\n                    \"dsc\": \"k\" + str(k.index(i)) + \"*gp\" + str(gp.index(j)),\n                }                    \n            all_gp_k.append(entry)\n\n    return all_k_c + all_k_mpk + all_mpk_c + all_gp_c + all_gp_k\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.run","title":"<code>run()</code>","text":"<p>Tries to find a decryption attack with the supplied ABE scheme parameters.</p> Source code in <code>decryption.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    Tries to find a decryption attack with the supplied\n    ABE scheme parameters.\n    \"\"\"\n    op = [a_dict[\"op\"] for a_dict in self.all_p]\n    dsc = [a_dict[\"dsc\"] for a_dict in self.all_p]\n\n    result, m, v, sol = self.decryption_attack_generalized_alt(self.key, op, self.unknown)\n    if result == True:\n        dsc = [a_dict[\"dsc\"] for a_dict in self.all_p]\n        self.sol = super().format_solution(dsc, sol, self.SOL_MSG)\n    else:\n        self.sol =  self.NOT_FOUND_MSG\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.set_corruption_model","title":"<code>set_corruption_model(corr_m)</code>","text":"<p>Sets the corruption model involved in the attack. By the default the corruption model is DecryptionKeyCorruptionModel.NoCorruption.</p> <p>Parameters:</p> Name Type Description Default <code>corr_m</code> <code>DecryptionKeyCorruptionModel</code> <p>Corruption model.</p> required Source code in <code>decryption.py</code> <pre><code>def set_corruption_model(self, corr_m) -&gt; None:\n\"\"\"\n    Sets the corruption model involved in the attack. By\n    the default the corruption model is DecryptionKeyCorruptionModel.NoCorruption.\n\n    Parameters:\n        corr_m (DecryptionKeyCorruptionModel): Corruption model.\n    \"\"\"\n    self.corr_model = corr_m\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.set_not_found_msg","title":"<code>set_not_found_msg(msg)</code>","text":"<p>Allows to set the not found solution message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Message.</p> required Source code in <code>decryption.py</code> <pre><code>def set_not_found_msg(self, msg: str) -&gt; None:\n\"\"\"\n    Allows to set the not found solution message.\n\n    Parameters:\n        msg (str): Message.\n    \"\"\"\n    self.NOT_FOUND_MSG = msg\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.set_sol_msg","title":"<code>set_sol_msg(msg)</code>","text":"<p>Allows to set the found solution message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Message.</p> required Source code in <code>decryption.py</code> <pre><code>def set_sol_msg(self, msg: str) -&gt; None:\n\"\"\"\n    Allows to set the found solution message.\n\n    Parameters:\n        msg (str): Message.\n    \"\"\"\n    self.SOL_MSG = msg\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.show_solution","title":"<code>show_solution()</code>","text":"<p>Returns the result of the attack.</p> <p>Returns:</p> Name Type Description <code>solution</code> <code>str</code> <p>The result of the attack.</p> Source code in <code>decryption.py</code> <pre><code>def show_solution(self) -&gt; str:\n\"\"\"\n    Returns the result of the attack.\n\n    Returns:\n        solution (str): The result of the attack.\n    \"\"\"\n    return '\\n' + self.sol + '\\n'\n</code></pre>"},{"location":"reference/#decryption.DecryptionAttack.transform_encoding_list","title":"<code>transform_encoding_list(denomprod, p)</code>","text":"<p>Function that 'normalizes' the encodings (by multiplying everything with the product of denominators^2 (because each element in p is paired already)) (master key is multiplied by the product^2).</p> <p>Parameters:</p> Name Type Description Default <code>denomprod</code> <code>sp.core.symbol.Symbo</code> <p>product of denominators. p (list): list of all possible combinations between the encodings.</p> required Source code in <code>decryption.py</code> <pre><code>def transform_encoding_list(self, denomprod, p):\n\"\"\"\n    Function that 'normalizes' the encodings\n    (by multiplying everything with the product of\n    denominators^2 (because each element in p is paired already))\n    (master key is multiplied by the product^2).\n\n    Parameters:\n        denomprod (sp.core.symbol.Symbo): product of denominators.\n         p (list): list of all possible combinations between the encodings.\n    \"\"\"\n    pcpy = []\n\n    for pp in p:\n        pcpy.append(cancel(pp * denomprod))\n\n    return canonical(pcpy)\n</code></pre>"},{"location":"reference/#decryption.DecryptionKeyCorruptedVariable","title":"<code>DecryptionKeyCorruptedVariable</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Describes the origin of corruptable variables in decryption key attacks.</p> <p>Attributes:</p> Name Type Description <code>MPK_AAi</code> <code>int</code> <p>MPK of an attribute authority [i].</p> <code>misc</code> <code>int</code> <p>misc. variable part of an attribute autority [i].</p> Source code in <code>decryption.py</code> <pre><code>class DecryptionKeyCorruptedVariable(Enum):\n\"\"\"\n    Describes the origin of corruptable variables in decryption key attacks.\n\n    Attributes:\n        MPK_AAi (int): MPK of an attribute authority [i].\n        misc (int): misc. variable part of an attribute autority [i].\n    \"\"\"\n    MPK_AAi = 1\n    misc = 2\n</code></pre>"},{"location":"reference/#decryption.DecryptionKeyCorruptionModel","title":"<code>DecryptionKeyCorruptionModel</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Allowed corruption models in decryption key attacks.</p> <p>Attributes:</p> Name Type Description <code>NoCorruption</code> <code>int</code> <p>Corruption is not possible.</p> <code>AA</code> <code>int</code> <p>Corruption of one Attribute Authority (AA[i]).</p> <code>AA_extended</code> <code>int</code> <p>Corruption of the Attribute Authority (AA[i]) where the interaction with a second Attribute Authority AA[j] is required. This interaction means that a second attribute-independent ciphertext is generated from a second authority.</p> Source code in <code>decryption.py</code> <pre><code>class DecryptionKeyCorruptionModel(Enum):\n\"\"\"\n    Allowed corruption models in decryption key attacks.\n\n    Attributes:\n        NoCorruption (int): Corruption is not possible.\n        AA (int): Corruption of one Attribute Authority (AA[i]).\n        AA_extended (int): Corruption of the Attribute Authority (AA[i]) where\n            the interaction with a second Attribute Authority AA[j] is required.\n            This interaction means that a second attribute-independent ciphertext\n            is generated from a second authority.\n    \"\"\"\n    NoCorruption = 1\n    AA = 2\n    AA_extended = 3\n</code></pre>"},{"location":"reference/#classes-for-analyzing-the-security-of-abe-schemes","title":"Classes for analyzing the security of ABE schemes","text":"<p>analysis.py: Definition of the analysis class that aims to perform different tests on a given ABE scheme</p>"},{"location":"reference/#analysis.Analysis","title":"<code>Analysis</code>","text":"<p>Base analysis class with methods to perform basic master key and  decryption attacks. AnalysisWithCorruption inherits this class and extends to also provide security analysis of the ABE scheme.</p> <p>Attributes:</p> Name Type Description <code>analysis_list</code> <code>list</code> <p>List of analysis to perform by the class via run.</p> <code>sol_list</code> <code>list</code> <p>Solutions found via the analysis in analysis_list.</p> Source code in <code>analysis.py</code> <pre><code>class Analysis:\n\"\"\"\n    Base analysis class with methods to perform basic master key and \n    decryption attacks. AnalysisWithCorruption inherits this class\n    and extends to also provide security analysis of the ABE scheme.\n\n    Attributes:\n        analysis_list (list): List of analysis to perform by the class via run.\n        sol_list (list): Solutions found via the analysis in analysis_list.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"\n        The constructor for the Analysis class. \n        \"\"\"\n        self.analysis_list = []\n        self.sol_list = []\n\n    def init(self, master_key_params: dict, decryption_key_params: dict) -&gt; None:\n\"\"\"\n        Initializes the analysis class with the respective params for\n        master key attacks and decryption attacks :\n\n        Parameters:\n            master_key_params (dict): The parameters required for a master key attack.\n            decryption_key_params (dict): The parameters required for a decryption key attack.\n        \"\"\"\n        master_key_attack = MasterKeyAttack()\n        master_key_attack.init(master_key_params[\"masterkey\"], master_key_params[\"keyenco\"], master_key_params[\"unknown\"])\n\n        decryption_attack = DecryptionAttack()\n        decryption_attack.init(decryption_key_params[\"key\"], decryption_key_params[\"all_p\"], decryption_key_params[\"unknown\"])\n\n        self.analysis_list.append(decryption_attack)\n        self.analysis_list.append(master_key_attack)\n\n    def run(self) -&gt; None:\n\"\"\"\n        Tries to find master key and decryption attacks in the\n        provided ABE scheme.\n        \"\"\"\n        for attack in self.analysis_list:\n            if attack.enabled == True:\n                attack.run()\n\n    def show_solution(self) -&gt; list:\n\"\"\"\n        Returns the result of the attacks.\n\n        Returns:\n            solution (list): The result of the attacks.\n        \"\"\"\n        for attack in self.analysis_list:\n            self.sol_list.append(attack.show_solution())\n        return self.sol_list\n</code></pre>"},{"location":"reference/#analysis.Analysis.__init__","title":"<code>__init__()</code>","text":"<p>The constructor for the Analysis class.</p> Source code in <code>analysis.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    The constructor for the Analysis class. \n    \"\"\"\n    self.analysis_list = []\n    self.sol_list = []\n</code></pre>"},{"location":"reference/#analysis.Analysis.init","title":"<code>init(master_key_params, decryption_key_params)</code>","text":"<p>Initializes the analysis class with the respective params for master key attacks and decryption attacks :</p> <p>Parameters:</p> Name Type Description Default <code>master_key_params</code> <code>dict</code> <p>The parameters required for a master key attack.</p> required <code>decryption_key_params</code> <code>dict</code> <p>The parameters required for a decryption key attack.</p> required Source code in <code>analysis.py</code> <pre><code>def init(self, master_key_params: dict, decryption_key_params: dict) -&gt; None:\n\"\"\"\n    Initializes the analysis class with the respective params for\n    master key attacks and decryption attacks :\n\n    Parameters:\n        master_key_params (dict): The parameters required for a master key attack.\n        decryption_key_params (dict): The parameters required for a decryption key attack.\n    \"\"\"\n    master_key_attack = MasterKeyAttack()\n    master_key_attack.init(master_key_params[\"masterkey\"], master_key_params[\"keyenco\"], master_key_params[\"unknown\"])\n\n    decryption_attack = DecryptionAttack()\n    decryption_attack.init(decryption_key_params[\"key\"], decryption_key_params[\"all_p\"], decryption_key_params[\"unknown\"])\n\n    self.analysis_list.append(decryption_attack)\n    self.analysis_list.append(master_key_attack)\n</code></pre>"},{"location":"reference/#analysis.Analysis.run","title":"<code>run()</code>","text":"<p>Tries to find master key and decryption attacks in the provided ABE scheme.</p> Source code in <code>analysis.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    Tries to find master key and decryption attacks in the\n    provided ABE scheme.\n    \"\"\"\n    for attack in self.analysis_list:\n        if attack.enabled == True:\n            attack.run()\n</code></pre>"},{"location":"reference/#analysis.Analysis.show_solution","title":"<code>show_solution()</code>","text":"<p>Returns the result of the attacks.</p> <p>Returns:</p> Name Type Description <code>solution</code> <code>list</code> <p>The result of the attacks.</p> Source code in <code>analysis.py</code> <pre><code>def show_solution(self) -&gt; list:\n\"\"\"\n    Returns the result of the attacks.\n\n    Returns:\n        solution (list): The result of the attacks.\n    \"\"\"\n    for attack in self.analysis_list:\n        self.sol_list.append(attack.show_solution())\n    return self.sol_list\n</code></pre>"},{"location":"reference/#analysis.AnalysisWithCorruption","title":"<code>AnalysisWithCorruption</code>","text":"<p>             Bases: <code>Analysis</code></p> <p>This class performs the security analysis of the provided scheme as well as look for master and decryption attacks if sufficient parameters are provided.</p> Source code in <code>analysis.py</code> <pre><code>class AnalysisWithCorruption(Analysis):\n\"\"\"\n    This class performs the security analysis of the provided\n    scheme as well as look for master and decryption attacks if\n    sufficient parameters are provided.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.corruptable_vars_MK = []\n        self.corruptable_vars_DK = []\n\n        super().__init__()\n\n    def init(self, master_key_params: dict, decryption_key_params: dict, corruptable_vars_MK: list, corruptable_vars_DK: list, security_analysis_params: dict) -&gt; bool:\n\"\"\"\n        Initializes the AnalysisWithCorruption class.\n\n        Parameters:\n            master_key_params (dict): Required parameters to look for master key attack.\n            decryption_key_params (dict): Required parameters to look for a decryption attack.\n            corruptable_vars_MK (list): The list of corruptable variables involved in the master key attack (if any).\n            corruptable_vars_DK (list): The list of corruptable variables involved in the decryption attack (if any).\n            security_analysis_params (dict): The required parameters to perform a security analysis of the scheme.\n\n\n        Returns:\n            (bool): If the inputs are valid e.g. corruption models and variable type are correct.\n        \"\"\"\n\n        is_init_correct = True\n\n        self.corruptable_vars_MK = corruptable_vars_MK\n        self.corruptable_vars_DK = corruptable_vars_DK\n\n        if security_analysis_params:\n            security_attack = SecurityAttack()\n            security_attack.init(\n                                 security_analysis_params[\"key\"],\n                                 security_analysis_params[\"k_encodings\"],\n                                 security_analysis_params[\"c_encodings\"], \n                                 security_analysis_params[\"mpk_encodings\"],\n                                 security_analysis_params[\"unknown\"])\n\n            # update unknown variables array with list of corruptable vars\n\n            for elem in security_analysis_params[\"corruptable_vars\"]:\n                security_attack.add_corruptable_variable_generic(elem)\n\n            self.analysis_list.append(security_attack)\n\n        if master_key_params:\n            master_key_attack = MasterKeyAttack()\n\n            if master_key_params[\"corruption_model\"] != 'NoCorruption':\n                master_key_attack.SOL_MSG = \"[*] Master key attack with corruption found: \"\n                master_key_attack.NOT_FOUND_MSG = \"[!] No Master key attack with corruption found\"\n            else:\n                master_key_attack.SOL_MSG = \"[*] Master key attack found: \"\n                master_key_attack.NOT_FOUND_MSG = \"[!] No Master key attack found. \"\n\n            master_key_attack.init(master_key_params[\"masterkey\"], master_key_params[\"keyenco\"], master_key_params[\"unknown\"])\n\n            match str(master_key_params[\"corruption_model\"]):\n               case 'NoCorruption':\n                  master_key_attack.set_corruption_model(MasterKeyCorruptionModel.NoCorruption)\n               case \"CA\":\n                  master_key_attack.set_corruption_model(MasterKeyCorruptionModel.CA)\n               case 'AA':\n                  master_key_attack.set_corruption_model(MasterKeyCorruptionModel.AA)\n               case 'mixed_CA_corr':\n                  master_key_attack.set_corruption_model(MasterKeyCorruptionModel.mixed_CA)\n               case 'mixed_AA_corr':\n                  master_key_attack.set_corruption_model(MasterKeyCorruptionModel.mixed_AA)\n               case _:\n                 is_init_correct = False\n\n            for elem in master_key_params[\"MPK_CA\"]:\n                master_key_attack.add_mpk_CA(elem)\n\n            for elem in master_key_params[\"MPK_AA\"]:\n                master_key_attack.add_mpk_AA(elem)\n\n            for elem in master_key_params[\"MPK_vars\"]:\n                master_key_attack.add_mpk(elem)\n\n            for elem in master_key_params[\"GP_vars\"]:\n                master_key_attack.add_gp_variable(elem)\n\n            if self.corruptable_vars_MK is not None:\n                for var in self.corruptable_vars_MK:\n                    if \"type\" in var:\n                            if \"var\" in var:\n                                if str(var[\"type\"]) in [\"MPK_CA\", \"MSK_CA\", \"MPK_AA\", \"MSK_AA\"]:\n                                    match str(var[\"type\"]):\n                                        case \"MPK_CA\":\n                                            master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MPK_CA, parse_expr(var[\"var\"]))\n                                        case \"MSK_CA\":\n                                            master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MSK_CA, parse_expr(var[\"var\"]))\n                                        case \"MPK_AA\":\n                                            master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MPK_AA, parse_expr(var[\"var\"]))\n                                        case \"MSK_AA\":\n                                            master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MSK_AA, parse_expr(var[\"var\"]))\n                                        case _:\n                                            is_init_correct = False\n\n            self.analysis_list.append(master_key_attack)\n\n        if decryption_key_params:\n            decryption_attack = DecryptionAttack()\n            decryption_attack.init(decryption_key_params[\"key\"], decryption_key_params[\"k_encodings\"], decryption_key_params[\"c_encodings\"],decryption_key_params[\"mpk_encodings\"],decryption_key_params[\"gp_encodings\"], decryption_key_params[\"unknown\"])\n\n            match str(decryption_key_params[\"corruption_model\"]):\n               case 'NoCorruption':\n                  decryption_attack.set_corruption_model(DecryptionKeyCorruptionModel.NoCorruption)\n               case \"AA\":\n                  decryption_attack.set_corruption_model(DecryptionKeyCorruptionModel.AA)\n               case 'AA_extended':\n                  decryption_attack.set_corruption_model(DecryptionKeyCorruptionModel.AA_extended)\n               case _:\n                 is_init_correct = False\n\n\n            for elem in decryption_key_params[\"MPK_AAi\"]:\n                decryption_attack.add_mpk_AAi(elem)\n\n            for elem in decryption_key_params[\"MPK_AAj\"]:\n                decryption_attack.add_mpk_AAj(elem)\n\n            for elem in decryption_key_params[\"misc_vars\"]:\n                decryption_attack.add_misc(elem)\n\n            if self.corruptable_vars_DK is not None:\n                for var in self.corruptable_vars_DK:\n                    if \"type\" in var:\n                        if \"var\" in var:    \n                            if str(var[\"type\"]) in [\"MPK_AAi\", \"MSK_AAi\", \"misc\"]:\n                                match str(var[\"type\"]):\n                                    case \"MPK_AAi\":\n                                        decryption_attack.add_corruptable_var(DecryptionKeyCorruptedVariable.MPK_AAi, parse_expr(var[\"var\"]))\n                                    case \"MSK_AAi\":\n                                        decryption_attack.add_corruptable_var(DecryptionKeyCorruptedVariable.MSK_AAi, parse_expr(var[\"var\"]))\n                                    case \"misc\":\n                                        decryption_attack.add_corruptable_var(DecryptionKeyCorruptedVariable.misc, parse_expr(var[\"var\"]))\n                                    case _:\n                                        is_init_correct = False\n\n            self.analysis_list.append(decryption_attack)\n\n\n        return is_init_correct\n\n    def run(self) -&gt; None:\n\"\"\"\n        For those analysis with sufficient parameters, it runs them.\n        \"\"\"\n        for attack in self.analysis_list:\n            if attack.enabled == True:\n                attack.run()\n\n    def run_logic(self) -&gt; None:\n\"\"\"\n        For those analysis with sufficient parameters, it runs them.\n        However, it only tries to find attacks whenever the security\n        analysis fails.\n        \"\"\"\n\n        print(\"[*] Starting complete analysis\")\n\n        for attack in self.analysis_list:\n            if attack.enabled == True:\n                if attack.description == \"SecurityAttack\":\n                    print(\"[*] Security analysys\")\n                    attack.run()\n\n        if not (attack.trivial_secure or attack.collusion_secure):\n            print(\"[*] Looking for attacks...\")\n            for attack in self.analysis_list:\n                if attack.enabled == True:\n                    if attack.description == \"MasterKeyAttack\":\n                        attack.run()\n                    if attack.description == \"DecryptionAttack\":\n                        attack.run()\n        else:\n            for attack in self.analysis_list:\n                if attack.enabled == True:\n                    if attack.description == \"MasterKeyAttack\":\n                        attack.enabled = False\n                    if attack.description == \"DecryptionAttack\":\n                        attack.enabled = False\n\n    def show_solution(self) -&gt; list:\n\"\"\"\n        Returns the results of the performed analysis.\n\n        Returns:\n            solution (list): The results obtained.\n            proof_data (list): \n        \"\"\"\n\n        proof_data = None\n        proof_header = None\n\n        for attack in self.analysis_list:\n                if attack.enabled == True:\n                    match attack.description:\n                        case \"SecurityAttack\":\n                            print(\"\\n[*] Security analysis results:\\n\")\n                            self.sol_list.append(\"sec_placeholder\")                           \n                            self.sol_list.append(attack.show_solution())\n                            print(\"\\n\" + attack.show_solution())\n                            attack.show_proof()\n                            proof_data, proof_header = attack.show_proof_latex()                        \n                        case \"MasterKeyAttack\":\n                            print(\"\\n[*] Master key attack results:\\n\")\n                            attack.format_encodings()\n                            print(\"\\n\" + attack.show_solution())\n                            self.sol_list.append(\"mk_placeholder\")\n                            self.sol_list.append(attack.format_encodings_string())\n                            self.sol_list.append(attack.show_solution())\n                        case \"DecryptionAttack\":\n                            print(\"\\n[*] Decryption key attack results:\\n\")\n                            attack.format_encodings()\n                            print(\"\\n\" + attack.show_solution())\n                            self.sol_list.append(\"da_placeholder\")\n                            self.sol_list.append(attack.format_encodings_string())                         \n                            self.sol_list.append(attack.show_solution())\n                        case _:\n                            pass # TODO: catch error      \n\n        return self.sol_list, proof_data, proof_header\n\n    def is_scheme_fractional(self) -&gt; bool:\n\"\"\"\n        If there is a security analysis attached, it\n        returns if the ABE scheme is fractional or not.\n\n        Returns:\n            (bool): Is the scheme fractional ?\n        \"\"\"\n\n        for attack in self.analysis_list:\n                if attack.enabled == True:\n                    if attack.description == \"SecurityAttack\":\n                        return attack.is_fractional\n\n        return False\n</code></pre>"},{"location":"reference/#analysis.AnalysisWithCorruption.init","title":"<code>init(master_key_params, decryption_key_params, corruptable_vars_MK, corruptable_vars_DK, security_analysis_params)</code>","text":"<p>Initializes the AnalysisWithCorruption class.</p> <p>Parameters:</p> Name Type Description Default <code>master_key_params</code> <code>dict</code> <p>Required parameters to look for master key attack.</p> required <code>decryption_key_params</code> <code>dict</code> <p>Required parameters to look for a decryption attack.</p> required <code>corruptable_vars_MK</code> <code>list</code> <p>The list of corruptable variables involved in the master key attack (if any).</p> required <code>corruptable_vars_DK</code> <code>list</code> <p>The list of corruptable variables involved in the decryption attack (if any).</p> required <code>security_analysis_params</code> <code>dict</code> <p>The required parameters to perform a security analysis of the scheme.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the inputs are valid e.g. corruption models and variable type are correct.</p> Source code in <code>analysis.py</code> <pre><code>def init(self, master_key_params: dict, decryption_key_params: dict, corruptable_vars_MK: list, corruptable_vars_DK: list, security_analysis_params: dict) -&gt; bool:\n\"\"\"\n    Initializes the AnalysisWithCorruption class.\n\n    Parameters:\n        master_key_params (dict): Required parameters to look for master key attack.\n        decryption_key_params (dict): Required parameters to look for a decryption attack.\n        corruptable_vars_MK (list): The list of corruptable variables involved in the master key attack (if any).\n        corruptable_vars_DK (list): The list of corruptable variables involved in the decryption attack (if any).\n        security_analysis_params (dict): The required parameters to perform a security analysis of the scheme.\n\n\n    Returns:\n        (bool): If the inputs are valid e.g. corruption models and variable type are correct.\n    \"\"\"\n\n    is_init_correct = True\n\n    self.corruptable_vars_MK = corruptable_vars_MK\n    self.corruptable_vars_DK = corruptable_vars_DK\n\n    if security_analysis_params:\n        security_attack = SecurityAttack()\n        security_attack.init(\n                             security_analysis_params[\"key\"],\n                             security_analysis_params[\"k_encodings\"],\n                             security_analysis_params[\"c_encodings\"], \n                             security_analysis_params[\"mpk_encodings\"],\n                             security_analysis_params[\"unknown\"])\n\n        # update unknown variables array with list of corruptable vars\n\n        for elem in security_analysis_params[\"corruptable_vars\"]:\n            security_attack.add_corruptable_variable_generic(elem)\n\n        self.analysis_list.append(security_attack)\n\n    if master_key_params:\n        master_key_attack = MasterKeyAttack()\n\n        if master_key_params[\"corruption_model\"] != 'NoCorruption':\n            master_key_attack.SOL_MSG = \"[*] Master key attack with corruption found: \"\n            master_key_attack.NOT_FOUND_MSG = \"[!] No Master key attack with corruption found\"\n        else:\n            master_key_attack.SOL_MSG = \"[*] Master key attack found: \"\n            master_key_attack.NOT_FOUND_MSG = \"[!] No Master key attack found. \"\n\n        master_key_attack.init(master_key_params[\"masterkey\"], master_key_params[\"keyenco\"], master_key_params[\"unknown\"])\n\n        match str(master_key_params[\"corruption_model\"]):\n           case 'NoCorruption':\n              master_key_attack.set_corruption_model(MasterKeyCorruptionModel.NoCorruption)\n           case \"CA\":\n              master_key_attack.set_corruption_model(MasterKeyCorruptionModel.CA)\n           case 'AA':\n              master_key_attack.set_corruption_model(MasterKeyCorruptionModel.AA)\n           case 'mixed_CA_corr':\n              master_key_attack.set_corruption_model(MasterKeyCorruptionModel.mixed_CA)\n           case 'mixed_AA_corr':\n              master_key_attack.set_corruption_model(MasterKeyCorruptionModel.mixed_AA)\n           case _:\n             is_init_correct = False\n\n        for elem in master_key_params[\"MPK_CA\"]:\n            master_key_attack.add_mpk_CA(elem)\n\n        for elem in master_key_params[\"MPK_AA\"]:\n            master_key_attack.add_mpk_AA(elem)\n\n        for elem in master_key_params[\"MPK_vars\"]:\n            master_key_attack.add_mpk(elem)\n\n        for elem in master_key_params[\"GP_vars\"]:\n            master_key_attack.add_gp_variable(elem)\n\n        if self.corruptable_vars_MK is not None:\n            for var in self.corruptable_vars_MK:\n                if \"type\" in var:\n                        if \"var\" in var:\n                            if str(var[\"type\"]) in [\"MPK_CA\", \"MSK_CA\", \"MPK_AA\", \"MSK_AA\"]:\n                                match str(var[\"type\"]):\n                                    case \"MPK_CA\":\n                                        master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MPK_CA, parse_expr(var[\"var\"]))\n                                    case \"MSK_CA\":\n                                        master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MSK_CA, parse_expr(var[\"var\"]))\n                                    case \"MPK_AA\":\n                                        master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MPK_AA, parse_expr(var[\"var\"]))\n                                    case \"MSK_AA\":\n                                        master_key_attack.add_corruptable_var(MasterKeyCorruptedVariable.MSK_AA, parse_expr(var[\"var\"]))\n                                    case _:\n                                        is_init_correct = False\n\n        self.analysis_list.append(master_key_attack)\n\n    if decryption_key_params:\n        decryption_attack = DecryptionAttack()\n        decryption_attack.init(decryption_key_params[\"key\"], decryption_key_params[\"k_encodings\"], decryption_key_params[\"c_encodings\"],decryption_key_params[\"mpk_encodings\"],decryption_key_params[\"gp_encodings\"], decryption_key_params[\"unknown\"])\n\n        match str(decryption_key_params[\"corruption_model\"]):\n           case 'NoCorruption':\n              decryption_attack.set_corruption_model(DecryptionKeyCorruptionModel.NoCorruption)\n           case \"AA\":\n              decryption_attack.set_corruption_model(DecryptionKeyCorruptionModel.AA)\n           case 'AA_extended':\n              decryption_attack.set_corruption_model(DecryptionKeyCorruptionModel.AA_extended)\n           case _:\n             is_init_correct = False\n\n\n        for elem in decryption_key_params[\"MPK_AAi\"]:\n            decryption_attack.add_mpk_AAi(elem)\n\n        for elem in decryption_key_params[\"MPK_AAj\"]:\n            decryption_attack.add_mpk_AAj(elem)\n\n        for elem in decryption_key_params[\"misc_vars\"]:\n            decryption_attack.add_misc(elem)\n\n        if self.corruptable_vars_DK is not None:\n            for var in self.corruptable_vars_DK:\n                if \"type\" in var:\n                    if \"var\" in var:    \n                        if str(var[\"type\"]) in [\"MPK_AAi\", \"MSK_AAi\", \"misc\"]:\n                            match str(var[\"type\"]):\n                                case \"MPK_AAi\":\n                                    decryption_attack.add_corruptable_var(DecryptionKeyCorruptedVariable.MPK_AAi, parse_expr(var[\"var\"]))\n                                case \"MSK_AAi\":\n                                    decryption_attack.add_corruptable_var(DecryptionKeyCorruptedVariable.MSK_AAi, parse_expr(var[\"var\"]))\n                                case \"misc\":\n                                    decryption_attack.add_corruptable_var(DecryptionKeyCorruptedVariable.misc, parse_expr(var[\"var\"]))\n                                case _:\n                                    is_init_correct = False\n\n        self.analysis_list.append(decryption_attack)\n\n\n    return is_init_correct\n</code></pre>"},{"location":"reference/#analysis.AnalysisWithCorruption.is_scheme_fractional","title":"<code>is_scheme_fractional()</code>","text":"<p>If there is a security analysis attached, it returns if the ABE scheme is fractional or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Is the scheme fractional ?</p> Source code in <code>analysis.py</code> <pre><code>def is_scheme_fractional(self) -&gt; bool:\n\"\"\"\n    If there is a security analysis attached, it\n    returns if the ABE scheme is fractional or not.\n\n    Returns:\n        (bool): Is the scheme fractional ?\n    \"\"\"\n\n    for attack in self.analysis_list:\n            if attack.enabled == True:\n                if attack.description == \"SecurityAttack\":\n                    return attack.is_fractional\n\n    return False\n</code></pre>"},{"location":"reference/#analysis.AnalysisWithCorruption.run","title":"<code>run()</code>","text":"<p>For those analysis with sufficient parameters, it runs them.</p> Source code in <code>analysis.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    For those analysis with sufficient parameters, it runs them.\n    \"\"\"\n    for attack in self.analysis_list:\n        if attack.enabled == True:\n            attack.run()\n</code></pre>"},{"location":"reference/#analysis.AnalysisWithCorruption.run_logic","title":"<code>run_logic()</code>","text":"<p>For those analysis with sufficient parameters, it runs them. However, it only tries to find attacks whenever the security analysis fails.</p> Source code in <code>analysis.py</code> <pre><code>def run_logic(self) -&gt; None:\n\"\"\"\n    For those analysis with sufficient parameters, it runs them.\n    However, it only tries to find attacks whenever the security\n    analysis fails.\n    \"\"\"\n\n    print(\"[*] Starting complete analysis\")\n\n    for attack in self.analysis_list:\n        if attack.enabled == True:\n            if attack.description == \"SecurityAttack\":\n                print(\"[*] Security analysys\")\n                attack.run()\n\n    if not (attack.trivial_secure or attack.collusion_secure):\n        print(\"[*] Looking for attacks...\")\n        for attack in self.analysis_list:\n            if attack.enabled == True:\n                if attack.description == \"MasterKeyAttack\":\n                    attack.run()\n                if attack.description == \"DecryptionAttack\":\n                    attack.run()\n    else:\n        for attack in self.analysis_list:\n            if attack.enabled == True:\n                if attack.description == \"MasterKeyAttack\":\n                    attack.enabled = False\n                if attack.description == \"DecryptionAttack\":\n                    attack.enabled = False\n</code></pre>"},{"location":"reference/#analysis.AnalysisWithCorruption.show_solution","title":"<code>show_solution()</code>","text":"<p>Returns the results of the performed analysis.</p> <p>Returns:</p> Name Type Description <code>solution</code> <code>list</code> <p>The results obtained.</p> <code>proof_data</code> <code>list</code> Source code in <code>analysis.py</code> <pre><code>def show_solution(self) -&gt; list:\n\"\"\"\n    Returns the results of the performed analysis.\n\n    Returns:\n        solution (list): The results obtained.\n        proof_data (list): \n    \"\"\"\n\n    proof_data = None\n    proof_header = None\n\n    for attack in self.analysis_list:\n            if attack.enabled == True:\n                match attack.description:\n                    case \"SecurityAttack\":\n                        print(\"\\n[*] Security analysis results:\\n\")\n                        self.sol_list.append(\"sec_placeholder\")                           \n                        self.sol_list.append(attack.show_solution())\n                        print(\"\\n\" + attack.show_solution())\n                        attack.show_proof()\n                        proof_data, proof_header = attack.show_proof_latex()                        \n                    case \"MasterKeyAttack\":\n                        print(\"\\n[*] Master key attack results:\\n\")\n                        attack.format_encodings()\n                        print(\"\\n\" + attack.show_solution())\n                        self.sol_list.append(\"mk_placeholder\")\n                        self.sol_list.append(attack.format_encodings_string())\n                        self.sol_list.append(attack.show_solution())\n                    case \"DecryptionAttack\":\n                        print(\"\\n[*] Decryption key attack results:\\n\")\n                        attack.format_encodings()\n                        print(\"\\n\" + attack.show_solution())\n                        self.sol_list.append(\"da_placeholder\")\n                        self.sol_list.append(attack.format_encodings_string())                         \n                        self.sol_list.append(attack.show_solution())\n                    case _:\n                        pass # TODO: catch error      \n\n    return self.sol_list, proof_data, proof_header\n</code></pre>"},{"location":"reference/#json-parsing-of-acabella-parameters","title":"JSON parsing of ACABELLA parameters","text":"<p>parse_config.py: JSON parser for ACABELLA analysis</p>"},{"location":"reference/#parse_config.ParseConfig","title":"<code>ParseConfig</code>","text":"<p>This class parses the JSON input files for ACABELLA involving all type of checks: master key attacks, decryption attacks, security analysis via AC17, etc.</p> <p>Attributes:</p> Name Type Description <code>json_parsed</code> <code>string</code> <p>Resulting string after JSON parsing.</p> Source code in <code>parse_config.py</code> <pre><code>class ParseConfig():\n\"\"\"\n    This class parses the JSON input files for ACABELLA involving\n    all type of checks: master key attacks, decryption attacks,\n    security analysis via AC17, etc.\n\n    Attributes:\n        json_parsed (string): Resulting string after JSON parsing.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.json_parsed = None \n\n    def init(self, config_file: str) -&gt; None:\n\"\"\"\n        Initializes the parser with a json configuration file\n        that describes the analysis.\n\n        Parameters:\n            config_file (str): Path to the JSON file.\n        \"\"\"\n        with open(config_file, \"r\") as read_file:\n            self.json_parsed = json.load(read_file)\n\n    def init_with_str(self, data: str) -&gt; None:\n\"\"\"\n        It is also possible to initialize the parser with\n        a string containing JSON instead of using a file\n        that needs to be open, read, etc.\n\n        Parameters:\n            data (str): String containing JSON code.\n        \"\"\"\n        self.json_parsed = json.loads(data)\n\n    def generate_master_key_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n        Based on the JSON input files, it generates a dictionary\n        with the corresponding parameters to look for master key\n        attacks. If a list of corruptable variables is supplied,\n        it also generates a list of those variables.\n\n        Returns:\n                Tuple (tuple): Master key attack parameters and corruptable variables. \n        \"\"\"\n\n        if self.json_parsed is None:\n            print(\"parse_config object is not initialized\")\n            return None, None\n\n        master_params = {}\n        corruptable_vars = {}\n\n        try:\n            master_params[\"keyenco\"] = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n            master_params[\"masterkey\"] = parse_expr(self.json_parsed[\"master_key\"])\n            master_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n            master_params[\"corruption_model\"] = self.json_parsed[\"corruption_model\"]\n\n            master_params[\"MPK_CA\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_CA\"]] \n            master_params[\"MPK_AA\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_AA\"]] \n            master_params[\"MPK_vars\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_vars\"]] \n            master_params[\"GP_vars\"] = [parse_expr(x) for x in self.json_parsed[\"GP_vars\"]] \n\n            corruptable_vars = self.json_parsed[\"corruptable_vars\"]\n        except:\n            master_params = None\n\n        return master_params, corruptable_vars\n\n    def generate_dec_key_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n        Based on the JSON input files, it generates a dictionary\n        with the corresponding parameters to look for decryption\n        attacks. If a list of corruptable variables is supplied,\n        it also generates a list of those variables.\n\n        Returns:\n            Tuple (tuple): Decryption attack parameters and corruptable variables\n        \"\"\"\n\n        if self.json_parsed is None:\n            print(\"parse_config object is not initialized\")\n            return None, None\n\n        # prepare decryption params\n\n        dec_params = {}\n        corruptable_vars = []\n\n        try:\n            dec_params[\"key\"] = parse_expr(self.json_parsed[\"key\"])\n            dec_params[\"k_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n            dec_params[\"c_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"c\"]]  \n            dec_params[\"mpk_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"mpk\"]] \n            dec_params[\"gp_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"gp\"]] \n            dec_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n\n            dec_params[\"corruption_model\"] = self.json_parsed[\"corruption_model\"]\n\n            # NOTE We suppose every field is always available in the JSON file.\n            # It will be empty if it is not related to a particular corruption model.\n\n            dec_params[\"MPK_AAi\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_AAi\"]] \n            dec_params[\"MPK_AAj\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_AAj\"]] \n\n            dec_params[\"misc_vars\"] = [parse_expr(x) for x in self.json_parsed[\"misc_vars\"]] \n\n            corruptable_vars = self.json_parsed[\"corruptable_vars\"]\n        except:\n            dec_params = None\n\n        return dec_params, corruptable_vars \n\n    def generate_conditional_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n        Based on the JSON input files, it generates a dictionary\n        with the corresponding parameters to look for conditional\n        attacks. If a list of corruptable variables is supplied,\n        it also generates a list of those variables.\n\n        Returns:\n            Parameters (dict): Conditional attack parameters.\n        \"\"\"\n\n        if self.json_parsed is None:\n            print(\"parse_config object is not initialized\")\n            return None, None\n\n\"\"\"\n        TODO: Some of this configuration generation can be automated e.g.\n            # these are fixed in the system\n            att_mpk_group = parse_expr(\"att_mpk_group\")\n            att_scalar = parse_expr(\"att_scalar\")\n            policy_share = parse_expr(\"lambda_policy_share\")\n\n            k_fixed_1 = alpha + r\n            k_att_1 = r + get_indexed_encoding(\"rp\", 1)*att_mpk_group\n            k_att_2 = get_indexed_encoding(\"rp\", 1)\n            c_att_1 = policy_share*att_mpk_group\n            c_att_2 = policy_share\n            mpk1 = att_mpk_group\n            special_s = s\n        \"\"\"\n\n        try:\n            att_mpk_group = parse_expr(\"att_mpk_group\")\n            att_scalar = parse_expr(\"att_scalar\")\n            policy_share = parse_expr(\"lambda_policy_share\")\n\n            mpk1 = att_mpk_group\n            special_s = parse_expr(\"s\")\n            k_fixed = [parse_expr(x) for x in self.json_parsed[\"k_fixed\"]] \n            k_att = [parse_expr(x) for x in self.json_parsed[\"k_indexed\"]] \n            c_fixed = [parse_expr(x) for x in self.json_parsed[\"c_fixed\"]] \n            c_att = [parse_expr(x) for x in self.json_parsed[\"c_indexed\"]] \n            unkown = [parse_expr(x) for x in self.json_parsed[\"unknown\"]] \n\n            mpk = []\n\n            prefixes = [\"rp\"]\n            nr_indexed_encodings = 1\n\n            # prepare conditional params\n\n            cd_params = {}\n            cd_params[\"alpha\"] = parse_expr(\"alpha\")\n            cd_params[\"special_s\"] = special_s\n            cd_params[\"mpk\"] = mpk\n            cd_params[\"k_fixed\"] = k_fixed\n            cd_params[\"k_att\"] = k_att\n            cd_params[\"c_fixed\"] = c_fixed\n            cd_params[\"c_att\"] = c_att\n            cd_params[\"unkown\"] = [],\n            cd_params[\"prefixes\"] = prefixes\n            cd_params[\"nr_indexed_encodings\"] = nr_indexed_encodings\n            cd_params[\"unknown\"] = unkown\n        except:\n            cd_params = None\n\n        return cd_params\n\n    def generate_abgw_bridge_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n        Based on the JSON input files, it generates a dictionary\n        with the corresponding parameters to transform a description\n        of an ABE scheme in ACABELLA format into a configuration file\n        to the tool that creates inputs for the ABGW tool in order\n        to check the security of the scheme.\n\n        Returns:\n            Parameters (dict): ABGW parameters.\n        \"\"\"\n\n        if self.json_parsed is None:\n            print(\"parse_config object is not initialized\")\n            return None, None\n\n        try:\n            k = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n            c = [parse_expr(x) for x in self.json_parsed[\"c\"]]  \n            mpk = [parse_expr(x) for x in self.json_parsed[\"mpk\"]] \n            gp = [parse_expr(x) for x in self.json_parsed[\"gp\"]] \n\n            # prepare abgw params\n\n            abgw_params = {}\n            abgw_params[\"key\"] = parse_expr(self.json_parsed[\"key\"])\n            abgw_params[\"k_encodings\"] = k\n            abgw_params[\"c_encodings\"] = c\n            abgw_params[\"mpk_encodings\"] = mpk\n            abgw_params[\"gp_encodings\"] = gp\n\n            abgw_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n            abgw_params[\"known\"] = [parse_expr(x) for x in self.json_parsed[\"known_vars\"]] \n        except:\n            abgw_params = None\n\n        return abgw_params\n\n    def generate_security_analysis_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n        Based on the JSON input files, it generates a dictionary\n        with the corresponding parameters to perform a security\n        analysis of the provided scheme.\n\n        Returns:\n            Parameters (dict): Security analysis parameters.\n        \"\"\"\n\n        if self.json_parsed is None:\n            print(\"parse_config object is not initialized\")\n            return None, None\n\n        # prepare security_analysis_params\n\n        security_analysis_params = {}\n\n        try:\n            security_analysis_params[\"key\"] = parse_expr(self.json_parsed[\"key\"])\n            security_analysis_params[\"k_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n            security_analysis_params[\"c_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"c\"]]  \n            security_analysis_params[\"mpk_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"mpk\"]] \n            security_analysis_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n            security_analysis_params[\"corruptable_vars\"] = [parse_expr(x) for x in self.json_parsed[\"corruptable_vars\"]] \n        except:\n            security_analysis_params = None\n\n        return security_analysis_params\n\n    def generate_all_params(self):\n\"\"\"\n        Based on the JSON input files, it generates a dictionary\n        with the corresponding parameters to look for decryption\n        and master key attacks as well as to check the security\n        of the provided ABE scheme.\n\n        Returns:\n            Parameters (dict): All involved parameters.\n        \"\"\"       \n        if self.json_parsed is None:\n            print(\"parse_config object is not initialized\")\n            return None, None\n\n        master_params = {}\n        corruptable_vars_master = {}\n        dec_params = {}\n        corruptable_vars_dec = {}\n\n        # parse security params\n\n        security_params_json = None\n        security_params = {}\n\n        try:\n            security_params_json = self.json_parsed[\"security\"]\n            security_params[\"key\"] = parse_expr(security_params_json[\"key\"])\n            security_params[\"k_encodings\"] = [parse_expr(x) for x in security_params_json[\"k\"]] \n            security_params[\"c_encodings\"] = [parse_expr(x) for x in security_params_json[\"c\"]]  \n            security_params[\"mpk_encodings\"] = [parse_expr(x) for x in security_params_json[\"mpk\"]] \n            security_params[\"unknown\"] = [parse_expr(x) for x in security_params_json[\"unknown_vars\"]] \n            security_params[\"corruptable_vars\"] = [parse_expr(x) for x in security_params_json[\"corruptable_vars\"]] \n        except:\n            security_params = None\n\n        # parse dec params\n\n        dec_params_json = None\n        corruptable_vars_dec =  None\n        dec_params = {}\n\n        try:\n            dec_params_json = self.json_parsed[\"decryption\"]\n            dec_params[\"key\"] = parse_expr(dec_params_json[\"key\"])\n            dec_params[\"k_encodings\"] = [parse_expr(x) for x in dec_params_json[\"k\"]] \n            dec_params[\"c_encodings\"] = [parse_expr(x) for x in dec_params_json[\"c\"]]  \n            dec_params[\"mpk_encodings\"] = [parse_expr(x) for x in dec_params_json[\"mpk\"]] \n            dec_params[\"gp_encodings\"] = [parse_expr(x) for x in dec_params_json[\"gp\"]] \n            dec_params[\"unknown\"] = [parse_expr(x) for x in dec_params_json[\"unknown_vars\"]] \n            dec_params[\"corruption_model\"] = dec_params_json[\"corruption_model\"]\n\n            # NOTE We suppose every field is always available in the JSON file.\n            # It will be empty if it is not related to a particular corruption model.\n\n            dec_params[\"MPK_AAi\"] = [parse_expr(x) for x in dec_params_json[\"MPK_AAi\"]] \n            dec_params[\"MPK_AAj\"] = [parse_expr(x) for x in dec_params_json[\"MPK_AAj\"]] \n            dec_params[\"misc_vars\"] = [parse_expr(x) for x in dec_params_json[\"misc_vars\"]] \n            corruptable_vars_dec = dec_params_json[\"corruptable_vars\"]\n        except:\n            dec_params = None\n\n        # parse master params\n\n        master_params_json = None\n        corruptable_vars_master = None        \n\n        try:\n            master_params_json = self.json_parsed[\"master_key\"]\n\n            master_params[\"keyenco\"] = [parse_expr(x) for x in master_params_json[\"k\"]] \n            master_params[\"masterkey\"] = parse_expr(master_params_json[\"master_key\"])\n            master_params[\"unknown\"] = [parse_expr(x) for x in master_params_json[\"unknown_vars\"]] \n            master_params[\"corruption_model\"] = master_params_json[\"corruption_model\"]\n\n            master_params[\"MPK_CA\"] = [parse_expr(x) for x in master_params_json[\"MPK_CA\"]] \n            master_params[\"MPK_AA\"] = [parse_expr(x) for x in master_params_json[\"MPK_AA\"]] \n            master_params[\"MPK_vars\"] = [parse_expr(x) for x in master_params_json[\"MPK_vars\"]] \n            master_params[\"GP_vars\"] = [parse_expr(x) for x in master_params_json[\"GP_vars\"]] \n            corruptable_vars_master = master_params_json[\"corruptable_vars\"]\n        except:\n            master_params = None\n\n        return security_params, master_params, corruptable_vars_master, dec_params, corruptable_vars_dec \n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.generate_abgw_bridge_params","title":"<code>generate_abgw_bridge_params()</code>","text":"<p>Based on the JSON input files, it generates a dictionary with the corresponding parameters to transform a description of an ABE scheme in ACABELLA format into a configuration file to the tool that creates inputs for the ABGW tool in order to check the security of the scheme.</p> <p>Returns:</p> Name Type Description <code>Parameters</code> <code>dict</code> <p>ABGW parameters.</p> Source code in <code>parse_config.py</code> <pre><code>def generate_abgw_bridge_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n    Based on the JSON input files, it generates a dictionary\n    with the corresponding parameters to transform a description\n    of an ABE scheme in ACABELLA format into a configuration file\n    to the tool that creates inputs for the ABGW tool in order\n    to check the security of the scheme.\n\n    Returns:\n        Parameters (dict): ABGW parameters.\n    \"\"\"\n\n    if self.json_parsed is None:\n        print(\"parse_config object is not initialized\")\n        return None, None\n\n    try:\n        k = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n        c = [parse_expr(x) for x in self.json_parsed[\"c\"]]  \n        mpk = [parse_expr(x) for x in self.json_parsed[\"mpk\"]] \n        gp = [parse_expr(x) for x in self.json_parsed[\"gp\"]] \n\n        # prepare abgw params\n\n        abgw_params = {}\n        abgw_params[\"key\"] = parse_expr(self.json_parsed[\"key\"])\n        abgw_params[\"k_encodings\"] = k\n        abgw_params[\"c_encodings\"] = c\n        abgw_params[\"mpk_encodings\"] = mpk\n        abgw_params[\"gp_encodings\"] = gp\n\n        abgw_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n        abgw_params[\"known\"] = [parse_expr(x) for x in self.json_parsed[\"known_vars\"]] \n    except:\n        abgw_params = None\n\n    return abgw_params\n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.generate_all_params","title":"<code>generate_all_params()</code>","text":"<p>Based on the JSON input files, it generates a dictionary with the corresponding parameters to look for decryption and master key attacks as well as to check the security of the provided ABE scheme.</p> <p>Returns:</p> Name Type Description <code>Parameters</code> <code>dict</code> <p>All involved parameters.</p> Source code in <code>parse_config.py</code> <pre><code>def generate_all_params(self):\n\"\"\"\n    Based on the JSON input files, it generates a dictionary\n    with the corresponding parameters to look for decryption\n    and master key attacks as well as to check the security\n    of the provided ABE scheme.\n\n    Returns:\n        Parameters (dict): All involved parameters.\n    \"\"\"       \n    if self.json_parsed is None:\n        print(\"parse_config object is not initialized\")\n        return None, None\n\n    master_params = {}\n    corruptable_vars_master = {}\n    dec_params = {}\n    corruptable_vars_dec = {}\n\n    # parse security params\n\n    security_params_json = None\n    security_params = {}\n\n    try:\n        security_params_json = self.json_parsed[\"security\"]\n        security_params[\"key\"] = parse_expr(security_params_json[\"key\"])\n        security_params[\"k_encodings\"] = [parse_expr(x) for x in security_params_json[\"k\"]] \n        security_params[\"c_encodings\"] = [parse_expr(x) for x in security_params_json[\"c\"]]  \n        security_params[\"mpk_encodings\"] = [parse_expr(x) for x in security_params_json[\"mpk\"]] \n        security_params[\"unknown\"] = [parse_expr(x) for x in security_params_json[\"unknown_vars\"]] \n        security_params[\"corruptable_vars\"] = [parse_expr(x) for x in security_params_json[\"corruptable_vars\"]] \n    except:\n        security_params = None\n\n    # parse dec params\n\n    dec_params_json = None\n    corruptable_vars_dec =  None\n    dec_params = {}\n\n    try:\n        dec_params_json = self.json_parsed[\"decryption\"]\n        dec_params[\"key\"] = parse_expr(dec_params_json[\"key\"])\n        dec_params[\"k_encodings\"] = [parse_expr(x) for x in dec_params_json[\"k\"]] \n        dec_params[\"c_encodings\"] = [parse_expr(x) for x in dec_params_json[\"c\"]]  \n        dec_params[\"mpk_encodings\"] = [parse_expr(x) for x in dec_params_json[\"mpk\"]] \n        dec_params[\"gp_encodings\"] = [parse_expr(x) for x in dec_params_json[\"gp\"]] \n        dec_params[\"unknown\"] = [parse_expr(x) for x in dec_params_json[\"unknown_vars\"]] \n        dec_params[\"corruption_model\"] = dec_params_json[\"corruption_model\"]\n\n        # NOTE We suppose every field is always available in the JSON file.\n        # It will be empty if it is not related to a particular corruption model.\n\n        dec_params[\"MPK_AAi\"] = [parse_expr(x) for x in dec_params_json[\"MPK_AAi\"]] \n        dec_params[\"MPK_AAj\"] = [parse_expr(x) for x in dec_params_json[\"MPK_AAj\"]] \n        dec_params[\"misc_vars\"] = [parse_expr(x) for x in dec_params_json[\"misc_vars\"]] \n        corruptable_vars_dec = dec_params_json[\"corruptable_vars\"]\n    except:\n        dec_params = None\n\n    # parse master params\n\n    master_params_json = None\n    corruptable_vars_master = None        \n\n    try:\n        master_params_json = self.json_parsed[\"master_key\"]\n\n        master_params[\"keyenco\"] = [parse_expr(x) for x in master_params_json[\"k\"]] \n        master_params[\"masterkey\"] = parse_expr(master_params_json[\"master_key\"])\n        master_params[\"unknown\"] = [parse_expr(x) for x in master_params_json[\"unknown_vars\"]] \n        master_params[\"corruption_model\"] = master_params_json[\"corruption_model\"]\n\n        master_params[\"MPK_CA\"] = [parse_expr(x) for x in master_params_json[\"MPK_CA\"]] \n        master_params[\"MPK_AA\"] = [parse_expr(x) for x in master_params_json[\"MPK_AA\"]] \n        master_params[\"MPK_vars\"] = [parse_expr(x) for x in master_params_json[\"MPK_vars\"]] \n        master_params[\"GP_vars\"] = [parse_expr(x) for x in master_params_json[\"GP_vars\"]] \n        corruptable_vars_master = master_params_json[\"corruptable_vars\"]\n    except:\n        master_params = None\n\n    return security_params, master_params, corruptable_vars_master, dec_params, corruptable_vars_dec \n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.generate_conditional_params","title":"<code>generate_conditional_params()</code>","text":"<p>Based on the JSON input files, it generates a dictionary with the corresponding parameters to look for conditional attacks. If a list of corruptable variables is supplied, it also generates a list of those variables.</p> <p>Returns:</p> Name Type Description <code>Parameters</code> <code>dict</code> <p>Conditional attack parameters.</p> Source code in <code>parse_config.py</code> <pre><code>def generate_conditional_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n    Based on the JSON input files, it generates a dictionary\n    with the corresponding parameters to look for conditional\n    attacks. If a list of corruptable variables is supplied,\n    it also generates a list of those variables.\n\n    Returns:\n        Parameters (dict): Conditional attack parameters.\n    \"\"\"\n\n    if self.json_parsed is None:\n        print(\"parse_config object is not initialized\")\n        return None, None\n\n\"\"\"\n    TODO: Some of this configuration generation can be automated e.g.\n        # these are fixed in the system\n        att_mpk_group = parse_expr(\"att_mpk_group\")\n        att_scalar = parse_expr(\"att_scalar\")\n        policy_share = parse_expr(\"lambda_policy_share\")\n\n        k_fixed_1 = alpha + r\n        k_att_1 = r + get_indexed_encoding(\"rp\", 1)*att_mpk_group\n        k_att_2 = get_indexed_encoding(\"rp\", 1)\n        c_att_1 = policy_share*att_mpk_group\n        c_att_2 = policy_share\n        mpk1 = att_mpk_group\n        special_s = s\n    \"\"\"\n\n    try:\n        att_mpk_group = parse_expr(\"att_mpk_group\")\n        att_scalar = parse_expr(\"att_scalar\")\n        policy_share = parse_expr(\"lambda_policy_share\")\n\n        mpk1 = att_mpk_group\n        special_s = parse_expr(\"s\")\n        k_fixed = [parse_expr(x) for x in self.json_parsed[\"k_fixed\"]] \n        k_att = [parse_expr(x) for x in self.json_parsed[\"k_indexed\"]] \n        c_fixed = [parse_expr(x) for x in self.json_parsed[\"c_fixed\"]] \n        c_att = [parse_expr(x) for x in self.json_parsed[\"c_indexed\"]] \n        unkown = [parse_expr(x) for x in self.json_parsed[\"unknown\"]] \n\n        mpk = []\n\n        prefixes = [\"rp\"]\n        nr_indexed_encodings = 1\n\n        # prepare conditional params\n\n        cd_params = {}\n        cd_params[\"alpha\"] = parse_expr(\"alpha\")\n        cd_params[\"special_s\"] = special_s\n        cd_params[\"mpk\"] = mpk\n        cd_params[\"k_fixed\"] = k_fixed\n        cd_params[\"k_att\"] = k_att\n        cd_params[\"c_fixed\"] = c_fixed\n        cd_params[\"c_att\"] = c_att\n        cd_params[\"unkown\"] = [],\n        cd_params[\"prefixes\"] = prefixes\n        cd_params[\"nr_indexed_encodings\"] = nr_indexed_encodings\n        cd_params[\"unknown\"] = unkown\n    except:\n        cd_params = None\n\n    return cd_params\n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.generate_dec_key_params","title":"<code>generate_dec_key_params()</code>","text":"<p>Based on the JSON input files, it generates a dictionary with the corresponding parameters to look for decryption attacks. If a list of corruptable variables is supplied, it also generates a list of those variables.</p> <p>Returns:</p> Name Type Description <code>Tuple</code> <code>tuple</code> <p>Decryption attack parameters and corruptable variables</p> Source code in <code>parse_config.py</code> <pre><code>def generate_dec_key_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n    Based on the JSON input files, it generates a dictionary\n    with the corresponding parameters to look for decryption\n    attacks. If a list of corruptable variables is supplied,\n    it also generates a list of those variables.\n\n    Returns:\n        Tuple (tuple): Decryption attack parameters and corruptable variables\n    \"\"\"\n\n    if self.json_parsed is None:\n        print(\"parse_config object is not initialized\")\n        return None, None\n\n    # prepare decryption params\n\n    dec_params = {}\n    corruptable_vars = []\n\n    try:\n        dec_params[\"key\"] = parse_expr(self.json_parsed[\"key\"])\n        dec_params[\"k_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n        dec_params[\"c_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"c\"]]  \n        dec_params[\"mpk_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"mpk\"]] \n        dec_params[\"gp_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"gp\"]] \n        dec_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n\n        dec_params[\"corruption_model\"] = self.json_parsed[\"corruption_model\"]\n\n        # NOTE We suppose every field is always available in the JSON file.\n        # It will be empty if it is not related to a particular corruption model.\n\n        dec_params[\"MPK_AAi\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_AAi\"]] \n        dec_params[\"MPK_AAj\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_AAj\"]] \n\n        dec_params[\"misc_vars\"] = [parse_expr(x) for x in self.json_parsed[\"misc_vars\"]] \n\n        corruptable_vars = self.json_parsed[\"corruptable_vars\"]\n    except:\n        dec_params = None\n\n    return dec_params, corruptable_vars \n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.generate_master_key_params","title":"<code>generate_master_key_params()</code>","text":"<p>Based on the JSON input files, it generates a dictionary with the corresponding parameters to look for master key attacks. If a list of corruptable variables is supplied, it also generates a list of those variables.</p> <p>Returns:</p> Name Type Description <code>Tuple</code> <code>tuple</code> <p>Master key attack parameters and corruptable variables.</p> Source code in <code>parse_config.py</code> <pre><code>def generate_master_key_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n    Based on the JSON input files, it generates a dictionary\n    with the corresponding parameters to look for master key\n    attacks. If a list of corruptable variables is supplied,\n    it also generates a list of those variables.\n\n    Returns:\n            Tuple (tuple): Master key attack parameters and corruptable variables. \n    \"\"\"\n\n    if self.json_parsed is None:\n        print(\"parse_config object is not initialized\")\n        return None, None\n\n    master_params = {}\n    corruptable_vars = {}\n\n    try:\n        master_params[\"keyenco\"] = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n        master_params[\"masterkey\"] = parse_expr(self.json_parsed[\"master_key\"])\n        master_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n        master_params[\"corruption_model\"] = self.json_parsed[\"corruption_model\"]\n\n        master_params[\"MPK_CA\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_CA\"]] \n        master_params[\"MPK_AA\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_AA\"]] \n        master_params[\"MPK_vars\"] = [parse_expr(x) for x in self.json_parsed[\"MPK_vars\"]] \n        master_params[\"GP_vars\"] = [parse_expr(x) for x in self.json_parsed[\"GP_vars\"]] \n\n        corruptable_vars = self.json_parsed[\"corruptable_vars\"]\n    except:\n        master_params = None\n\n    return master_params, corruptable_vars\n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.generate_security_analysis_params","title":"<code>generate_security_analysis_params()</code>","text":"<p>Based on the JSON input files, it generates a dictionary with the corresponding parameters to perform a security analysis of the provided scheme.</p> <p>Returns:</p> Name Type Description <code>Parameters</code> <code>dict</code> <p>Security analysis parameters.</p> Source code in <code>parse_config.py</code> <pre><code>def generate_security_analysis_params(self) -&gt; tuple[dict, list]:\n\"\"\"\n    Based on the JSON input files, it generates a dictionary\n    with the corresponding parameters to perform a security\n    analysis of the provided scheme.\n\n    Returns:\n        Parameters (dict): Security analysis parameters.\n    \"\"\"\n\n    if self.json_parsed is None:\n        print(\"parse_config object is not initialized\")\n        return None, None\n\n    # prepare security_analysis_params\n\n    security_analysis_params = {}\n\n    try:\n        security_analysis_params[\"key\"] = parse_expr(self.json_parsed[\"key\"])\n        security_analysis_params[\"k_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"k\"]] \n        security_analysis_params[\"c_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"c\"]]  \n        security_analysis_params[\"mpk_encodings\"] = [parse_expr(x) for x in self.json_parsed[\"mpk\"]] \n        security_analysis_params[\"unknown\"] = [parse_expr(x) for x in self.json_parsed[\"unknown_vars\"]] \n        security_analysis_params[\"corruptable_vars\"] = [parse_expr(x) for x in self.json_parsed[\"corruptable_vars\"]] \n    except:\n        security_analysis_params = None\n\n    return security_analysis_params\n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.init","title":"<code>init(config_file)</code>","text":"<p>Initializes the parser with a json configuration file that describes the analysis.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>Path to the JSON file.</p> required Source code in <code>parse_config.py</code> <pre><code>def init(self, config_file: str) -&gt; None:\n\"\"\"\n    Initializes the parser with a json configuration file\n    that describes the analysis.\n\n    Parameters:\n        config_file (str): Path to the JSON file.\n    \"\"\"\n    with open(config_file, \"r\") as read_file:\n        self.json_parsed = json.load(read_file)\n</code></pre>"},{"location":"reference/#parse_config.ParseConfig.init_with_str","title":"<code>init_with_str(data)</code>","text":"<p>It is also possible to initialize the parser with a string containing JSON instead of using a file that needs to be open, read, etc.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>String containing JSON code.</p> required Source code in <code>parse_config.py</code> <pre><code>def init_with_str(self, data: str) -&gt; None:\n\"\"\"\n    It is also possible to initialize the parser with\n    a string containing JSON instead of using a file\n    that needs to be open, read, etc.\n\n    Parameters:\n        data (str): String containing JSON code.\n    \"\"\"\n    self.json_parsed = json.loads(data)\n</code></pre>"},{"location":"reference/#methods-for-generating-indexed-encodings-and-specific-access-structures","title":"Methods for generating indexed encodings and specific access structures","text":"<p>access_structures.py: This module contains functions for generating specific access structures and for generating encodings utilized in the ACABELLA analysis methods.</p>"},{"location":"reference/#access_structures.create_policy_matrix_for_AND","title":"<code>create_policy_matrix_for_AND(length)</code>","text":"<p>Creates a policy matrix for the AND-gate of a given length.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the policy matrix.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Policy matrix for AND.</p> Source code in <code>access_structures.py</code> <pre><code>def create_policy_matrix_for_AND(length):\n\"\"\"\n    Creates a policy matrix for the AND-gate of a given length.\n\n    Parameters:\n        length (int): Length of the policy matrix.\n\n    Returns:\n        (array): Policy matrix for AND.\n    \"\"\"  \n    matrix_A = zeros(length, length)\n    matrix_A[0,0] = 1\n    matrix_A[0,1] = 1\n    matrix_A[length-1,length-1] = -1\n    for ind in range(1,length-1):\n        matrix_A[ind,ind] = -1\n        matrix_A[ind,ind + 1] = 1\n    return matrix_A\n</code></pre>"},{"location":"reference/#access_structures.create_policy_matrix_for_general_access_policy","title":"<code>create_policy_matrix_for_general_access_policy(length)</code>","text":"<p>Creates a policy matrix for the  general case of a given length.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the policy matrix.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Policy matrix for AND.</p> Source code in <code>access_structures.py</code> <pre><code>def create_policy_matrix_for_general_access_policy(length):\n\"\"\"\n    Creates a policy matrix for the  general case of a given length.\n\n    Parameters:\n        length (int): Length of the policy matrix.\n\n    Returns:\n        (array): Policy matrix for AND.\n    \"\"\"  \n    matrix_A = zeros(length, length)\n    for i in range(length):\n        sum_row = 0\n        for j in range(1,length):\n            new_entry = parse_expr(\"A_(\" + str(i+1) + \",\" + str(j+1) + \")\")\n            matrix_A[i,j] = new_entry\n            w_entry = parse_expr(\"w_\" + str(j+1))\n            sum_row -= new_entry*w_entry\n        # matrix_A[i,0] = parse_expr(\"A_(\" + str(i+1) + \",1)\")\n        matrix_A[i,0] = sum_row\n    return matrix_A\n</code></pre>"},{"location":"reference/#access_structures.create_share_vector","title":"<code>create_share_vector(length, special_s)</code>","text":"<p>Creates a share vector v.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the policy matrix.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Sympy description of s.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Vector of shares.</p> Source code in <code>access_structures.py</code> <pre><code>def create_share_vector(length, special_s):\n\"\"\"\n    Creates a share vector v.\n\n    Parameters:\n        length (int): Length of the policy matrix.\n        special_s (sp.core.list.Symbol): Sympy description of s.\n\n    Returns:\n        (list): Vector of shares.\n    \"\"\"      \n    vec_v = zeros(length,1)\n    vec_v[0,0] = special_s\n    for ind in range(1,length):\n        vec_v[ind,0] = parse_expr(\"v_\" + str(ind+1))\n    return vec_v\n</code></pre>"},{"location":"reference/#access_structures.get_attribute_as_scalar","title":"<code>get_attribute_as_scalar(index)</code>","text":"<p>Returns a scalar x_att for some index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index to add at the end of the encoding.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Encoding starting with x_</p> Source code in <code>access_structures.py</code> <pre><code>def get_attribute_as_scalar(index):\n\"\"\"\n    Returns a scalar x_att for some index\n\n    Parameters:\n        index (str): Index to add at the end of the encoding.\n\n    Returns:\n        (sp.core.list.Symbol): Encoding starting with x_\n    \"\"\"      \n    return parse_expr(\"x_\" + str(index))\n</code></pre>"},{"location":"reference/#access_structures.get_attribute_in_group","title":"<code>get_attribute_in_group(index)</code>","text":"<p>Returns a public key b_att for attribute with index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>str</code> <p>Index to add at the end of the encoding.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Encoding starting with b_</p> Source code in <code>access_structures.py</code> <pre><code>def get_attribute_in_group(index):\n\"\"\"\n    Returns a public key b_att for attribute with index\n\n    Parameters:\n        index (str): Index to add at the end of the encoding.\n\n    Returns:\n        (sp.core.list.Symbol): Encoding starting with b_\n    \"\"\"      \n    return parse_expr(\"b_\" + str(index))\n</code></pre>"},{"location":"reference/#access_structures.get_i_of_n_policy_shares","title":"<code>get_i_of_n_policy_shares(index, length, special_s)</code>","text":"<p>Get the i-th share for a policy of length n for a policy  consisting of an AND-gate.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Position in the lambda vector.</p> required <code>length</code> <code>int</code> <p>Length of the AND policy matrix.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Sympy description of s.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Value of lambda vector at index position.</p> Source code in <code>access_structures.py</code> <pre><code>def get_i_of_n_policy_shares(index, length, special_s):\n\"\"\"\n    Get the i-th share for a policy of length n for a policy \n    consisting of an AND-gate.\n\n    Parameters:\n        index (int): Position in the lambda vector.\n        length (int): Length of the AND policy matrix.\n        special_s (sp.core.list.Symbol): Sympy description of s.\n\n    Returns:\n        (sp.core.list.Symbol): Value of lambda vector at index position.\n    \"\"\"      \n    vec_lambda = create_policy_matrix_for_AND(length) * create_share_vector(length, special_s)\n    return vec_lambda[index]\n</code></pre>"},{"location":"reference/#access_structures.get_i_of_n_policy_shares_general","title":"<code>get_i_of_n_policy_shares_general(index, length, special_s)</code>","text":"<p>Get the i-th share for a policy of length n where the policy is a general matrix.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Position in the lambda vector.</p> required <code>length</code> <code>int</code> <p>Length of the AND policy matrix.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Sympy description of s.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Value of lambda vector at index position.</p> Source code in <code>access_structures.py</code> <pre><code>def get_i_of_n_policy_shares_general(index, length, special_s):\n\"\"\"\n    Get the i-th share for a policy of length n where the policy is a general matrix.\n\n    Parameters:\n        index (int): Position in the lambda vector.\n        length (int): Length of the AND policy matrix.\n        special_s (sp.core.list.Symbol): Sympy description of s.\n\n    Returns:\n        (sp.core.list.Symbol): Value of lambda vector at index position.\n    \"\"\"      \n    vec_lambda = create_policy_matrix_for_general_access_policy(length) * create_share_vector(length, special_s)\n    return vec_lambda[index]\n</code></pre>"},{"location":"reference/#access_structures.get_indexed_encoding","title":"<code>get_indexed_encoding(prefix, index)</code>","text":"<p>Returns an indexed encoding with prefix with extra indices for the  attribute and the key nr, e.g., r_(1,att).</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add to the encoding.</p> required <code>index</code> <code>str</code> <p>Index to add at the end of the encoding.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Indexed encoding</p> Source code in <code>access_structures.py</code> <pre><code>def get_indexed_encoding(prefix, index):\n\"\"\"\n    Returns an indexed encoding with prefix with extra indices for the \n    attribute and the key nr, e.g., r_(1,att).\n\n    Parameters:\n        prefix (str): Prefix to add to the encoding.\n        index (str): Index to add at the end of the encoding.\n\n    Returns:\n        (sp.core.list.Symbol): Indexed encoding \n    \"\"\"      \n    return parse_expr(\"indexed_enc_\" + prefix + \"_\" + str(index))\n</code></pre>"},{"location":"reference/#access_structures.get_indexed_encoding_extra_index","title":"<code>get_indexed_encoding_extra_index(prefix, index1, index2, index_key)</code>","text":"<p>Returns an indexed encoding with prefix with extra indices (2) for the  attribute and the key nr, e.g., r_(1,att).</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add to the encoding.</p> required <code>index1</code> <code>str</code> <p>First index to add.</p> required <code>index2</code> <code>str</code> <p>Second index to add.</p> required <code>index_key</code> <code>str</code> <p>Index to add at the end of the encoding.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Indexed encoding</p> Source code in <code>access_structures.py</code> <pre><code>def get_indexed_encoding_extra_index(prefix, index1, index2, index_key):\n\"\"\"\n    Returns an indexed encoding with prefix with extra indices (2) for the \n    attribute and the key nr, e.g., r_(1,att).\n\n    Parameters:\n        prefix (str): Prefix to add to the encoding.\n        index1 (str): First index to add.\n        index2 (str): Second index to add.\n        index_key (str): Index to add at the end of the encoding.\n\n    Returns:\n        (sp.core.list.Symbol): Indexed encoding \n    \"\"\"      \n    return parse_expr(prefix + \"_(\" + str(index1) + \",att_\" \n                      + str(index2) + \",\" + str(index_key) + \")\")\n</code></pre>"},{"location":"reference/#methods-for-working-with-sympy-symbols","title":"Methods for working with Sympy symbols","text":"<p>common.py: general methods for dealing with symbols in the attack and analysis implementations</p>"},{"location":"reference/#doc_common.addcomptodecomp","title":"<code>addcomptodecomp(kvector, uvector, toadd)</code>","text":"<p>Adds a new monomial split in a known and unknown part to kvector and uvector</p> <p>Parameters:</p> Name Type Description Default <code>kvector</code> <code>list</code> <p>Known vector of variables</p> required <code>uvector</code> <code>list</code> <p>Unknown vector of variables</p> required <code>toadd</code> <code>list</code> <p>Monomial split</p> required Source code in <code>doc_common.py</code> <pre><code>def addcomptodecomp(kvector: list, uvector: list, toadd) -&gt; None:\n\"\"\"\n    Adds a new monomial split in a known and unknown part to kvector and uvector\n\n    Parameters:\n        kvector (list): Known vector of variables\n        uvector (list): Unknown vector of variables\n        toadd (list): Monomial split\n    \"\"\"   \n    [k, u] = toadd\n    (b, c, umul) = invector(u, uvector)\n    kmul = 1\n    for g in k:\n        kmul = Mul(kmul, g)\n    if b:\n        kvector[c] = Add(kvector[c], kmul)\n    else:\n        kvector.append(kmul)\n        uvector.append(umul)\n</code></pre>"},{"location":"reference/#doc_common.appendzeros","title":"<code>appendzeros(mat, uvector)</code>","text":"<p>Takes a matrix as input and makes each row as long as uvector</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array</code> <p>Input matrix</p> required <code>uvector</code> <code>list</code> <p>Unknown vector of variables</p> required Source code in <code>doc_common.py</code> <pre><code>def appendzeros(mat, uvector: list) -&gt; None:\n\"\"\"\n    Takes a matrix as input and makes each row as long as uvector\n\n    Parameters:\n        mat (array): Input matrix\n        uvector (list): Unknown vector of variables\n    \"\"\"   \n    l = len(uvector)\n    for f in mat:\n        while len(f) &lt; l:\n            f.append(0)\n</code></pre>"},{"location":"reference/#doc_common.canonical","title":"<code>canonical(listpolys)</code>","text":"<p>First ensure that all polynomials are in canonical form.</p> <p>Parameters:</p> Name Type Description Default <code>listpolys</code> <code>list</code> <p>List of poynomials.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of polynomials in canonical form.</p> Source code in <code>doc_common.py</code> <pre><code>def canonical(listpolys: list) -&gt; list:\n\"\"\"\n    First ensure that all polynomials are in canonical form.\n\n    Parameters:\n        listpolys (list): List of poynomials.\n\n    Returns:\n        (list): List of polynomials in canonical form.\n    \"\"\"   \n    copylist = []\n    for x in listpolys:\n        x = x.expand()\n        copylist.append(x)\n    return copylist\n</code></pre>"},{"location":"reference/#doc_common.collect_denoms","title":"<code>collect_denoms(lis, unknowns)</code>","text":"<p>Collects the denominators of the encodings not to be confused with demons</p> <p>Parameters:</p> Name Type Description Default <code>lis</code> <code>list</code> <p>Input list of sp.core.list.Symbol expressions.</p> required <code>unknown</code> <code>list</code> <p>List of unknowns as sympy expressions.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of denominators.</p> Source code in <code>doc_common.py</code> <pre><code>def collect_denoms(lis: list, unknowns: list) -&gt; list:\n\"\"\"\n    Collects the denominators of the encodings\n    not to be confused with demons\n\n    Parameters:\n        lis (list): Input list of sp.core.list.Symbol expressions.\n        unknown (list): List of unknowns as sympy expressions.\n\n    Returns:\n        (list): List of denominators.\n    \"\"\"   \n    ## this part is the same as in writepolyasprod\n    colmono = []\n    for poly in lis:\n        recovermonos(poly, colmono)\n        cmcpy = []\n    for f in colmono:\n        if not (f == None):\n            cmcpy.append(f)\n    variables = []\n    for mono in cmcpy:\n        recovervars(mono, variables)\n    denoms = []\n    for var in variables:\n        if is_var_denom(var):\n            if var_contains_unknown(var.args[0], unknowns):\n                if is_var_not_in_list(var.args[0], denoms):\n                    denoms.append(var.args[0])\n    return denoms\n</code></pre>"},{"location":"reference/#doc_common.decompose","title":"<code>decompose(lisi, unknown)</code>","text":"<p>Decomposes list lisi of variables in two lists: k = list of known variables and u = list of unknown variables</p> <p>Parameters:</p> Name Type Description Default <code>lisi</code> <code>list</code> <p>List of variables</p> required <code>unknown</code> <code>list</code> <p>Unkonwn variables</p> required <p>Returns:</p> Type Description <code>bool</code> <p>According to the intersection of lis1 and list2</p> Source code in <code>doc_common.py</code> <pre><code>def decompose(lisi: list, unknown) -&gt; list:\n\"\"\"\n    Decomposes list lisi of variables in two lists:\n    k = list of known variables and u = list of unknown variables\n\n    Parameters:\n        lisi (list): List of variables\n        unknown (list): Unkonwn variables\n\n    Returns:\n        (bool): According to the intersection of lis1 and list2\n    \"\"\"    \n\n    k = []\n    u = []\n    for f in lisi:\n        g = []\n        findsymb(f, g)\n        if intersectnotempt(g, unknown):\n            u.append(f)\n        else:\n            k.append(f)\n    return [k, u]\n</code></pre>"},{"location":"reference/#doc_common.denoms_prod","title":"<code>denoms_prod(denoms)</code>","text":"<p>Computes the product of denoms</p> <p>Parameters:</p> Name Type Description Default <code>denoms</code> <code>list</code> <p>Product of denominators.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Product of denominators.</p> Source code in <code>doc_common.py</code> <pre><code>def denoms_prod(denoms: list):\n\"\"\"\n    Computes the product of denoms\n\n    Parameters:\n        denoms (list): Product of denominators.\n\n    Returns:\n        (list): Product of denominators.\n    \"\"\"   \n    denomprod = 1\n    for denom in denoms:\n        denomprod = Mul(denomprod, denom)\n    return denomprod\n</code></pre>"},{"location":"reference/#doc_common.find_attack_row","title":"<code>find_attack_row(mat)</code>","text":"<p>Given a matrix finds the attack row.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>array</code> <p>Input matrix.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If a row can be attacked.</p> <code>list</code> <p>Row.</p> Source code in <code>doc_common.py</code> <pre><code>def find_attack_row(mat):\n\"\"\"\n    Given a matrix finds the\n    attack row.\n\n    Parameters:\n        matrix (array): Input matrix.\n\n    Returns:\n        (bool): If a row can be attacked.\n        (list): Row.\n    \"\"\"   \n    nr_rows = shape(mat)[0]\n\n    if nr_rows == 0:\n        return True, None\n\n    for i in range(nr_rows):\n        row = mat.row(i)\n        if row[-1] != 0:\n            return False, (-row / row[-1])[:-1]\n    return False, 0 * row[:-1]\n</code></pre>"},{"location":"reference/#doc_common.findsymb","title":"<code>findsymb(f, g)</code>","text":"<p>Adds the symbols occurring in f to g</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>list of sp.core.list.Symbol</code> <p>first expression</p> required <code>g</code> <code>list of sp.core.list.Symbol</code> <p>second expression</p> required Source code in <code>doc_common.py</code> <pre><code>def findsymb(f, g):\n\"\"\"\n    Adds the symbols occurring in f to g\n\n    Parameters:\n        f (list of sp.core.list.Symbol): first expression\n        g (list of sp.core.list.Symbol): second expression\n    \"\"\"    \n    if f.func == Symbol:\n        g.append(f)\n    else:\n        for fp in f.args:\n            findsymb(fp, g)\n</code></pre>"},{"location":"reference/#doc_common.gen_all_p","title":"<code>gen_all_p(k, c, mpk, gp)</code>","text":"<p>Gives all possible products that an attacker can generate.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>list</code> <p>List of key encodings.</p> required <code>c</code> <code>list</code> <p>List of ciphertext encodings.</p> required <code>mpk</code> <code>list</code> <p>List of MPK encodings.</p> required <code>gp</code> <code>list</code> <p>List of global parameter encodings.</p> required <p>Returns:</p> Type Description <code>list</code> <p>All possible combinations of encodings.</p> Source code in <code>doc_common.py</code> <pre><code>def gen_all_p(k, c, mpk, gp):\n\"\"\"\n    Gives all possible products that an attacker can generate.\n\n    Parameters:\n        k (list): List of key encodings.\n        c (list): List of ciphertext encodings.\n        mpk (list): List of MPK encodings.\n        gp (list): List of global parameter encodings.\n    Returns:\n        (list): All possible combinations of encodings. \n    \"\"\"   \n\n    # k*c\n\n    all_k_c = []\n    for i in k:\n        for j in c:\n            all_k_c.append(i * j)\n\n    # k*mpk\n\n    all_k_mpk = []\n    for i in k:\n        for j in mpk:\n            all_k_mpk.append(i * j)\n\n    # c*mpk\n\n    all_mpk_c = []\n    for i in c:\n        for j in mpk:\n            all_mpk_c.append(i * j)\n\n    # c*gp\n\n    all_gp_c = []\n    for i in c:\n        for j in gp:\n            all_gp_c.append(i * j)\n\n    # k*gp\n\n    all_gp_k = []\n    for i in k:\n        for j in gp:\n            all_gp_k.append(i * j)\n\n    return all_k_c + all_k_mpk + all_mpk_c + all_gp_c + all_gp_k\n</code></pre>"},{"location":"reference/#doc_common.get_vars_list_polynomials","title":"<code>get_vars_list_polynomials(polys)</code>","text":"<p>Returns list of variables occuring in the list of polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>polys</code> <code>list</code> <p>Polynomial.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of variables occuring in poly.</p> Source code in <code>doc_common.py</code> <pre><code>def get_vars_list_polynomials(polys):\n\"\"\"\n    Returns list of variables occuring in the list of polynomials.\n\n    Parameters:\n        polys (list): Polynomial.\n\n    Returns:\n        (list): List of variables occuring in poly.\n    \"\"\"   \n    lis_vars = []\n    for poly in polys:\n        lis_vars += get_vars_polynomial(poly)\n    return lis_vars\n</code></pre>"},{"location":"reference/#doc_common.get_vars_polynomial","title":"<code>get_vars_polynomial(poly)</code>","text":"<p>Returns a list of variables occuring in the polynomial poly.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>list</code> <p>Polynomial.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of variables occuring in poly.</p> Source code in <code>doc_common.py</code> <pre><code>def get_vars_polynomial(poly):\n\"\"\"\n    Returns a list of variables occuring in the polynomial poly.\n\n    Parameters:\n        poly (list): Polynomial.\n\n    Returns:\n        (list): List of variables occuring in poly.\n    \"\"\"   \n    monos = []\n    recovermonos(poly, monos)\n    monos_cpy = []\n    for f in monos:\n        if f != None:\n            monos_cpy.append(f)\n    monos = monos_cpy\n    lis_vars = []\n    for mono in monos:\n        recovervars(mono, lis_vars)\n\n    lis_vars_cpy = []\n    for elem in lis_vars:\n        if not elem in lis_vars_cpy:\n            lis_vars_cpy.append(elem)\n    return lis_vars_cpy\n</code></pre>"},{"location":"reference/#doc_common.intersectnotempt","title":"<code>intersectnotempt(lis1, lis2)</code>","text":"<p>Checks if the intersection of lis1 and lis2 is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>list1</code> <code>list</code> <p>First list</p> required <code>list2</code> <code>list</code> <p>Second list</p> required <p>Returns:</p> Type Description <code>bool</code> <p>According to the intersection of lis1 and list2</p> Source code in <code>doc_common.py</code> <pre><code>def intersectnotempt(lis1: list, lis2: list) -&gt; bool:\n\"\"\"\n    Checks if the intersection of lis1 and lis2 is not empty.\n\n    Parameters:\n        list1 (list): First list\n        list2 (list): Second list\n\n    Returns:\n        (bool): According to the intersection of lis1 and list2\n    \"\"\"    \n    for f in lis1:\n        if f in lis2:\n            return True\n    return False\n</code></pre>"},{"location":"reference/#doc_common.invector","title":"<code>invector(f, vec)</code>","text":"<p>Checks if the monomial f is already in vec</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>list</code> <p>Monomial f</p> required <code>vec</code> <code>list</code> <p>Input vector</p> required Source code in <code>doc_common.py</code> <pre><code>def invector(f, vec):\n\"\"\"\n    Checks if the monomial f is already in vec\n\n    Parameters:\n        f (list): Monomial f\n        vec (list): Input vector\n    \"\"\"   \n    fmul = 1\n    for g in f:\n        fmul = Mul(fmul, g)\n    c = 0\n    for fp in vec:\n        if fmul == fp:\n            return (True, c, fmul)\n        c += 1\n    return (False, -1, fmul)\n</code></pre>"},{"location":"reference/#doc_common.is_var_denom","title":"<code>is_var_denom(var)</code>","text":"<p>It detects if a variable is part of the denominator.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>sp.core.list.Symbol</code> <p>Input variable.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result of checking if a variable is part of the denominator.</p> Source code in <code>doc_common.py</code> <pre><code>def is_var_denom(var) -&gt; bool:\n\"\"\"\n    It detects if a variable is part of the\n    denominator.\n\n    Parameters:\n        var (sp.core.list.Symbol): Input variable.\n\n    Returns:\n        (bool): Result of checking if a variable is part of the denominator.\n    \"\"\"   \n    if var.func == Pow:\n        if var.args[1] == -1:\n            return True\n    return False\n</code></pre>"},{"location":"reference/#doc_common.is_var_not_in_list","title":"<code>is_var_not_in_list(var, lis)</code>","text":"<p>It detects if a variable doesn't belong to a list.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>sp.core.list.Symbol</code> <p>Input variable.</p> required <code>lis</code> <code>list</code> <p>List of sympy expressions.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result of check.</p> Source code in <code>doc_common.py</code> <pre><code>def is_var_not_in_list(var, lis) -&gt; bool:\n\"\"\"\n    It detects if a variable doesn't belong\n    to a list.\n\n    Parameters:\n        var (sp.core.list.Symbol): Input variable.\n        lis (list): List of sympy expressions.\n\n    Returns:\n        (bool): Result of check.\n    \"\"\"   \n    for varx in lis:\n        if var == varx:\n            return False\n    return True\n</code></pre>"},{"location":"reference/#doc_common.merge_lists","title":"<code>merge_lists(lis1, lis2)</code>","text":"<p>Merges two lists of sp.core.list.Symbol expresions.</p> <p>Parameters:</p> Name Type Description Default <code>lis1</code> <code>list</code> <p>List of sp.core.list.Symbol expresions.</p> required <code>lis2</code> <code>list</code> <p>List of sp.core.list.Symbol expresions.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Merged list.</p> Source code in <code>doc_common.py</code> <pre><code>def merge_lists(lis1, lis2):\n\"\"\"\n    Merges two lists of sp.core.list.Symbol expresions.\n\n    Parameters:\n        lis1 (list): List of sp.core.list.Symbol expresions.\n        lis2 (list): List of sp.core.list.Symbol expresions.\n\n    Returns:\n        (list): Merged list.\n    \"\"\"   \n    lis3 = []\n    for elem in lis1 + lis2:\n        if not elem in lis3:\n            lis3.append(elem)\n    return lis3\n</code></pre>"},{"location":"reference/#doc_common.recovermonos","title":"<code>recovermonos(ar, col)</code>","text":"<p>Returns a list of monomials of a given polynomial ar</p> <p>Parameters:</p> Name Type Description Default <code>ar</code> <code>list</code> <p>Input polynomial</p> required <code>col</code> <code>list</code> <p>List of monomials of polynomial ar</p> required Source code in <code>doc_common.py</code> <pre><code>def recovermonos(ar, col: list) -&gt; None:\n\"\"\"\n    Returns a list of monomials of a given polynomial ar\n\n    Parameters:\n        ar (list): Input polynomial\n        col (list): List of monomials of polynomial ar\n    \"\"\"   \n    if type(ar) != int:\n        if ar.func == Add:\n            for f in ar.args:\n                col.append(recovermonos(f, col))\n        else:\n            col.append(ar)\n</code></pre>"},{"location":"reference/#doc_common.recovervars","title":"<code>recovervars(mono, lis)</code>","text":"<p>Adds the variables of a monomial to list lis</p> <p>Parameters:</p> Name Type Description Default <code>mono</code> <code>list</code> <p>Monomial</p> required <code>lis</code> <code>list</code> <p>List to add teh variables</p> required Source code in <code>doc_common.py</code> <pre><code>def recovervars(mono, lis: list) -&gt; None:\n\"\"\"\n    Adds the variables of a monomial to list lis\n\n    Parameters:\n        mono (list): Monomial\n        lis (list): List to add teh variables\n    \"\"\"    \n    if mono.func == Mul:\n        for f in mono.args:\n            recovervars(f, lis)\n    else:\n        lis.append(mono)\n</code></pre>"},{"location":"reference/#doc_common.reordermatuvec","title":"<code>reordermatuvec(masterkey, mat, uvector)</code>","text":"<p>Reordering matrix and uvector so master key is in first entry.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>List of poynomials.</p> required <code>uvector</code> <code>list</code> <p>List of unkonwn variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The master key was identified.</p> <code>array</code> <p>Matrix reordered so mater key is in the first entry.</p> <code>list</code> <p>List of unkown variables.</p> Source code in <code>doc_common.py</code> <pre><code>def reordermatuvec(masterkey, mat, uvector: list):\n\"\"\"\n    Reordering matrix and uvector so master key is in first entry.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): List of poynomials.\n        uvector (list): List of unkonwn variables.\n\n    Returns:\n        (bool): The master key was identified.\n        (array): Matrix reordered so mater key is in the first entry.\n        (list): List of unkown variables.\n    \"\"\"   \n    mk_found = False\n\n    if uvector[0] == masterkey:\n        mk_found = True\n        return (mk_found, mat, uvector)\n    c = 0\n    for u in uvector:\n        if u == masterkey:\n            cp = c\n            mk_found = True\n        c += 1\n\n    if mk_found:\n        uvector = [uvector[cp]] + uvector[:cp] + uvector[cp + 1 :]\n        matcpy = []\n        for lis in mat:\n            lis = [lis[cp]] + lis[:cp] + lis[cp + 1 :]\n            matcpy.append(lis)\n        return (mk_found, matcpy, uvector)\n\n    return (mk_found, mat, uvector)\n</code></pre>"},{"location":"reference/#doc_common.transform_encoding_list","title":"<code>transform_encoding_list(denomprod, p)</code>","text":"<p>Normalizes the encoding list with respect to the denominators.</p> <p>Parameters:</p> Name Type Description Default <code>denomprod</code> <code>list</code> <p>List of denominators.</p> required <code>p</code> <code>list</code> <p>Encoding list.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Transformed encoding list.</p> Source code in <code>doc_common.py</code> <pre><code>def transform_encoding_list(denomprod, p):\n\"\"\"\n    Normalizes the encoding list with respect to the denominators.\n\n    Parameters:\n        denomprod (list): List of denominators.\n        p (list): Encoding list.\n\n    Returns:\n        (list): Transformed encoding list.\n    \"\"\"   \n    pcpy = []\n\n    for pp in p:\n        pcpy.append(cancel(pp * denomprod))\n\n    return canonical(pcpy)\n</code></pre>"},{"location":"reference/#doc_common.trim_matrix_and_uvector","title":"<code>trim_matrix_and_uvector(mat, uvec)</code>","text":"<p>Removes the rows in the matrix that do not contribute an attack.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array</code> <p>Attacking matrix.</p> required <code>uvec</code> <p>Unknown vector.</p> required <p>Returns:</p> Type Description <code>array</code> <p>Matrix after trimming.</p> Source code in <code>doc_common.py</code> <pre><code>def trim_matrix_and_uvector(mat, uvec):\n\"\"\"\n    Removes the rows in the matrix that do not contribute an attack.\n\n    Parameters:\n        mat (array): Attacking matrix.\n        uvec: Unknown vector.\n\n    Returns:\n        (array): Matrix after trimming.\n    \"\"\"   \n    nr_rows = shape(mat)[0]\n    nr_columns = shape(mat)[1]\n    rows_to_delete = []\n    cols_to_delete = []\n\n    for jind in range(nr_columns):\n        ctr = 0\n        last_iind = 0\n        for iind in range(nr_rows):\n            if mat[iind,jind] != 0:\n                ctr += 1\n                last_iind = iind\n        if ctr == 1:\n            if not last_iind in rows_to_delete:\n                rows_to_delete.append(last_iind)\n            cols_to_delete.append(jind)\n\n    for jind in reversed(cols_to_delete):\n        mat.col_del(jind)\n        del uvec[jind]\n\n    rows_to_delete2 = []\n    for ind in reversed(range(nr_rows-1)):\n        if ind in rows_to_delete:\n            rows_to_delete2.append(ind)\n\n    for ind in rows_to_delete2:\n        mat.row_del(ind)\n\n    return (mat, uvec, rows_to_delete2, reversed(cols_to_delete))\n</code></pre>"},{"location":"reference/#doc_common.var_contains_unknown","title":"<code>var_contains_unknown(var, unknowns)</code>","text":"<p>It detects if a sympy variable is part of the unknowns.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>sp.core.list.Symbol</code> <p>Input variable.</p> required <code>unknown</code> <code>list</code> <p>List of unknowns as sympy expressions.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result of check.</p> Source code in <code>doc_common.py</code> <pre><code>def var_contains_unknown(var, unknowns: list) -&gt; bool:\n\"\"\"\n    It detects if a sympy variable is part of the\n    unknowns.\n\n    Parameters:\n        var (sp.core.list.Symbol): Input variable.\n        unknown (list): List of unknowns as sympy expressions.\n\n    Returns:\n        (bool): Result of check.\n    \"\"\"   \n    if var.func == Symbol:\n        return var in unknowns\n    for x in var.args:\n        if x in unknowns:\n            return True\n    return False\n</code></pre>"},{"location":"reference/#doc_common.writeencodingasprod","title":"<code>writeencodingasprod(enco, unknown)</code>","text":"<p>This takes as input an encoding and a set of unknown variables. It outputs a matrix decomposition, where the matrix consists of integers and known variables, and the vector of unknown variables.</p> <p>Parameters:</p> Name Type Description Default <code>enco</code> <code>list</code> <p>Input encoding.</p> required <code>unknown</code> <code>list</code> <p>Vector of unknown variables.</p> required Source code in <code>doc_common.py</code> <pre><code>def writeencodingasprod(enco: list, unknown: list) -&gt; tuple[list, list]:\n\"\"\"\n    This takes as input an encoding and a set of unknown variables.\n    It outputs a matrix decomposition, where the matrix consists of\n    integers and known variables, and the vector of unknown variables.\n\n    Parameters:\n        enco (list): Input encoding.\n        unknown (list): Vector of unknown variables.\n    \"\"\"   \n    uvector = []\n    mat = []\n    for poly in enco:\n        mat.append(writepolyasprod(poly, uvector, unknown))\n    appendzeros(mat, uvector)\n    return (mat, uvector)\n</code></pre>"},{"location":"reference/#doc_common.writepolyasprod","title":"<code>writepolyasprod(poly, uvector, unknown)</code>","text":"<p>This takes as input a polynomial, and a set of unknown variables. It outputs a vector decomposition, where the kvector consists of integers and known variables, and the uvector of unknown variables.</p> <p>Parameters:</p> Name Type Description Default <code>poly</code> <code>sp.core.list.Symbol</code> <p>Polynomial expression.</p> required <code>uvector</code> <code>list</code> <p>Vector decomposition.</p> required <code>unknown</code> <code>list</code> <p>Vector of unknown variables.</p> required Source code in <code>doc_common.py</code> <pre><code>def writepolyasprod(poly, uvector: list, unknown: list) -&gt; None:\n\"\"\"\n    This takes as input a polynomial, and a set of unknown variables.\n    It outputs a vector decomposition, where the kvector consists of\n    integers and known variables, and the uvector of unknown variables.\n\n    Parameters:\n        poly (sp.core.list.Symbol): Polynomial expression.\n        uvector (list): Vector decomposition.\n        unknown (list): Vector of unknown variables.\n    \"\"\"   \n    colmono = []\n    # this recovers a list colmono of monomials\n    recovermonos(poly, colmono)\n    cmcpy = []\n    # this eliminates all occurrences of 'None'\n    for f in colmono:\n        if not (f == None):\n            cmcpy.append(f)\n    variables = []\n    # for each monomial in the list, we:\n    for mono in cmcpy:\n        lis = []\n        # recover a list of the variables\n        recovervars(mono, lis)\n        # note that variables is a list of lists of variables\n        # the first entry is the list of variables of the first monomial, etc.\n        variables.append(lis)\n    kvector = [0 for x in uvector]\n    # for each list of variables f\n    for f in variables:\n        # we decompose it into a subset of known and subset of unknown variables\n        liso = decompose(f, unknown)\n        # we add the decomposition to the known and uknown-variable vector\n        # this is done by first checking wether the product of the unknown\n        # variables is already in uvector or not\n        addcomptodecomp(kvector, uvector, liso)\n    return kvector\n</code></pre>"},{"location":"reference/#methods-for-generating-general-encodings","title":"Methods for generating general encodings","text":""},{"location":"reference/#encodings_helper.create_b_encoding","title":"<code>create_b_encoding(gp, mpk, att_range)</code>","text":"<p>Creates the encoding for the common variables b based on the used attributes.</p> <p>Parameters:</p> Name Type Description Default <code>gp</code> <code>list</code> <p>List of global parameters.</p> required <code>mpk</code> <code>list</code> <p>List of mpk encodings.</p> required <p>Returns:</p> Type Description <code>list</code> <p>b encoding</p> Source code in <code>encodings_helper.py</code> <pre><code>def create_b_encoding(gp, mpk, att_range):\n\"\"\"\n    Creates the encoding for the common variables b based on the used attributes.\n\n    Parameters:\n        gp (list): List of global parameters.\n        mpk (list): List of mpk encodings.\n\n    Returns:\n        (list): b encoding\n    \"\"\"      \n    benc = gp + mpk\n    for ind in att_range:\n        benc.append(get_attribute_in_group(ind))\n    return benc\n</code></pre>"},{"location":"reference/#encodings_helper.create_ciphertext_encoding","title":"<code>create_ciphertext_encoding(c_fixed, c_att, special_s, att_range, prefixes, nr_indexed_encodings)</code>","text":"<p>This function creates a ciphertext encoding for the attributes in the  att_range, for the AND-policy over all the attributes</p> <p>Parameters:</p> Name Type Description Default <code>c_fixed</code> <code>list</code> <p>List of fixed ciphertext encodings.</p> required <code>c_att</code> <code>list</code> <p>List of attribute-dependent ciphertext encodings.</p> required <code>special_s</code> <code>list</code> <p>Description of s.</p> required <code>att_range</code> <code>list</code> <p>Attributes to use in the ciphertext encoding generation.</p> required <code>prefixes</code> <code>list</code> <p>Prefixes to se.</p> required <code>nr_indexed_encodings</code> <code>list</code> <p>Indexed encodings.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of generated ciphertext encodings.</p> Source code in <code>encodings_helper.py</code> <pre><code>def create_ciphertext_encoding(c_fixed, c_att, special_s, att_range, prefixes, nr_indexed_encodings):\n\"\"\"\n    This function creates a ciphertext encoding for the attributes in the \n    att_range, for the AND-policy over all the attributes\n\n    Parameters:\n        c_fixed (list): List of fixed ciphertext encodings.\n        c_att (list): List of attribute-dependent ciphertext encodings.\n        special_s (list): Description of s.\n        att_range (list): Attributes to use in the ciphertext encoding generation.\n        prefixes (list): Prefixes to se.\n        nr_indexed_encodings (list): Indexed encodings.\n    Returns:\n        (list): List of generated ciphertext encodings.\n    \"\"\" \n    cenc = c_fixed\n    for ind in range(len(att_range)):\n        cenc += substitute_encodings(c_att, special_s, ind, att_range, \n                                         prefixes, nr_indexed_encodings, 0)\n    return cenc\n</code></pre>"},{"location":"reference/#encodings_helper.create_key_encoding","title":"<code>create_key_encoding(k_fixed, k_att, att_range, prefixes, nr_indexed_encodings, key_index_range)</code>","text":"<p>This function creates key encodings for each entry in the key_index_range  list, for attributes in the att_range.        </p> <p>Parameters:</p> Name Type Description Default <code>k_fixed</code> <code>list</code> <p>List of fixed key encodings.</p> required <code>k_att</code> <code>list</code> <p>List of attribute-dependent key encodings.</p> required <code>nr_indexed_encodings</code> <code>list</code> <p>Indexed encodings.</p> required <code>key_index_range</code> <code>list</code> <p>Key index range.</p> required <p>Returns:</p> Type Description <code>list</code> <p>key encodings</p> Source code in <code>encodings_helper.py</code> <pre><code>def create_key_encoding(k_fixed, k_att, att_range, prefixes, nr_indexed_encodings, key_index_range):\n\"\"\"\n    This function creates key encodings for each entry in the key_index_range \n    list, for attributes in the att_range.        \n\n    Parameters:\n        k_fixed (list): List of fixed key encodings.\n        k_att (list): List of attribute-dependent key encodings.\n        nr_indexed_encodings (list): Indexed encodings.\n        key_index_range (list): Key index range.\n\n    Returns:\n        (list): key encodings\n    \"\"\" \n    kenc = k_fixed\n    for ind2 in key_index_range:\n        for ind in range(len(att_range)):\n            no_s = parse_expr(\"no_s\")\n            kenc += substitute_encodings(k_att, no_s, ind, att_range, \n                                             prefixes, nr_indexed_encodings, ind2)\n    return kenc\n</code></pre>"},{"location":"reference/#encodings_helper.generate_known_variable_set","title":"<code>generate_known_variable_set(unknown, kenc, cenc, benc)</code>","text":"<p>Returns all known variables by determining all the variables in the  encodings. .</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>List of key encodings.</p> required <code>cenc</code> <code>list</code> <p>List of ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>List of b encodings.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of generated known variables.</p> Source code in <code>encodings_helper.py</code> <pre><code>def generate_known_variable_set(unknown, kenc, cenc, benc):\n\"\"\"\n    Returns all known variables by determining all the variables in the \n    encodings. .\n\n    Parameters:\n        kenc (list): List of key encodings.\n        cenc (list): List of ciphertext encodings.\n        benc (list): List of b encodings.\n    Returns:\n        (list): List of generated known variables.\n    \"\"\" \n    all_vars = EmptySet\n\n    for enc in benc + cenc + kenc:\n        all_vars = Union(all_vars, enc.free_symbols)\n\n    all_vars = list(all_vars)\n\n    knowns = []\n    for var in all_vars:\n        if not var in unknown:\n            knowns.append(var)\n    return knowns\n</code></pre>"},{"location":"reference/#encodings_helper.generate_unknown_variable_set","title":"<code>generate_unknown_variable_set(kenc, cenc, benc, att_range_ct, att_range_key)</code>","text":"<p>Returns all unknown variables by determining all the variables in the  encodings. It filters out those that are generated by get_attribute_as_scalar.</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>List of key encodings.</p> required <code>cenc</code> <code>list</code> <p>List of ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>List of b encodings.</p> required <code>att_range_ct</code> <code>list</code> <p>Attributes in ciphertext range.</p> required <code>att_range_key</code> <code>list</code> <p>Attributes in key range.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of generated unknown variables.</p> Source code in <code>encodings_helper.py</code> <pre><code>def generate_unknown_variable_set(kenc, cenc, benc, att_range_ct, att_range_key):\n\"\"\"\n    Returns all unknown variables by determining all the variables in the \n    encodings. It filters out those that are generated by get_attribute_as_scalar.\n\n    Parameters:\n        kenc (list): List of key encodings.\n        cenc (list): List of ciphertext encodings.\n        benc (list): List of b encodings.\n        att_range_ct (list): Attributes in ciphertext range.\n        att_range_key (list): Attributes in key range.\n    Returns:\n        (list): List of generated unknown variables.\n    \"\"\" \n    all_vars = EmptySet\n\n    for enc in benc + cenc + kenc:\n        all_vars = Union(all_vars, enc.free_symbols)\n\n    knowns = EmptySet\n    for ind in att_range_ct + att_range_key:\n        knowns = Union(knowns, {get_attribute_as_scalar(ind)})\n\n    unknown = []\n    for el in all_vars:\n        contains = False\n        for elp in knowns:\n            if el == elp:\n                contains = True\n        if not contains:\n            unknown.append(el)\n\n    return unknown\n</code></pre>"},{"location":"reference/#encodings_helper.generate_unknown_variable_set_new","title":"<code>generate_unknown_variable_set_new(known, kenc, cenc, benc, att_range_ct, att_range_key)</code>","text":"<p>Returns all unknown variables by determining all the variables in the  encodings. It filters out those that are generated by get_attribute_as_scalar.</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>List of key encodings.</p> required <code>cenc</code> <code>list</code> <p>List of ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>List of b encodings.</p> required <code>att_range_ct</code> <code>list</code> <p>Attributes in ciphertext range.</p> required <code>att_range_key</code> <code>list</code> <p>Attributes in key range.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of generated unknown variables.</p> Source code in <code>encodings_helper.py</code> <pre><code>def generate_unknown_variable_set_new(known, kenc, cenc, benc, att_range_ct, att_range_key):\n\"\"\"\n    Returns all unknown variables by determining all the variables in the \n    encodings. It filters out those that are generated by get_attribute_as_scalar.\n\n    Parameters:\n        kenc (list): List of key encodings.\n        cenc (list): List of ciphertext encodings.\n        benc (list): List of b encodings.\n        att_range_ct (list): Attributes in ciphertext range.\n        att_range_key (list): Attributes in key range.\n    Returns:\n        (list): List of generated unknown variables.\n    \"\"\" \n    all_vars = EmptySet\n\n    for enc in benc + cenc + kenc:\n        all_vars = Union(all_vars, enc.free_symbols)\n\n    knowns = EmptySet\n    for elem in known:\n        knowns = Union(knowns, {elem})\n    for ind in att_range_ct + att_range_key:\n        knowns = Union(knowns, {get_attribute_as_scalar(ind)})\n\n    unknown = []\n    for el in all_vars:\n        contains = False\n        for elp in knowns:\n            if str(el)[:len(str(elp))] == str(elp):\n                contains = True\n        if not contains:\n            unknown.append(el)\n\n    return unknown\n</code></pre>"},{"location":"reference/#methods-for-translating-the-acabella-format-to-abgw-inputs","title":"Methods for translating the ACABELLA format to ABGW inputs","text":"<p>generate_abgw_inputs.py: This module contains functions involved in the translation of ACABELLA inputs to the ABGW format.</p>"},{"location":"reference/#generate_abgw_inputs.generate_abgw_input","title":"<code>generate_abgw_input(blindingvalue, kenc, cenc, benc, unknown, known)</code>","text":"<p>This function generates a valid ABGW input given a description of the ABE scheme.</p> <p>Parameters:</p> Name Type Description Default <code>blindingvalue</code> <code>sp.core.list.Symbol</code> <p>Blinding value, by default a*s.</p> required <code>kenc</code> <code>list</code> <p>List of key encodings</p> required <code>cenc</code> <code>list</code> <p>List of ciphertext encodings</p> required <code>benc</code> <code>list</code> <p>List of b encodings</p> required <code>unknown</code> <code>unknown</code> <p>List of unknown values</p> required <code>known</code> <code>known</code> <p>List of known values</p> required Source code in <code>generate_abgw_inputs.py</code> <pre><code>def generate_abgw_input(blindingvalue, kenc, cenc, benc, unknown, known):\n\"\"\"\n    This function generates a valid ABGW input given a description of\n    the ABE scheme.\n\n    Parameters:\n        blindingvalue (sp.core.list.Symbol): Blinding value, by default a*s.\n        kenc (list): List of key encodings\n        cenc (list): List of ciphertext encodings\n        benc (list): List of b encodings\n        unknown (unknown): List of unknown values\n        known (known): List of known values\n    \"\"\"   \n    penc = gen_all_p(kenc, cenc, [], [])\n    penc = canonical(penc)\n    penc = [to_c_code(i) for i in penc]\n\n    # prepare header\n\n    ## c_i's\n\n    coef = \"\"\n    for ctr2 in range(len(penc)):\n        if ctr2 != len(penc)- 1:\n            coef += \"c\" + str(ctr2 + 1) + \",\"\n        else:\n            coef += \"c\" + str(ctr2 + 1) + \" in Zp.\"\n    print(\"\\nparams \" + coef)\n\n    ## vars\n\n    print(\"vars \", end=\"\")\n    for elem in unknown:\n        if elem != unknown[-1]:\n            print(str(elem) + \",\", end=\"\")\n        else:\n            print(str(elem) + \" in Zp.\\n\", end=\"\")\n\n    if not known:\n        print(\"\\n\")\n\n    ## extra params\n\n    if known:\n        print(\"params \", end=\"\")\n        for elem in known:\n            if elem != known[-1]:\n                print(str(elem) + \",\", end=\"\")\n            else:\n                print(str(elem) + \" in Zp.\\n\", end=\"\")\n        print(\"\\n\")\n\n    # prepare constraints\n\n    ctr = 1\n    for en in penc:\n        if en != penc[-1]:\n            print(\"c\" + str(ctr) + \"*(\" + str(en) + \")\" + \" +\")\n        else:\n            print(\"c\" + str(ctr) + \"*(\" + str(en) + \")\" + \"\")\n            print(\"= a * s.\\n\\ngo.\\n\")    \n        ctr += 1\n</code></pre>"},{"location":"reference/#generate_abgw_inputs.to_c_code","title":"<code>to_c_code(expr)</code>","text":"<p>This functions removes squares in the form x*2 and replace them by xx. This is required in the ABGW tool. This function is based on https://stackoverflow.com/questions/14264431/expanding-algebraic-powers-in-python-sympy</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>sp.core.list.Symbol</code> <p>Sympy expression to transform.</p> required <p>Returns:</p> Type Description <code>sp.core.list.Symbol</code> <p>Transformed Sympy expression.</p> Source code in <code>generate_abgw_inputs.py</code> <pre><code>def to_c_code(expr):\n\"\"\"\n    This functions removes squares in the form x**2 and replace them\n    by x*x. This is required in the ABGW tool. This function is\n    based on https://stackoverflow.com/questions/14264431/expanding-algebraic-powers-in-python-sympy\n\n    Parameters:\n        expr (sp.core.list.Symbol): Sympy expression to transform.\n\n    Returns:\n        (sp.core.list.Symbol): Transformed Sympy expression.\n    \"\"\"    \n    code = ccode(expr)\n    # sympy has a hard time unsimplifying x**2 to x*x\n    # replace all pow(var,2) with var*var\n    code = re.sub(CPOW, r'\\g&lt;var&gt;*\\g&lt;var&gt;', code)\n    return code\n</code></pre>"},{"location":"reference/#methods-for-proof-generation","title":"Methods for proof generation","text":""},{"location":"reference/#proof_generation.check_kernel_products","title":"<code>check_kernel_products(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>Checks whether the kernel contains vectors that are not zero in the important entries.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Equations found.</p> <code>list</code> <p>Equations.</p> Source code in <code>proof_generation.py</code> <pre><code>def check_kernel_products(masterkey, special_s, kenc, cenc, benc, unknown):\n\"\"\"\n    Checks whether the kernel contains vectors that are not zero in the important entries.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): Equations found.\n        (list): Equations.\n    \"\"\"   \n    kenc = canonical(kenc)\n    cenc = canonical(cenc)\n\n    penc = []\n    for k_el in kenc:\n        for c_el in cenc:\n            penc.append(cancel(k_el*c_el))\n\n    (mat,uvector) = writeencodingasprod(penc, unknown)\n\n    BigMat = Matrix(mat)\n\n    mk_index = 0\n    ctr = 0\n    for el in uvector:\n        if el == masterkey * special_s:\n            mk_index = ctr\n        ctr += 1\n\n    kern = BigMat.nullspace()\n\n    eqs = []\n    eqsfound = False\n    for vec in kern:\n        if vec[mk_index] != 0:\n            eqsfound = True\n            eqs.append(vec[mk_index])\n    return (eqsfound, eqs)\n</code></pre>"},{"location":"reference/#proof_generation.construct_benc_mats","title":"<code>construct_benc_mats(benc, nonlonesub, uvector, kern)</code>","text":"<p>Constructs the matrices for the common variables b implied by mpk.</p> <p>Parameters:</p> Name Type Description Default <code>benc</code> <code>list</code> <p>List of public key encodings.</p> required <code>nonlonesub</code> <code>list</code> <p>List of non-lone variables.</p> required <code>uvector</code> <code>list</code> <p>List of unknown variables.</p> required <code>kern</code> <code>list</code> <p>Kernel.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Matrix for the common variable b.</p> <code>list</code> <p>List of variables not in b.</p> Source code in <code>proof_generation.py</code> <pre><code>def construct_benc_mats(benc, nonlonesub, uvector, kern):\n\"\"\"\n    Constructs the matrices for the common variables b implied by mpk.\n\n    Parameters:\n        benc (list): List of public key encodings.\n        nonlonesub (list): List of non-lone variables.\n        uvector (list): List of unknown variables.\n        kern (list): Kernel.\n\n    Returns:\n        (list): Matrix for the common variable b.\n        (list): List of variables not in b.\n    \"\"\"    \n    benc_mats = []\n    notinit_b = []\n    for bx in benc:\n        bx_not_in_benc = True\n        bmat = [[0 for i in kern] for j in nonlonesub]\n        count = 0\n        for mono in uvector:\n            if type(mono) != int:\n                lis = []\n                recovervars(mono,lis)\n                if bx in lis and len(lis) == 2:\n                    bx_not_in_benc = False\n                    sindex = 1 - lis.index(bx)\n                    svar = lis[sindex]\n                    row_s = nonlonesub.index(svar)\n                    count_kern = 0\n                    for v in kern:\n                        bmat[row_s][count_kern] = v.row(count)[0]\n                        count_kern += 1\n            count += 1\n        if bx_not_in_benc:\n            notinit_b.append(bx)\n        else:  \n            bmat = Matrix(bmat)\n            benc_mats.append((bx,bmat))\n    return (benc_mats, notinit_b)\n</code></pre>"},{"location":"reference/#proof_generation.construct_lone_vects","title":"<code>construct_lone_vects(benc, lonesub, uvector, kern, len_vec)</code>","text":"<p>Constructs the vectors for the lone variables associated with the ciphertext (or key in the case of co-selective security).</p> <p>Parameters:</p> Name Type Description Default <code>benc</code> <code>list</code> <p>List of public key encodings.</p> required <code>lonesub</code> <code>list</code> <p>List of lone variables.</p> required <code>uvector</code> <code>list</code> <p>List of unknown variables.</p> required <code>kern</code> <code>list</code> <p>Kernel.</p> required <code>len_vec</code> <p>Length of vector.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Lone variables vector.</p> Source code in <code>proof_generation.py</code> <pre><code>def construct_lone_vects(benc, lonesub, uvector, kern, len_vec):\n\"\"\"\n    Constructs the vectors for the lone variables associated with the ciphertext\n    (or key in the case of co-selective security).\n\n    Parameters:\n        benc (list): List of public key encodings.\n        lonesub (list): List of lone variables.\n        uvector (list): List of unknown variables.\n        kern (list): Kernel.\n        len_vec: Length of vector.\n\n    Returns:\n        (list): Lone variables vector.\n    \"\"\"    \n    lone_vects = []\n    for slone in lonesub:\n        svec = [0 for i in range(len_vec)]\n        count = 0\n        for mono in uvector:\n            if type(mono) != int:\n                lis = []\n                recovervars(mono,lis)\n                if slone in lis and len(lis) == 1:\n                    row_s = lonesub.index(slone)\n                    for i in range(len(kern)):                  \n                        svec[i] = kern[i].row(count)[0]\n            count += 1\n        svec = Matrix([svec]) #.transpose()\n        lone_vects.append((slone, svec))\n    return lone_vects\n</code></pre>"},{"location":"reference/#proof_generation.determine_non_lone_vars_in_uvector","title":"<code>determine_non_lone_vars_in_uvector(enc, benc, uvector)</code>","text":"<p>Returns a list of non-lone variables that occur in the uvector.</p> <p>Parameters:</p> Name Type Description Default <code>enc</code> <code>list</code> <p>List of encodings.</p> required <code>benc</code> <code>list</code> <p>List of public key encodings.</p> required <code>uvector</code> <code>list</code> <p>List of unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Non-Lone variables in unknown vector.</p> Source code in <code>proof_generation.py</code> <pre><code>def determine_non_lone_vars_in_uvector(enc, benc, uvector):\n\"\"\"\n    Returns a list of non-lone variables that occur in the uvector.\n\n    Parameters:\n        enc (list): List of encodings.\n        benc (list): List of public key encodings.\n        uvector (list): List of unknown variables.\n\n    Returns:\n        (list): Non-Lone variables in unknown vector.\n    \"\"\"    \n    list_non_common_vars = []\n    for mono in uvector:\n        if type(mono) != int:\n            lis = []\n            recovervars(mono,lis)        \n            for x in lis:\n                if not x in benc and not x in list_non_common_vars:\n                    list_non_common_vars.append(x)\n    list_nonlone = []\n    for x in list_non_common_vars:\n        non_lone = False\n        for mono in uvector:\n            if type(mono) != int:\n                lis = []\n                recovervars(mono,lis)\n                if x in lis:\n                    for y in lis:\n                        if y in benc:\n                            non_lone = True\n        list_nonlone.append((x, non_lone))\n    return list_nonlone\n</code></pre>"},{"location":"reference/#proof_generation.extend_mat_and_vec","title":"<code>extend_mat_and_vec(matc, uvectorc, benc, nonlones)</code>","text":"<p>Extends the matrix and uvector with combinations that are not in the encodings.</p> <p>Parameters:</p> Name Type Description Default <code>matc</code> <code>array</code> <p>Input matrix.</p> required <code>uvectorc</code> <code>list</code> <p>List uf unkown variables.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>nonlones</code> <code>list</code> <p>Non-lone variables.</p> required Source code in <code>proof_generation.py</code> <pre><code>def extend_mat_and_vec(matc, uvectorc, benc, nonlones):\n\"\"\"\n    Extends the matrix and uvector with combinations that are not in the encodings.\n\n    Parameters:\n        matc (array): Input matrix.\n        uvectorc (list): List uf unkown variables.\n        benc (list): Public key encodings.\n        nonlones (list): Non-lone variables.\n    \"\"\"    \n    zero_vec = zeros(shape(matc)[0],1)\n    nr_cols = shape(matc)[1]\n    for x_b in benc:\n        for x_c in nonlones:\n            prod = x_b * x_c\n            if not prod in uvectorc:\n                uvectorc.append(prod)\n                matc = matc.col_insert(nr_cols,zero_vec)\n                nr_cols += 1\n    return (matc, uvectorc)\n</code></pre>"},{"location":"reference/#proof_generation.extend_mat_and_vec2","title":"<code>extend_mat_and_vec2(matc, uvectorc, benc, nonlones)</code>","text":"<p>Extends the matrix and uvector with common variables that are not in the encodings</p> <p>Parameters:</p> Name Type Description Default <code>matc</code> <code>array</code> <p>Input matrix.</p> required <code>uvectorc</code> <code>list</code> <p>List uf unkown variables.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>nonlones</code> <code>list</code> <p>Non-lone variables.</p> required Source code in <code>proof_generation.py</code> <pre><code>def extend_mat_and_vec2(matc, uvectorc, benc, nonlones):\n\"\"\"\n    Extends the matrix and uvector with common variables that are not in the encodings\n\n    Parameters:\n        matc (array): Input matrix.\n        uvectorc (list): List uf unkown variables.\n        benc (list): Public key encodings.\n        nonlones (list): Non-lone variables.\n    \"\"\"    \n    zero_vec = zeros(shape(matc)[0],1)\n    nr_cols = shape(matc)[1]\n    spec_s = nonlones[0]\n    for x_b in benc:\n        b_in_uvec = False\n        for x_c in nonlones:\n            prod = x_b * x_c\n            if prod in uvectorc:\n                b_in_uvec = True\n        if not b_in_uvec:\n            uvectorc.append(x_b * spec_s)\n            matc = matc.col_insert(nr_cols,zero_vec)\n            nr_cols += 1\n    return (matc, uvectorc)\n</code></pre>"},{"location":"reference/#proof_generation.generate_proof_co_selective","title":"<code>generate_proof_co_selective(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>Generates an AC17 co-selective proof.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Co-selective proof.</p> Source code in <code>proof_generation.py</code> <pre><code>def generate_proof_co_selective(masterkey, special_s, kenc, cenc, benc, unknown):\n\"\"\"\n    Generates an AC17 co-selective proof.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): Co-selective proof.\n    \"\"\"    \n    output = generate_proof_selective(masterkey, special_s, cenc, kenc, benc, unknown)\n    (benc_mats, rvectors_nonlone, rvectors_lone, svectors_nonlone, svectors_lone) = output\n\n    if benc_mats == None:\n        return output\n\n    benc_mats_new = []\n    for (bx, mat) in benc_mats:\n        mat_new = mat.transpose()\n        benc_mats_new.append((bx, mat_new))\n\n    rvectors_nonlone_new = []\n    for (k, vec) in rvectors_nonlone:\n        vec_new = vec.transpose()\n        rvectors_nonlone_new.append((k, vec_new))\n\n    rvectors_lone_new = []\n    for (k, vec) in rvectors_lone:\n        vec_new = vec.transpose()\n        rvectors_lone_new.append((k, vec_new))\n\n    svectors_nonlone_new = []\n    for (c, vec) in svectors_nonlone:\n        vec_new = vec.transpose()\n        svectors_nonlone_new.append((c, vec_new))\n\n    svectors_lone_new = []\n    for (c, vec) in svectors_lone:\n        vec_new = vec.transpose()\n        svectors_lone_new.append((c, vec_new))\n\n    output = (benc_mats_new, svectors_nonlone_new, svectors_lone_new, rvectors_nonlone_new, rvectors_lone_new)\n    return output\n</code></pre>"},{"location":"reference/#proof_generation.generate_proof_selective","title":"<code>generate_proof_selective(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>Generates an AC17 selective proof.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Selective proof.</p> Source code in <code>proof_generation.py</code> <pre><code>def generate_proof_selective(masterkey, special_s, kenc, cenc, benc, unknown):\n\"\"\"\n    Generates an AC17 selective proof.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): Selective proof.\n    \"\"\"    \n    kenc = canonical(kenc)\n    cenc = canonical(cenc)\n    (matk, uvectork) = writeencodingasprod(kenc, unknown)\n    (matc, uvectorc) = writeencodingasprod(cenc, unknown)\n\n    Mat_k = Matrix(matk)\n    Mat_c = Matrix(matc)\n\n    nonlone_c = determine_non_lone_vars_in_uvector(cenc, benc, uvectorc)\n\n    (sublist_nonlones_c, sublist_lones_c) = sublistslonenonlone(nonlone_c)\n\n    sublist_nonlones_c = put_special_s_first_entry(special_s, sublist_nonlones_c)\n\n    # this can also be run with extend_mat_and_vec but yields larger vectors and matrices\n    (Mat_c, uvectorc) = extend_mat_and_vec2(Mat_c, uvectorc, benc, sublist_nonlones_c)\n\n    kern_c = Mat_c.nullspace()\n\n    if len(kern_c) == 0:\n        # print(\"\\n - No proof found.\\n\")\n        return (None, None, None, None, None)\n    (benc_mats, _) = construct_benc_mats(benc, sublist_nonlones_c, uvectorc, kern_c)\n\n    nonlone_k = determine_non_lone_vars_in_uvector(kenc, benc, uvectork)\n\n    (sublist_nonlones_k, sublist_lones_k) = sublistslonenonlone(nonlone_k)\n\n    bm_sh = shape(benc_mats[0][1])\n    bm_rows = bm_sh[0]\n    bm_columns = bm_sh[1]\n\n    svectors_nonlone = []\n    count = 0\n    for c in sublist_nonlones_c:\n        vec = zeros(1,bm_rows)\n        vec[count] = 1\n        svectors_nonlone.append((c, vec))\n        count += 1\n\n    svectors_lone = construct_lone_vects(benc, sublist_lones_c, uvectorc, kern_c, bm_columns)\n\n    (big_matrix, big_uvector) = merge_matrices(Mat_c, Mat_k, uvectorc, uvectork, sublist_nonlones_c, sublist_nonlones_k)\n    kern_bm = big_matrix.nullspace()\n    if len(kern_bm) == 0:\n        return (None, None, None, None, None)\n\n    kern_vec = select_kern_vec(masterkey, special_s, sublist_nonlones_c, kern_bm, big_uvector)\n\n    rvectors_nonlone = get_nonlone_vecs(kern_vec, kern_c, uvectorc, big_uvector, sublist_nonlones_k)\n    rvectors_lone = get_lone_vecs(kern_vec, big_uvector, sublist_lones_k, sublist_nonlones_c)\n\n    output = (benc_mats, svectors_nonlone, svectors_lone, rvectors_nonlone, rvectors_lone)\n    return output\n</code></pre>"},{"location":"reference/#proof_generation.get_lone_vecs","title":"<code>get_lone_vecs(kern_vec, big_uvector, lones_k, nonlones_c)</code>","text":"<p>Generates the vectors for the lone variables based on the large kernel</p> <p>Parameters:</p> Name Type Description Default <code>kern_vec</code> <code>list</code> <p>Kernel vector.</p> required <code>kern_c</code> <code>list</code> <p>Ciphertext-related kernel.</p> required <code>uvectorc</code> <code>list</code> <p>Unknown variables in ciphertext encodings.</p> required <code>uvectork</code> <code>list</code> <p>Unknown variables in key encodings.</p> required <code>lones_k</code> <code>list</code> <p>Lone key encodings.</p> required <code>nonlones_c</code> <code>list</code> <p>Non-lone ciphertext encodings.</p> required Source code in <code>proof_generation.py</code> <pre><code>def get_lone_vecs(kern_vec, big_uvector, lones_k, nonlones_c):\n\"\"\"\n    Generates the vectors for the lone variables based on the large kernel\n\n    Parameters:\n        kern_vec (list): Kernel vector.\n        kern_c (list): Ciphertext-related kernel.\n        uvectorc (list): Unknown variables in ciphertext encodings.\n        uvectork (list): Unknown variables in key encodings.\n        lones_k (list): Lone key encodings.\n        nonlones_c (list): Non-lone ciphertext encodings.\n    \"\"\"    \n    rvectors_lone = []\n    for l_el in lones_k:\n        rvec = []\n        for nl_el in nonlones_c:\n            prd = l_el * nl_el\n            if prd in big_uvector:\n                ind = big_uvector.index(prd)\n                rvec.append(kern_vec[ind])\n            else:\n                rvec.append(0)\n        rvectors_lone.append((l_el, Matrix(rvec)))\n    return rvectors_lone\n</code></pre>"},{"location":"reference/#proof_generation.get_nonlone_vecs","title":"<code>get_nonlone_vecs(kern_vec, kern_c, uvectorc, big_uvector, nonlones_k)</code>","text":"<p>Generates the vectors for the non-lone variables based on the large kernel</p> <p>Parameters:</p> Name Type Description Default <code>kern_vec</code> <code>list</code> <p>Kernel vector.</p> required <code>kern_c</code> <code>list</code> <p>Ciphertext-related kernel.</p> required <code>uvectorc</code> <code>list</code> <p>Unknown variables in ciphertext encodings.</p> required <code>uvectork</code> <code>list</code> <p>Unknown variables in key encodings.</p> required <code>nonlones_k</code> <code>list</code> <p>Non-lone key encodings.</p> required Source code in <code>proof_generation.py</code> <pre><code>def get_nonlone_vecs(kern_vec, kern_c, uvectorc, big_uvector, nonlones_k):\n\"\"\"\n    Generates the vectors for the non-lone variables based on the large kernel\n\n    Parameters:\n        kern_vec (list): Kernel vector.\n        kern_c (list): Ciphertext-related kernel.\n        uvectorc (list): Unknown variables in ciphertext encodings.\n        uvectork (list): Unknown variables in key encodings.\n        nonlones_k (list): Non-lone key encodings.\n    \"\"\"    \n    rvectors_nonlone = []\n    ctr = 0\n    for nl_el in nonlones_k:\n        sub_vec = []\n        for i in range(ctr, ctr + len(uvectorc)):\n            sub_vec.append(kern_vec[i,0])\n        sub_vec = Matrix(sub_vec)\n\n        new_mat = Matrix([vec.transpose() for vec in kern_c + [sub_vec]]).transpose()\n\n        ns_new_mat = new_mat.nullspace()\n        for ns_vec in ns_new_mat:\n            if ns_vec[-1] != 0:\n                ns_vec2 = [-i/ns_vec[-1] for i in ns_vec[:-1]]\n                rvectors_nonlone.append((nl_el, Matrix(ns_vec2)))\n        ctr += len(uvectorc)\n\n    return rvectors_nonlone\n</code></pre>"},{"location":"reference/#proof_generation.merge_matrices","title":"<code>merge_matrices(matc, matk, uvectorc, uvectork, nonlones_c, nonlones_k)</code>","text":"<p>Merges the matrix for the ciphertext and key encodings.</p> <p>Parameters:</p> Name Type Description Default <code>matc</code> <code>array</code> <p>Ciphertext matrix.</p> required <code>matk</code> <code>array</code> <p>Key matrix.</p> required <code>uvectorc</code> <code>list</code> <p>Unknown variables in ciphertext encodings.</p> required <code>uvectork</code> <code>list</code> <p>Unknown variables in key encodings.</p> required <code>nonlones_c</code> <code>list</code> <p>Non-lone ciphertext encodings.</p> required <code>nonlones_k</code> <code>list</code> <p>Non-lone key encodings.</p> required Source code in <code>proof_generation.py</code> <pre><code>def merge_matrices(matc, matk, uvectorc, uvectork, nonlones_c, nonlones_k):\n\"\"\"\n    Merges the matrix for the ciphertext and key encodings.\n\n    Parameters:\n        matc (array): Ciphertext matrix.\n        matk (array): Key matrix.\n        uvectorc (list): Unknown variables in ciphertext encodings.\n        uvectork (list): Unknown variables in key encodings.\n        nonlones_c (list): Non-lone ciphertext encodings.\n        nonlones_k (list): Non-lone key encodings.\n    \"\"\"    \n    len_nl_c = len(nonlones_c)\n    len_nl_k = len(nonlones_k)\n    matc_rows = shape(matc)[0]\n    matc_cols = shape(matc)[1]\n    matk_rows = shape(matk)[0]\n    matk_cols = shape(matk)[1]\n\n    big_uvectorc = []\n    for x_k in nonlones_k:\n        big_uvectorc += [x_k * i for i in uvectorc]\n\n    big_uvectork = []\n    for x_c in nonlones_c:\n        big_uvectork += [x_c * i for i in uvectork]\n\n    big_uvector = []\n    big_uvector += big_uvectorc\n    for x_u in big_uvectork:\n        if not x_u in big_uvector:\n            big_uvector.append(x_u)\n\n    big_matc = zeros(matc_rows*len_nl_k, matc_cols*len_nl_k)\n    big_matk = zeros(matk_rows*len_nl_c, matk_cols*len_nl_c)\n    ctr = 0\n    for x_k in nonlones_k:\n        for i in range(matc_rows):\n            for j in range(matc_cols):\n                big_matc[i + ctr*matc_rows, j + ctr*matc_cols] += matc[i,j]\n        ctr += 1\n\n    ctr = 0\n    for x_c in nonlones_c:\n        for i in range(matk_rows):\n            for j in range(matk_cols):\n                big_matk[i + ctr*matk_rows, j + ctr*matk_cols] += matk[i,j]\n        ctr += 1\n\n    big_matc_rows = matc_rows*len_nl_k\n    big_matk_rows = matk_rows*len_nl_c\n    big_mat = zeros(big_matc_rows + big_matk_rows, len(big_uvector))\n    i_u = 0\n    for x_u in big_uvector:\n        i = 0\n        for x_c in big_uvectorc:\n            if x_u == x_c:\n                for j in range(big_matc_rows):\n                    big_mat[j,i_u] += big_matc[j,i]\n            i += 1\n\n        i = 0\n        for x_k in big_uvectork:\n            if x_u == x_k:\n                for j in range(big_matk_rows):\n                    big_mat[j + big_matc_rows,i_u] += big_matk[j,i]\n            i += 1\n\n        i_u += 1\n\n    return (big_mat, big_uvector)\n</code></pre>"},{"location":"reference/#proof_generation.normalize_substitutions","title":"<code>normalize_substitutions(masterkey, special_s, proofs)</code>","text":"<p>Ensures that the first entry of the master-key and special non-lone s is 1.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>proofs</code> <code>list</code> <p>List of proofs.</p> required Source code in <code>proof_generation.py</code> <pre><code>def normalize_substitutions(masterkey, special_s, proofs):\n\"\"\"\n    Ensures that the first entry of the master-key and special non-lone s is 1.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        proofs (list): List of proofs.\n    \"\"\"    \n    (benc_mats, svectors_nonlone, svectors_lone, rvectors_nonlone, rvectors_lone) = proofs\n\n    nm_factor_keys = 1\n    nm_factor_ct = 1\n    swap = False\n    init_key = False\n    if rvectors_lone != None:\n        for (k, vec) in rvectors_lone:\n            if k == masterkey:\n                master_key_vec = vec\n                init_key = True\n\n    init_ct = False\n    if svectors_nonlone != None:\n        for (c, vec) in svectors_nonlone:\n            if c == special_s:\n                special_s_vec = vec\n                init_ct = True\n\n    ind = 0\n    if init_key and init_ct:\n        if master_key_vec[0] == 0 or special_s_vec[0] == 0:\n            for i in range(len(master_key_vec)):\n                if master_key_vec[i] != 0 and special_s_vec[i] != 0:\n                    ind = i\n                    swap = True\n                    nm_factor_keys = master_key_vec[i]\n                    nm_factor_ct = special_s_vec[i]\n        else:\n            nm_factor_keys = master_key_vec[0]\n            nm_factor_ct = special_s_vec[0]\n\n        if rvectors_lone != None:\n            ctr_vecs = 0\n            for (k, vec) in rvectors_lone:\n                if swap:\n                    vec = vec.elementary_row_op('n&lt;-&gt;m',0,ind)\n                    rvectors_lone[ctr_vecs] = (k, vec)\n                ctr = 0\n                for entry in vec:\n                    vec[ctr] = simplify(entry/nm_factor_keys)\n                    ctr += 1\n                ctr_vecs+= 1\n\n        if rvectors_nonlone != None:\n            for (k, vec) in rvectors_nonlone:\n                ctr = 0\n                for entry in vec:\n                    vec[ctr] = simplify(entry/nm_factor_keys)\n                    ctr += 1\n\n        if svectors_nonlone != None:\n            ctr_vecs = 0\n            for (c, vec) in svectors_nonlone:\n                if swap:\n                    vec = vec.elementary_col_op('n&lt;-&gt;m',0,ind)\n                    svectors_nonlone[ctr_vecs] = (c, vec)\n                ctr = 0\n                for entry in vec:\n                    vec[ctr] = simplify(entry/nm_factor_ct)\n                    ctr += 1\n                ctr_vecs += 1\n\n        if svectors_lone != None:\n            for (c, vec) in svectors_lone:\n                ctr = 0\n                for entry in vec:\n                    vec[ctr] = simplify(entry/nm_factor_ct)\n                    ctr += 1\n\n        if swap:\n            ctr_rows =  0\n            for (b, mat) in benc_mats:\n                mat = mat.elementary_row_op('n&lt;-&gt;m',0,ind)\n                benc_mats = (b, mat)\n                ctr_rows += 1\n\n    return proofs\n</code></pre>"},{"location":"reference/#proof_generation.put_special_s_first_entry","title":"<code>put_special_s_first_entry(special_s, sublist)</code>","text":"<p>Ensures that the special_s is in the first entry of the sublist.</p> <p>Parameters:</p> Name Type Description Default <code>sublist</code> <code>list</code> <p>Input sublist.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required Source code in <code>proof_generation.py</code> <pre><code>def put_special_s_first_entry(special_s, sublist):\n\"\"\"\n    Ensures that the special_s is in the first entry of the sublist.\n\n    Parameters:\n        sublist (list): Input sublist.\n        special_s (sp.core.list.Symbol): Blinding factor.\n    \"\"\"    \n    ctr = 0\n    entry = 0\n    for x_s in sublist:\n        if x_s == special_s:\n            entry = ctr\n        ctr += 1\n    cpy_first = sublist[0]\n    sublist[0] = special_s\n    sublist[entry] = cpy_first\n    return sublist\n</code></pre>"},{"location":"reference/#proof_generation.select_kern_vec","title":"<code>select_kern_vec(masterkey, special_s, nonlones, kern_bm, big_uvector)</code>","text":"<p>Selects the kern vector that has 1 in the entry corresponding to <code>alpha * s</code> and 0 in all other combinations of alpha and nonlones.   </p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Master key descryption.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>nonlones</code> <code>list</code> <p>Non-lone variables.</p> required <code>kern_bm</code> <code>list</code> <p>Kernel.</p> required <code>big_uvector</code> <code>list</code> <p>Unknown variables.</p> required Source code in <code>proof_generation.py</code> <pre><code>def select_kern_vec(masterkey, special_s, nonlones, kern_bm, big_uvector):\n\"\"\"\n    Selects the kern vector that has 1 in the entry corresponding to `alpha * s`\n    and 0 in all other combinations of alpha and nonlones.   \n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Master key descryption.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        nonlones (list): Non-lone variables.\n        kern_bm (list): Kernel.\n        big_uvector (list): Unknown variables.\n    \"\"\"    \n    sub_kern = []\n    mk_entry = big_uvector.index(masterkey * special_s)\n    null_entries = []\n    for el in [i for i in nonlones if i != special_s]:\n        if masterkey * el in big_uvector:\n            null_entries.append(big_uvector.index(masterkey * el))\n\n    for vec in kern_bm:\n        vec_qualified = (vec[mk_entry] != 0)\n        for en in null_entries:\n            vec_qualified = vec_qualified and (vec[en] == 0)\n        if vec_qualified:\n            sub_kern.append(vec)\n\n    if len(sub_kern) &gt; 0:\n        kern_vec = sub_kern[0]\n        for vec in sub_kern[1:]:\n            kern_vec += vec\n    else: \n        kern_vec = kern_bm[0]\n\n    return kern_vec\n</code></pre>"},{"location":"reference/#proof_generation.sublistslonenonlone","title":"<code>sublistslonenonlone(list_lone_nonlone)</code>","text":"<p>Separates the list of lone and non-lone variables in two sublists.</p> <p>Parameters:</p> Name Type Description Default <code>list_lone_nonlone</code> <code>list</code> <p>List of lone and lone-lone variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of lone variables.</p> <code>list</code> <p>List of non-lone variables.</p> Source code in <code>proof_generation.py</code> <pre><code>def sublistslonenonlone(list_lone_nonlone):\n\"\"\"\n    Separates the list of lone and non-lone variables in two sublists.\n\n    Parameters:\n        list_lone_nonlone (list): List of lone and lone-lone variables.\n\n    Returns:\n        (list): List of lone variables.\n        (list): List of non-lone variables.\n    \"\"\"    \n    sublist_nonlones = []\n    sublist_lones = []\n    for (c,nonlone) in list_lone_nonlone:\n        if nonlone:\n            sublist_nonlones.append(c)\n        else: \n            sublist_lones.append(c)\n    return (sublist_nonlones, sublist_lones)\n</code></pre>"},{"location":"reference/#methods-for-proof-verification","title":"Methods for proof verification","text":""},{"location":"reference/#proof_verification.enhanced_symbolic_property","title":"<code>enhanced_symbolic_property(masterkey, kenc, cenc, benc, proofs)</code>","text":"<p>Checks if the additional requirements of the enhanced symbolic property hold.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>proofs</code> <code>list</code> <p>Proofs elements.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Analysis result.</p> Source code in <code>proof_verification.py</code> <pre><code>def enhanced_symbolic_property(masterkey, kenc, cenc, benc, proofs):\n\"\"\"\n    Checks if the additional requirements of the enhanced symbolic property hold.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        proofs (list): Proofs elements.\n\n    Returns:\n        (bool): Analysis result.\n    \"\"\"    \n    (benc_mats, svectors_nonlone, svectors_lone, rvectors_nonlone, rvectors_lone) = proofs\n    k_nonlone = []\n    for (k,_) in rvectors_nonlone:\n        k_nonlone.append(k)\n    c_nonlone = []\n    for (c,_) in svectors_nonlone:\n        c_nonlone.append(c)\n    substitutions = rvectors_nonlone + rvectors_lone + benc_mats + svectors_nonlone + svectors_lone\n\n    for (k, vec) in rvectors_lone:\n        if k == masterkey:\n            masterkey_vec = vec.transpose()\n\n    enhanced_s_p = True\n\n    # first check\n    masterkey_correct_form = (masterkey_vec[0] != 0)\n    for el in masterkey_vec[1:]:\n        if el != 0: \n            masterkey_correct_form = False\n    if not masterkey_correct_form:\n        print(\"\\n The master key is not of the correct form.\\n\")\n\n    enhanced_s_p = enhanced_s_p and masterkey_correct_form\n\n    # second check TODO\n\n    # third check TODO\n\n    # fourth check\n    nl_i_r = nonlones_independent(rvectors_nonlone)\n    nl_i_s = nonlones_independent(svectors_nonlone)\n    if not nl_i_r:\n        print(\"\\n The non-lone key variables are not linearly independent. \\n\")\n    if not nl_i_s:\n        print(\"\\n The non-lone ciphertext variables are not linearly independent. \\n\")\n\n    enhanced_s_p = enhanced_s_p and nl_i_r and nl_i_s\n\n    if enhanced_s_p:\n        return True\n</code></pre>"},{"location":"reference/#proof_verification.eval_poly","title":"<code>eval_poly(is_key_encoding, poly, substitutions, benc)</code>","text":"<p>Evaluates the given encoding polynomial with the substituted values.</p> <p>Parameters:</p> Name Type Description Default <code>is_key_encoding</code> <code>bool</code> <p>If it is a key encoding.</p> required <code>poly</code> <code>list</code> <p>Polynomial.</p> required <code>substitutions</code> <code>list</code> <p>Substituded values.</p> required <code>benc</code> <code>list</code> <p>List of public key encodings.  </p> required <p>Returns:</p> Type Description <code>list</code> <p>Polynomial evaluation.</p> Source code in <code>proof_verification.py</code> <pre><code>def eval_poly(is_key_encoding, poly, substitutions, benc):\n\"\"\"\n    Evaluates the given encoding polynomial with the substituted values.\n\n    Parameters:\n        is_key_encoding (bool): If it is a key encoding.\n        poly (list): Polynomial.\n        substitutions (list): Substituded values.\n        benc (list): List of public key encodings.  \n    Returns:\n        (list): Polynomial evaluation.\n    \"\"\" \n    sub_args = []\n    for (arg, _) in substitutions:\n        sub_args.append(arg)\n\n    if poly.func == Mul:\n        lis_var = []\n        mono_args = list(poly.args)\n        mono_args = reorder_mono_args(mono_args, sub_args, benc, is_key_encoding)\n        for var in mono_args:\n            if var in sub_args:\n                ind = sub_args.index(var)\n                lis_var.append(substitutions[ind][1])\n            else: \n                lis_var.append(var)\n        subs_mono = prod(lis_var) #.transpose()\n        return subs_mono\n    else:\n        new_poly = []\n        for mono in poly.args:\n            if mono.func == Mul:\n                lis_var = []\n                mono_args = list(mono.args)\n                mono_args = reorder_mono_args(mono_args, sub_args, benc, is_key_encoding)\n                for var in mono_args:\n                    if var in sub_args:\n                        ind = sub_args.index(var)\n                        lis_var.append(substitutions[ind][1])\n                    else: \n                        lis_var.append(var)\n                subs_mono = prod(lis_var) #.transpose()\n            else:\n                if mono in sub_args:\n                    ind = sub_args.index(mono)\n                    subs_mono = substitutions[ind][1]\n                else:\n                    subs_mono = mono\n            new_poly.append(subs_mono)\n        sum_poly = new_poly[0]\n        for mono in new_poly[1:]:\n            sum_poly = sum_poly + mono\n        return sum_poly\n</code></pre>"},{"location":"reference/#proof_verification.is_poly","title":"<code>is_poly(entry, benc, lones)</code>","text":"<p>Helper function to determine whether the encoding is a polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>sp.core.list.Symbol</code> <p>Entry to analyze.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>lones</code> <code>list</code> <p>List of lone encodings.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result.</p> Source code in <code>proof_verification.py</code> <pre><code>def is_poly(entry, benc, lones):\n\"\"\"\n    Helper function to determine whether the encoding is a polynomial.\n\n    Parameters:\n        entry (sp.core.list.Symbol): Entry to analyze.\n        benc (list): Public key encodings.\n        lones (list): List of lone encodings.\n\n    Returns:\n        (bool): Result.\n    \"\"\"  \n    lone_args = []\n    for (lone_var, _) in lones:\n        lone_args.append(lone_var)\n\n    is_polynomial = False\n    if type(entry) != int:\n        lis = []\n        recovervars(entry, lis)\n        for var in lis:\n            if var in benc or var in lone_args:\n                is_polynomial = True\n    return is_polynomial\n</code></pre>"},{"location":"reference/#proof_verification.nonlones_independent","title":"<code>nonlones_independent(list_of_nonlones)</code>","text":"<p>Checks if the non-lone variables are linearly independent or not.</p> <p>Parameters:</p> Name Type Description Default <code>list_of_nonlones</code> <code>list</code> <p>List of non-lone variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result.</p> Source code in <code>proof_verification.py</code> <pre><code>def nonlones_independent(list_of_nonlones):\n\"\"\"\n    Checks if the non-lone variables are linearly independent or not.\n\n    Parameters:\n        list_of_nonlones (list): List of non-lone variables.\n\n    Returns:\n        (bool): Result.\n    \"\"\" \n    nonlone_vects = []\n    for (_,vec) in list_of_nonlones:\n        if shape(vec)[0] &gt; 1:\n            vec = vec.transpose()\n        nonlone_vects.append(vec)\n    mat = Matrix(nonlone_vects)\n    rs = mat.rowspace()\n    if shape(mat)[0] == len(rs):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/#proof_verification.reorder_mono_args","title":"<code>reorder_mono_args(mono_args, sub_args, benc, is_key_encoding)</code>","text":"<p>Helper function to ensure that the product of vector and matrix is done in  the right order.</p> <p>Parameters:</p> Name Type Description Default <code>mono_args</code> <code>list</code> <p>List of monomials.</p> required <code>sub_args</code> <code>list</code> <p>Substituded values.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>is_key_encoding</code> <code>bool</code> <p>If it is a key encoding.      </p> required <p>Returns:</p> Type Description <code>list</code> <p>Ordered product of vector and matrix.</p> Source code in <code>proof_verification.py</code> <pre><code>def reorder_mono_args(mono_args, sub_args, benc, is_key_encoding):\n\"\"\"\n    Helper function to ensure that the product of vector and matrix is done in \n    the right order.\n\n    Parameters:\n        mono_args (list): List of monomials.\n        sub_args (list): Substituded values.\n        benc (list): Public key encodings.\n        is_key_encoding (bool): If it is a key encoding.      \n    Returns:\n        (list): Ordered product of vector and matrix.\n    \"\"\" \n    first_sub = 0\n    second_sub = 0\n    ctr = 0\n    ctr_i = 0\n    for arg in mono_args:\n        if arg in sub_args:\n            if ctr == 0:\n                first_sub = (ctr_i, arg)\n                ctr += 1\n            else: \n                second_sub = (ctr_i, arg)\n        ctr_i += 1\n\n    if is_key_encoding:\n        if second_sub in benc:\n            mono_args[first_sub[0]] = second_sub[1]\n            mono_args[second_sub[0]] = first_sub[1]\n    else: \n        if first_sub[1] in benc:\n            mono_args[first_sub[0]] = second_sub[1]\n            mono_args[second_sub[0]] = first_sub[1]\n    return mono_args\n</code></pre>"},{"location":"reference/#proof_verification.verify_collusion_security_only","title":"<code>verify_collusion_security_only(masterkey, special_s, kenc, cenc, benc, proofs)</code>","text":"<p>Verifies the security against collusion by inspecting the security proofs generated by the proving functionality - the vectors for the master key  and special_s should be (1,0,...,0).</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>proofs</code> <code>list</code> <p>Proof elements.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Verification result.</p> <code>str</code> <p>Process log.</p> Source code in <code>proof_verification.py</code> <pre><code>def verify_collusion_security_only(masterkey, special_s, kenc, cenc, benc, proofs):\n\"\"\"\n    Verifies the security against collusion by inspecting the security proofs\n    generated by the proving functionality - the vectors for the master key \n    and special_s should be (1,0,...,0).\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        proofs (list): Proof elements.\n    Returns:\n        (bool): Verification result.\n        (str): Process log.\n    \"\"\" \n    (benc_mats, svectors_nonlone, svectors_lone, rvectors_nonlone, rvectors_lone) = proofs\n    result, process_log = verify_proof(masterkey, special_s, kenc, cenc, benc, proofs)\n    if result:\n        # first check\n        for (k, vec) in rvectors_lone:\n            if k == masterkey:\n                masterkey_vec = vec #.transpose()\n        masterkey_correct_form = (masterkey_vec[0] != 0)\n        for el in masterkey_vec[1:]:\n            if el != 0: \n                masterkey_correct_form = False\n        if not masterkey_correct_form:\n            result = False\n        # second check\n        for (c, vec) in svectors_nonlone:\n            if c == special_s:\n                s_vec = vec #.transpose()\n        s_correct_form = (s_vec[0] != 0)\n        for el in s_vec[1:]:\n            if el != 0: \n                s_correct_form = False\n        if not s_correct_form:\n            result = False\n    return result, process_log\n</code></pre>"},{"location":"reference/#proof_verification.verify_proof","title":"<code>verify_proof(masterkey, special_s, kenc, cenc, benc, proofs)</code>","text":"<p>Checks if the symbolic property holds.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>proofs</code> <code>list</code> <p>List of proofs elements.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Verification result.</p> <code>str</code> <p>Process log.</p> Source code in <code>proof_verification.py</code> <pre><code>def verify_proof(masterkey, special_s, kenc, cenc, benc, proofs):\n\"\"\"\n    Checks if the symbolic property holds.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        proofs (list): List of proofs elements.\n\n    Returns:\n        (bool): Verification result.\n        (str): Process log.\n    \"\"\"   \n\n    process_log = []\n\n    (benc_mats, svectors_nonlone, svectors_lone, rvectors_nonlone, rvectors_lone) = proofs\n\n    k_nonlone = []\n    for (k,_) in rvectors_nonlone:\n        k_nonlone.append(k)\n    c_nonlone = []\n    for (c,_) in svectors_nonlone:\n        c_nonlone.append(c)\n    substitutions = rvectors_nonlone + rvectors_lone + benc_mats + svectors_nonlone + svectors_lone\n\n    masterkey_given = False\n    masterkey_vec = rvectors_lone[0][1] #.transpose()\n    for (k, vec) in rvectors_lone:\n        if k == masterkey:\n            masterkey_vec = vec #.transpose()\n            masterkey_given = True\n    special_s_given = False\n    special_s_vec = svectors_nonlone[0][1]\n    for (c, vec) in svectors_nonlone:\n        if c == special_s:\n            special_s_vec = vec\n            special_s_given = True\n\n    verifies_correctly = True\n\n    if special_s_vec * masterkey_vec == Matrix([[0]]) or not masterkey_given or not special_s_given:\n        verifies_correctly = False\n        #print(\"\\n The proof does not verify correctly, because masterkey * special_s = \" + str(masterkey) + \" * \" + str(special_s) + \" = 0. \\n\")\n        process_log.append(\"\\n The proof does not verify correctly, because masterkey * special_s = \" + str(masterkey) + \" * \" + str(special_s) + \" = 0. \\n\")\n\n    for k in kenc:\n        if len(k.args) &gt; 1:\n            if is_poly(k, benc, rvectors_lone):\n                evaluated = cancel(eval_poly(True, k, substitutions, benc))\n                all_zero = zeros(shape(evaluated)[0], shape(evaluated)[1])\n                if evaluated != all_zero:\n                    #print(\"\\n The proof does not verify correctly, because \", k, \"!= 0 \\n\")\n                    process_log.append(\"\\n The proof does not verify correctly, because \" + str(k) + \" != 0 \\n\")\n                    verifies_correctly = False\n\n    for c in cenc:\n        if len(c.args) &gt; 1:\n            if is_poly(c, benc, svectors_lone):\n                evaluated = cancel(eval_poly(False, c, substitutions, benc))\n                all_zero = zeros(shape(evaluated)[0], shape(evaluated)[1])\n                if evaluated != all_zero:\n                    #print(\"\\n The proof does not verify correctly, because \", c, \"!= 0 \\n\")\n                    process_log.append(\"\\n The proof does not verify correctly, because \" + str(c) + \" != 0 \\n\")\n                    verifies_correctly = False\n\n    # if verifies_correctly:\n    #     print(\"\\n The following symbolic property proof verifies correctly. \\n\")\n    return verifies_correctly, '\\n'.join(process_log)\n</code></pre>"},{"location":"reference/#methods-for-checking-if-an-abe-scheme-is-correct-according-to-the-ac17-framework","title":"Methods for checking if an ABE scheme is correct according to the AC17 framework","text":""},{"location":"reference/#ac17_correctness_checks.all_enc_contains_no_fractions","title":"<code>all_enc_contains_no_fractions(kenc, cenc, unknown)</code>","text":"<p>This function determines whether the key and ciphertext encodings contains  no fractions. It returns True if the encodings contains no fractions.</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Analysis result.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def all_enc_contains_no_fractions(kenc, cenc, unknown):\n\"\"\"\n    This function determines whether the key and ciphertext encodings contains \n    no fractions. It returns True if the encodings contains no fractions.\n\n    Parameters:\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Analysis result. \n    \"\"\"  \n    bool_1 = enc_contains_no_fractions(kenc, unknown)\n    bool_2 = enc_contains_no_fractions(cenc, unknown)\n    return bool_1 and bool_2\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.blinding_value_correct_form","title":"<code>blinding_value_correct_form(blindingval, kenc, cenc, benc, unknown)</code>","text":"<p>This function determines whether the blinding value is of the form alpha * s</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Analysis result.</p> <code>Symbol</code> <p>alpha.</p> <code>Symbol</code> <p>special_s.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def blinding_value_correct_form(blindingval, kenc, cenc, benc, unknown):\n\"\"\"\n    This function determines whether the blinding value is of the form alpha * s\n\n    Parameters:\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Analysis result.\n        (Symbol): alpha.\n        (Symbol): special_s.\n    \"\"\"    \n    uvector = []\n    writepolyasprod(blindingval,uvector,unknown)\n    if len(uvector) &gt; 1 or len(uvector) == 0:\n        return (False, None, None)\n\n    lis_bv_vars = []\n    recovervars(uvector[0], lis_bv_vars)\n\n    if len(lis_bv_vars) != 2:\n        return (False, None, None)\n\n    bv_1 = lis_bv_vars[0]\n    bv_2 = lis_bv_vars[1]\n\n    lis_vars_kenc = recover_list_enc_vars(kenc, benc, unknown)\n    lis_vars_cenc = recover_list_enc_vars(cenc, benc, unknown)\n\n    is_correct_form = False\n    if bv_1 in lis_vars_kenc and bv_2 in lis_vars_cenc:\n        is_correct_form = True\n        alpha = bv_1\n        special_s = bv_2\n    if bv_1 in lis_vars_cenc and bv_2 in lis_vars_kenc:\n        is_correct_form = True\n        alpha = bv_2\n        special_s = bv_1\n\n    if is_correct_form:\n        return (True, alpha, special_s)\n    else:\n        return (False, None, None)\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.cenc_correct_form","title":"<code>cenc_correct_form(cenc, benc, unknown)</code>","text":"<p>Checks correctness of the ciphertext encoding.</p> <p>Parameters:</p> Name Type Description Default <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>function</code> <p>enc_correct_form.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def cenc_correct_form(cenc, benc, unknown):\n\"\"\"\n    Checks correctness of the ciphertext encoding.\n\n    Parameters:\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (function): enc_correct_form.\n    \"\"\"    \n    return enc_correct_form(cenc, benc, unknown, \"ciphertext\")\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.correct_form","title":"<code>correct_form(kenc, cenc, benc, unknown)</code>","text":"<p>Main function that calls the correctness checks for the AC17 form.</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Analysis result.</p> <code>list</code> <p>Key encodings.</p> <code>list</code> <p>Ciphertext encodings.</p> <code>str</code> <p>Process log.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def correct_form(kenc, cenc, benc, unknown):\n\"\"\"\n    Main function that calls the correctness checks for the AC17 form.\n\n    Parameters:\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): Analysis result.\n        (list): Key encodings.\n        (list): Ciphertext encodings.\n        (str): Process log.\n    \"\"\"    \n\n    process_log = []\n\n    (result_k, message_k, kenc) = kenc_correct_form(kenc, benc, unknown)\n    (result_c, message_c, cenc) = cenc_correct_form(cenc, benc, unknown)\n    if result_k and result_c:\n        #print(\"\\n The pair encoding scheme satisfies the AC17 form. \" + message_k + message_c + \"\\n\")\n        process_log.append(\"\\n The pair encoding scheme satisfies the AC17 form. \" + message_k + message_c + \"\\n\")\n        return (True, kenc, cenc, '\\n'.join(process_log))\n    else:\n        #print(\"\\n The pair encoding scheme does not satisfy the AC17 form, because \\n\")\n        process_log.append(\"\\n The pair encoding scheme does not satisfy the AC17 form, because \\n\")\n        if not result_k:\n            #print(message_k)\n            process_log.append(message_k)\n        if not result_c:\n            #print(message_c)\n            process_log.append(message_c)\n        return (False, None, None, '\\n'.join(process_log))\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.correct_form_silent","title":"<code>correct_form_silent(kenc, cenc, benc, unknown)</code>","text":"<p>The same as the correct_form function, without system messages.</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Analysis result.</p> <code>list</code> <p>Key encodings.</p> <code>list</code> <p>Ciphertext encodings.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def correct_form_silent(kenc, cenc, benc, unknown):\n\"\"\"\n    The same as the correct_form function, without system messages.\n\n    Parameters:\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): Analysis result.\n        (list): Key encodings.\n        (list): Ciphertext encodings.\n    \"\"\"    \n    (result_k, message_k, kenc) = kenc_correct_form(kenc, benc, unknown)\n    (result_c, message_c, cenc) = cenc_correct_form(cenc, benc, unknown)\n    if result_k and result_c:\n        return (True, kenc, cenc)\n    else:\n        return (False, None, None)\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.enc_contains_no_fractions","title":"<code>enc_contains_no_fractions(enc, unknown)</code>","text":"<p>This function determines whether the encoding contains no fractions. It returns True if the encodings contains no fractions.</p> <p>Parameters:</p> Name Type Description Default <code>enc</code> <code>list</code> <p>Key or ciphertext encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Analysis result.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def enc_contains_no_fractions(enc, unknown):\n\"\"\"\n    This function determines whether the encoding contains no fractions.\n    It returns True if the encodings contains no fractions.\n\n    Parameters:\n        enc (list): Key or ciphertext encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Analysis result. \n    \"\"\"  \n    enc = canonical(enc)\n\n    denoms = collect_denoms(enc, unknown)\n\n    return len(denoms) == 0\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.enc_correct_form","title":"<code>enc_correct_form(cenc, benc, unknown, mes)</code>","text":"<p>Checks whether the encoding is of the correct form.</p> <p>Parameters:</p> Name Type Description Default <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Analysis result.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def enc_correct_form(cenc, benc, unknown, mes):\n\"\"\"\n    Checks whether the encoding is of the correct form.\n\n    Parameters:\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Analysis result.\n    \"\"\"    \n    cenc = canonical(cenc)\n    s_nonlone = []\n    for c in cenc:\n        uvector = []\n        writepolyasprod(c,uvector,unknown)\n        if len(uvector) == 1:\n            mono = uvector[0]\n            lis = []\n            recovervars(mono, lis)\n            if len(lis) == 1:\n                if type(mono) != int and not mono in benc:\n                    s_nonlone.append(mono)\n\n    lones_in_disguise = []\n    associated_commons = []\n    for c in cenc:\n        uvector = []\n        writepolyasprod(c,uvector,unknown)\n        if len(uvector) &gt; 1: \n            for mono in uvector:\n                if type(mono) != int:\n                    lis = []\n                    recovervars(mono, lis)\n                    is_prod_with_benc = False\n                    for var in lis:\n                        if var in benc:\n                            is_prod_with_benc = True\n                    if is_prod_with_benc:\n                        for var in lis:\n                            if not var in benc and not var in s_nonlone:\n                                lis.remove(var)\n                                if var in lones_in_disguise:\n                                    ind = lones_in_disguise.index(var)\n                                    associated_commons[ind] = merge_lists(lis,associated_commons[ind])\n                                else:\n                                    lones_in_disguise.append(var)\n                                    associated_commons.append(lis)\n\n    message = \"\"\n    replaced = False\n    ctr = 0\n    for var in lones_in_disguise:\n        if len(associated_commons[ctr]) &gt; 1:\n            lones_in_disguise.remove(var)\n            s_nonlone.append(var)\n            message = \"The \" + mes + \" encoding contained non-lone variables that do not occur as a singleton.\\n\"\n        else: \n            ctr2 = 0\n            for c in cenc:\n                cenc[ctr2] = c.subs(var*associated_commons[ctr][0], var)\n                ctr2 += 1\n                replaced = True\n        ctr += 1\n\n    if replaced:\n        message += \"The \" + mes + \" encoding previously contained non-lone variables that act as lone variables. These have now been replaced by lone variables.\"\n\n    return_boolean = True\n\n    for c in cenc:\n        uvector = []\n        writepolyasprod(c,uvector,unknown)\n        for mono in uvector:\n            if type(mono) != int:\n                lis = []\n                recovervars(mono, lis)\n                if len(lis) &gt; 2:\n                    return_boolean = False\n                    message += \"\\t - The \" + mes + \" encoding has monomials with more than two unknown variables \\n\"\n                    # return (False, \"The \" + mes + \" encoding has monomials with more than two unknown variables \\n\", None)\n    for c in cenc:\n        uvector = []\n        writepolyasprod(c,uvector,unknown)\n        if len(uvector) &gt; 1:\n            is_polynomial = False\n            for mono in uvector:\n                if type(mono) != int:\n                    lis = []\n                    recovervars(mono, lis)\n                    for var in lis:\n                        if var in benc:\n                            is_polynomial = True\n            if is_polynomial:\n                for mono in uvector:\n                    if type(mono) != int:\n                        lis = []\n                        recovervars(mono, lis)\n                        if len(lis) == 1:\n                            if lis[0] in s_nonlone:\n                                return_boolean = False\n                                message += \"\\t - The \" + mes +  \" encoding contains non-lone variables that are also used as lone variables \\n\"\n                                # return (False, \"The \" + mes +  \" encoding contains non-lone variables that are also used as lone variables \\n\", None)\n    return(return_boolean, message, cenc)\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.kenc_correct_form","title":"<code>kenc_correct_form(kenc, benc, unknown)</code>","text":"<p>Checks correctness of the key encoding.</p> <p>Parameters:</p> Name Type Description Default <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>function</code> <p>enc_correct_form.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def kenc_correct_form(kenc, benc, unknown):\n\"\"\"\n    Checks correctness of the key encoding.\n\n    Parameters:\n        kenc (list): Key encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (function): enc_correct_form.\n    \"\"\"    \n    return enc_correct_form(kenc, benc, unknown, \"key\")\n</code></pre>"},{"location":"reference/#ac17_correctness_checks.recover_list_enc_vars","title":"<code>recover_list_enc_vars(enc, benc, unknown)</code>","text":"<p>This function makes a list of all variables occurring in enc that do not  occur in benc.</p> <p>Parameters:</p> Name Type Description Default <code>enc</code> <code>list</code> <p>Key or ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>List of variables.</p> Source code in <code>ac17_correctness_checks.py</code> <pre><code>def recover_list_enc_vars(enc, benc, unknown):\n\"\"\"\n    This function makes a list of all variables occurring in enc that do not \n    occur in benc.\n\n    Parameters:\n        enc (list): Key or ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): List of variables.\n    \"\"\"  \n    (_, uvector) = writeencodingasprod(enc, unknown)\n    lis = []\n    for mono in uvector:\n        sub_lis = []\n        recovervars(mono, sub_lis)\n        for var in sub_lis:\n            if not var in benc and not var in lis:\n                lis.append(var)\n    return lis\n</code></pre>"},{"location":"reference/#security-analysis-methods","title":"Security analysis methods","text":""},{"location":"reference/#security_analysis_ac17.security_analysis","title":"<code>security_analysis(masterkey, special_s, kenc, cenc, benc, unknown, controlled, constraints)</code>","text":"<p>This is the main function that performs all steps relevant to the security analysis of a scheme satisfying the AC17 form</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <code>controlled</code> <code>bool</code> <p>Flag</p> required <code>constraints</code> <code>list</code> <p>List of constraints.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The scheme is trivial secure.</p> <code>bool</code> <p>The scheme is collusion secure.</p> <code>str</code> <p>Process log.</p> Source code in <code>security_analysis_ac17.py</code> <pre><code>def security_analysis(masterkey, special_s, kenc, cenc, benc, unknown, controlled, constraints):\n\"\"\"\n    This is the main function that performs all steps relevant to the security analysis of a scheme satisfying the AC17 form\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n        controlled (bool): Flag\n        constraints (list): List of constraints.\n\n    Returns:\n        (bool): The scheme is trivial secure.\n        (bool): The scheme is collusion secure.\n        (str): Process log.\n    \"\"\"    \n\n    analysis_log = []\n    proof_log = []\n\n    (correct, kenc, cenc, ac17_log) = correct_form(kenc, cenc, benc, unknown)\n    analysis_log.append(ac17_log)\n\n    if not correct:\n        #print(\"\\n Security analysis for AC17 schemes cannot be performed.\")\n        analysis_log.append(\"\\n Security analysis for AC17 schemes cannot be performed.\")\n    else:\n        #print(\"\\n Performing security analysis on the following encodings:\\n\")\n        analysis_log.append(\"\\n Performing security analysis on the following encodings:\\n\")\n        #pprint(\"\\t\\tMPK encodings: \\t\\t\\t\" + str(benc) + \"\\n\", use_unicode=True)\n        analysis_log.append(\"\\t\\tMPK encodings: \\t\\t\\t\" + str(benc) + \"\\n\")\n        #pprint(\"\\t\\tKey encodings: \\t\\t\\t\" + str(kenc) + \"\\n\", use_unicode=True)\n        analysis_log.append(\"\\t\\tKey encodings: \\t\\t\\t\" + str(kenc) + \"\\n\")\n        #pprint(\"\\t\\tCiphertext encodings: \\t\" + str(cenc) + \"\\n\", use_unicode=True)\n        analysis_log.append(\"\\t\\tCiphertext encodings: \\t\" + str(cenc) + \"\\n\")\n\n        #print(\"\\n == Performing simple trivial security check.. ==\")\n        analysis_log.append(\"\\n == Performing simple trivial security check.. ==\")\n        trivial_secure, log_trivial_security = verify_trivial_security(masterkey, special_s, kenc, cenc, benc, unknown, controlled, constraints)\n        analysis_log.append(log_trivial_security)\n\n        #print(\"\\n == Performing collusion security checks.. ==\")\n        analysis_log.append(\"\\n == Performing collusion security checks.. ==\")\n        collusion_secure, log = generate_the_proofs_and_check_collusion(masterkey, special_s, kenc, cenc, benc, unknown)\n        analysis_log.append(log)\n\n        log = FABEO_properties(masterkey, special_s, kenc, cenc, benc, unknown)\n        analysis_log.append(log)\n\n        if trivial_secure and collusion_secure: \n            proof_log = generate_the_proofs(masterkey, special_s, kenc, cenc, benc, unknown)\n\n        return (trivial_secure, collusion_secure, '\\n'.join(analysis_log), proof_log)\n</code></pre>"},{"location":"reference/#main-security-proof-methods","title":"Main security proof methods","text":""},{"location":"reference/#doc_security_proof.generate_the_encodings_then_the_proofs","title":"<code>generate_the_encodings_then_the_proofs(masterkey, special_s, benc, kenc_fixed, kenc_att, cenc_fixed, cenc_att, unknown, prefixes, nr_indexed_encodings)</code>","text":"<p>This helper function can generate encodings automatically using the encodings_helper.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>kenc_fixed</code> <code>list</code> <p>Fixed key encodings.</p> required <code>kenc_att</code> <code>list</code> <p>Attribute-dependent key encodings.</p> required <code>cenc_fixed</code> <code>list</code> <p>Fixed ciphertext encodings.</p> required <code>cenc_att</code> <code>list</code> <p>Attribute-dependent ciphertext encodings.</p> required <code>unknown</code> <code>list</code> <p>List of unkonwn variables.</p> required <code>prefixes</code> <code>list</code> <p>Prefixes utilized.</p> required <code>nr_indexed_encodings</code> <code>int</code> <p>Indexed encodings.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Generated proofs.</p> Source code in <code>doc_security_proof.py</code> <pre><code>def generate_the_encodings_then_the_proofs(masterkey, special_s, benc, kenc_fixed, kenc_att, cenc_fixed, cenc_att, unknown, prefixes, nr_indexed_encodings):\n\"\"\"\n    This helper function can generate encodings automatically using the encodings_helper.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        benc (list): Public key encodings.\n        kenc_fixed (list): Fixed key encodings.\n        kenc_att (list): Attribute-dependent key encodings.\n        cenc_fixed (list): Fixed ciphertext encodings.\n        cenc_att (list): Attribute-dependent ciphertext encodings.\n        unknown (list): List of unkonwn variables.\n        prefixes (list): Prefixes utilized.\n        nr_indexed_encodings (int): Indexed encodings.\n\n    Returns:\n        (list): Generated proofs.\n    \"\"\"    \n    att_range_key_1 = [1,3]\n    att_range_ct = [1,2]\n\n    benc = create_b_encoding([], benc, [1,2,3])\n    cenc = create_ciphertext_encoding(cenc_fixed, cenc_att, special_s, att_range_ct, prefixes, nr_indexed_encodings)    \n\n    kenc = create_key_encoding(kenc_fixed, kenc_att, att_range_key_1, prefixes, nr_indexed_encodings, [1])\n    unknown2 = generate_unknown_variable_set(kenc, cenc, benc, att_range_ct, att_range_key_1)\n    unknown = merge_lists(unknown, unknown2)\n\n    generate_the_proofs(masterkey, special_s, kenc, cenc, benc, unknown)\n</code></pre>"},{"location":"reference/#doc_security_proof.generate_the_proofs","title":"<code>generate_the_proofs(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>This function generates the proofs for the given encodings.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>List of unkonwn variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Generated proofs.</p> Source code in <code>doc_security_proof.py</code> <pre><code>def generate_the_proofs(masterkey, special_s, kenc, cenc, benc, unknown):\n\"\"\"\n    This function generates the proofs for the given encodings.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): List of unkonwn variables.\n\n    Returns:\n        (list): Generated proofs.\n    \"\"\"    \n    (correct, kenc, cenc) = correct_form_silent(kenc, cenc, benc, unknown)\n    if correct: \n        print(\"\\n== Generating a security proof for the following encodings: ==\\n\")\n        pprint(\"\\t\\tMPK encodings: \\t\\t\\t\" + str(benc) + \"\\n\", use_unicode=True)\n        pprint(\"\\t\\tKey encodings: \\t\\t\\t\" + str(kenc) + \"\\n\", use_unicode=True)\n        pprint(\"\\t\\tCiphertext encodings: \\t\" + str(cenc) + \"\\n\", use_unicode=True)\n        output = generate_proof_selective(masterkey, special_s, kenc, cenc, benc, unknown)\n        output = normalize_substitutions(masterkey, special_s, output)\n        if output[0] != None:\n            print(\"\\n The selective proof: \\n\")\n            pprint(output, use_unicode=True)\n            result = verify_proof(masterkey, special_s, kenc, cenc, benc, output)\n            if result:\n                print(\"\\n The selective proof verifies correctly. \\n\")\n            else:\n                print(\"\\n [!] The selective proof does *not* verify correctly! \\n\")\n        else:\n            print(\"\\n No selective proof found.\\n\")\n\n        output2 = generate_proof_co_selective(masterkey, special_s, kenc, cenc, benc, unknown)\n        output2 = normalize_substitutions(masterkey, special_s, output2)\n        if output2[0] != None:\n            print(\"\\n The co-selective proof: \\n\")\n            pprint(output2, use_unicode=True)\n            result = verify_proof(masterkey, special_s, kenc, cenc, benc, output2)\n            if result:\n                print(\"\\n The co-selective proof verifies correctly. \\n\")\n            else:\n                print(\"\\n [!] The co-selective proof does *not* verify correctly! \\n\")\n        else:\n            print(\"\\n No co-selective proof found.\\n\")\n</code></pre>"},{"location":"reference/#trivial-security-and-collusion-checks","title":"Trivial security and collusion checks","text":""},{"location":"reference/#doc_trivial_security_and_collusion.analysis_trivial_and_collusion_security","title":"<code>analysis_trivial_and_collusion_security(blindingvalue, kenc, cenc, benc, unknown)</code>","text":"<p>Analyzes the trivial and collusion security of the scheme.</p> <p>Parameters:</p> Name Type Description Default <code>blindingvalue</code> <code>sp.core.list.Symbol</code> <p>Blinding value.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The scheme is trivial secure.</p> <code>bool</code> <p>The scheme is collusion secure.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def analysis_trivial_and_collusion_security(blindingvalue, kenc, cenc, benc, unknown):\n\"\"\"\n    Analyzes the trivial and collusion security of the scheme.\n\n    Parameters:\n        blindingvalue (sp.core.list.Symbol): Blinding value.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): The scheme is trivial secure.\n        (bool): The scheme is collusion secure.\n    \"\"\"    \n    pprint(\"\\t\\tMPK encodings: \\t\\t\\t\" + str(benc) + \"\\n\", use_unicode=True)\n    pprint(\"\\t\\tKey encodings: \\t\\t\\t\" + str(kenc) + \"\\n\", use_unicode=True)\n    pprint(\"\\t\\tCiphertext encodings: \\t\" + str(cenc) + \"\\n\", use_unicode=True)\n\n    trivial_secure = False\n    collusion_secure = False\n\n    print(\"\\n == Performing simple trivial security check.. ==\")\n    (trivial_secure, kern, uvector, target_vector, list_bv_indices) = verify_trivial_security_generalized(blindingvalue, kenc, cenc, benc, unknown)\n    if trivial_secure:\n        print(\"\\n\\t The scheme is probably trivially secure, because there exists a solution for the equations.\")\n    else:\n        print(\"\\n\\t The scheme may not be trivially secure, because no solution could be found.\")\n\n    print(\"\\n == Performing collusion security check.. ==\")\n    collusion_secure = verify_collusion_security_generalized(blindingvalue, kenc, cenc, benc, unknown, kern, uvector, target_vector, list_bv_indices)\n\n    return trivial_secure, collusion_secure\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.generate_the_proofs_and_check_collusion","title":"<code>generate_the_proofs_and_check_collusion(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>Verifies security against collusion of a scheme that satisfies the AC17 form. It uses the security proofs for this, which implies the collusion-security check in the generalized variant of this function.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Collusion analysis result.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def generate_the_proofs_and_check_collusion(masterkey, special_s, kenc, cenc, benc, unknown):\n\"\"\"\n    Verifies security against collusion of a scheme that satisfies the AC17 form.\n    It uses the security proofs for this, which implies the collusion-security check\n    in the generalized variant of this function.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Collusion analysis result.\n    \"\"\"   \n    (correct, kenc, cenc) = correct_form_silent(kenc, cenc, benc, unknown)\n    collusion_secure = False\n    if correct: \n        output = generate_proof_selective(masterkey, special_s, kenc, cenc, benc, unknown)\n        output = normalize_substitutions(masterkey, special_s, output)\n        if output[0] != None:\n            result = verify_collusion_security_only(masterkey, special_s, kenc, cenc, benc, output)\n            if not result:\n                print(\"\\n\\t [!] The scheme is possibly insecure against collusion! \\n\")\n        else:\n            result = False\n            print(\"\\n\\t [!] No selective proof found. The scheme is possibly insecure against collusion! \\n\")\n\n        output2 = generate_proof_co_selective(masterkey, special_s, kenc, cenc, benc, unknown)\n        output2 = normalize_substitutions(masterkey, special_s, output2)\n        if output2[0] != None:\n            result2 = verify_proof(masterkey, special_s, kenc, cenc, benc, output2)\n            if result and result2:\n                print(\"\\n\\t The scheme satisfies our collusion property and is thus secure against collusion. \\n\")\n                collusion_secure = True\n            else:\n                print(\"\\n\\t [!] The scheme is possibly insecure against collusion! \\n\")\n        else: \n            print(\"\\n\\t [!] No co-selective proof found. The scheme is possibly insecure against collusion! \\n\")\n    return collusion_secure\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.obtain_masterkeys","title":"<code>obtain_masterkeys(blindingvalue, kenc, cenc, benc, unknown)</code>","text":"<p>Obtains the master keys from the encodings.</p> <p>Parameters:</p> Name Type Description Default <code>blindingvalue</code> <code>sp.core.list.Symbol</code> <p>What masks the message.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Master keys.</p> <code>list</code> <p>Key encodings.</p> <code>list</code> <p>Ciphertext encodings.</p> <code>list</code> <p>Public key encodings.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def obtain_masterkeys(blindingvalue, kenc, cenc, benc, unknown):\n\"\"\"\n    Obtains the master keys from the encodings.\n\n    Parameters:\n\n        blindingvalue (sp.core.list.Symbol): What masks the message.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (list): Master keys.\n        (list): Key encodings.\n        (list): Ciphertext encodings.\n        (list): Public key encodings.\n    \"\"\" \n    lis_vars_blindingvalue = get_vars_polynomial(blindingvalue)\n    lis_vars_kenc = get_vars_list_polynomials(kenc)\n    lis_vars_cenc = get_vars_list_polynomials(cenc)\n    lis_vars_benc = get_vars_list_polynomials(benc)\n\n    lis_masterkeys = []\n    for elem in lis_vars_blindingvalue:\n        is_unknown = (elem in unknown)\n        in_key = (elem in lis_vars_kenc)\n        not_in_cenc = not (elem in lis_vars_cenc)\n        not_in_benc = not (elem in lis_vars_benc)\n        if is_unknown and in_key and not_in_cenc and not_in_benc:\n            lis_masterkeys.append(elem)\n    return (lis_masterkeys, lis_vars_kenc, lis_vars_cenc, lis_vars_benc)\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.print_transcript_to_trivial_and_collusion_security","title":"<code>print_transcript_to_trivial_and_collusion_security(kern, uvector, target_vector, list_bv_indices, lis_shared_indices_not_bv)</code>","text":"<p>Generates and prints a transcript that proves trivial and collusion security of the scheme.</p> <p>Parameters:</p> Name Type Description Default <code>kern</code> <code>list</code> <p>Kernel.</p> required <code>uvector</code> <code>list</code> <p>Unknown variables vector.</p> required <code>target_vector</code> <code>list</code> <p>Target.</p> required <code>list_bv_indices</code> <code>list</code> <p>Indices.</p> required <code>lis_shared_indices_not_bv</code> <p>Shared indices that are not in bv.</p> required Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def print_transcript_to_trivial_and_collusion_security(kern, uvector, target_vector, list_bv_indices, lis_shared_indices_not_bv):\n\"\"\"\n    Generates and prints a transcript that proves trivial and collusion security of the scheme.\n\n    Parameters:\n        kern (list): Kernel.\n        uvector (list): Unknown variables vector.\n        target_vector (list): Target.\n        list_bv_indices (list): Indices.\n        lis_shared_indices_not_bv: Shared indices that are not in bv.\n    \"\"\"    \n    print(\"\\n\\t Attempting to compute transcript to trivial and collusion security..\")\n\n    kern_short = []\n    for vec in kern:\n        vec_s = []\n        for ind in lis_shared_indices_not_bv:\n            vec_s.append(vec[ind])\n        kern_short.append(vec_s)\n\n    mat_kern_short = Matrix([Matrix(vec).transpose() for vec in kern_short])\n    mks_ns = mat_kern_short.transpose().nullspace()\n\n    if len(mks_ns) == 0:\n        print(\"\\n\\t The system could not find a transcript.\")\n        return False\n\n    kern_red = []\n    for ks_vec in mks_ns:\n        vec = cancel(ks_vec[0]*kern[0])\n        for ind in range(1,len(ks_vec)):\n            vec += cancel(ks_vec[ind]*kern[ind])\n        kern_red.append(vec)\n\n    kern_red2 = []\n    for vec in kern_red:\n        if sum(target_vector[i] * vec[i] for i in range(len(target_vector))) != 0:\n            kern_red2.append(vec)\n\n    if len(kern_red2) == 0:\n        print(\"\\n\\t The system could not find a transcript.\")\n        return False\n\n    kern_vec = cancel(kern_red2[0])\n    for vec in kern_red2[1:]:\n        kern_vec += vec\n\n    print(\"\\n\\t The system found a transcript, so the scheme is trivially secure and secure against collusion.\")\n\n    print(\"\\t Substitutions for the terms associated with the blinding value:\")\n    for ind in list_bv_indices:\n        print(\"\\n\\t\\t - \" + str(uvector[ind]) + \" : \" + str(kern_vec[ind]))\n\n    print(\"\\n\\t Substitutions for the special terms that are shared among keys and are not associated with the blinding value:\")\n    for ind in lis_shared_indices_not_bv:\n        print(\"\\n\\t\\t - \" + str(uvector[ind]) + \" : \" + str(kern_vec[ind]))\n\n    lis_rest_indices = [ind for ind in range(len(uvector)) if not ind in list_bv_indices and not ind in lis_shared_indices_not_bv]\n    print(\"\\n\\t Substitutions for the rest of the terms:\")\n    for ind in lis_rest_indices:\n        print(\"\\n\\t\\t - \" + str(uvector[ind]) + \" : \" + str(kern_vec[ind]))\n    return True\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.reduce_kern","title":"<code>reduce_kern(indices, kern)</code>","text":"<p>Removes all the kernel vectors that are all-zero in the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>list</code> <p>Indices.</p> required <code>kern</code> <code>list</code> <p>Kernel.</p> required <p>Returns:</p> Type Description <code>list</code> <p>New kernel.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def reduce_kern(indices, kern):\n\"\"\"\n    Removes all the kernel vectors that are all-zero in the given indices.\n\n    Parameters:\n\n        indices (list): Indices.\n        kern (list): Kernel.\n\n    Returns:\n        (list): New kernel.\n    \"\"\" \n    new_kern = []\n    for vec in kern:\n        at_least_one_nonzero = False\n        for ind in indices:\n            if vec[ind] != 0:\n                at_least_one_nonzero = True\n        if at_least_one_nonzero:\n            new_kern.append(vec)\n    return new_kern\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.remove_kern_unnecessary_vecs","title":"<code>remove_kern_unnecessary_vecs(bv_indices, shared_indices_not_bv, kern)</code>","text":"<p>Removes all kernel vectors that do not contribute to solution.</p> <p>Parameters:</p> Name Type Description Default <code>bv_indices</code> <code>list</code> <p>Indices.</p> required <code>shared_indices_not_bv</code> <code>list</code> <p>Shared indices.</p> required <code>kern</code> <code>list</code> <p>Kernel.</p> required <p>Returns:</p> Type Description <code>list</code> <p>New kernel.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def remove_kern_unnecessary_vecs(bv_indices, shared_indices_not_bv, kern):\n\"\"\"\n    Removes all kernel vectors that do not contribute to solution.\n\n    Parameters:\n\n        bv_indices (list): Indices.\n        shared_indices_not_bv (list): Shared indices.\n        kern (list): Kernel.\n\n    Returns:\n        (list): New kernel.\n    \"\"\" \n    new_kern = []\n    kern_remainder = []\n    for vec in kern:\n        allzero = True\n        for ind in bv_indices:\n            if vec[ind] != 0:\n                allzero = False\n        if allzero:\n            kern_remainder.append(vec)\n\n    kern_vecs_removed = []\n    for ind in shared_indices_not_bv:\n        non_zeros = []\n        ctr = 0\n        for vec in kern:\n            if vec in kern_remainder and vec[ind] != 0:\n                non_zeros.append(ctr)\n            ctr += 1\n        if len(non_zeros) == 1:\n            if not non_zeros[0] in kern_vecs_removed:\n                kern_vecs_removed.append(non_zeros[0])\n\n    ctr = 0\n    for vec in kern:\n        if not ctr in kern_vecs_removed:\n            new_kern.append(vec)\n        ctr += 1\n    return new_kern\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.verify_collusion_security_generalized","title":"<code>verify_collusion_security_generalized(blindingvalue, kenc, cenc, benc, unknown, kern, uvector, target_vector, list_bv_indices)</code>","text":"<p>Checks whether the scheme is secure against collusion.</p> <p>Parameters:</p> Name Type Description Default <code>blindingvalue</code> <code>sp.core.list.Symbol</code> <p>Blinding value.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <code>kern</code> <code>list</code> <p>Kernel.</p> required <code>uvector</code> <code>list</code> <p>Unknown variables vector.</p> required <code>target_vector</code> <code>list</code> <p>Target.</p> required <code>list_bv_indices</code> <code>list</code> <p>Indices.</p> required Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def verify_collusion_security_generalized(blindingvalue, kenc, cenc, benc, unknown, kern, uvector, target_vector, list_bv_indices):\n\"\"\"\n    Checks whether the scheme is secure against collusion.\n\n    Parameters:\n        blindingvalue (sp.core.list.Symbol): Blinding value.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n        kern (list): Kernel.\n        uvector (list): Unknown variables vector.\n        target_vector (list): Target.\n        list_bv_indices (list): Indices.\n    \"\"\"    \n    (lis_masterkeys, lis_vars_kenc, lis_vars_cenc, lis_vars_benc) = obtain_masterkeys(blindingvalue, kenc, cenc, benc, unknown)\n\n    lis_shared_indices = []\n    for ind in range(len(uvector)):\n        vars_elem = get_vars_polynomial(uvector[ind])\n        is_shared = True\n        for var in vars_elem:\n            if (var in lis_vars_kenc) and not (var in lis_vars_benc) and not (var in lis_masterkeys):\n                is_shared = False\n        if is_shared:\n            lis_shared_indices.append(ind)\n\n    lis_shared_indices_not_bv = [ind for ind in lis_shared_indices if not ind in list_bv_indices]\n\n    kern = reduce_kern(lis_shared_indices, kern)\n\n    kern = remove_kern_unnecessary_vecs(list_bv_indices, lis_shared_indices_not_bv, kern)\n\n    transcript_found = print_transcript_to_trivial_and_collusion_security(kern, uvector, target_vector, list_bv_indices, lis_shared_indices_not_bv)\n\n    if not transcript_found:\n        print(\"\\n\\t If there exists a solution for the previous system of equations such that the following system of equations holds:\")\n        msg = \"\"\n        ctr = 1\n        for ind in lis_shared_indices_not_bv:\n            msg2 = \"\\n\\t\\t (\" + str(ctr + len(list_bv_indices) + 1) + \") \"\n            first = True\n            at_least_one_nonzero = False\n            for ind2 in range(len(kern)):\n                eq_is_zero = False\n                el = cancel(kern[ind2][ind])\n                if not el.is_integer:\n                    eq = \"(\" + str(el) + \")\"\n                    at_least_one_nonzero = True\n                else:\n                    if el != 0:\n                        eq = str(kern[ind2][ind])\n                        at_least_one_nonzero = True\n                    else:\n                        eq_is_zero = True\n\n                if not eq_is_zero:\n                    if not first: \n                        msg2 += \" + c\" + str(ind2) + \"*\" + eq\n                    else: \n                        msg2 += \" c\" + str(ind2) + \"*\" + eq\n                        first = False\n            if at_least_one_nonzero:\n                msg2 += \" = 0,\"\n                msg += msg2\n                ctr += 1\n        print(msg)\n        print(\"\\n\\t then the scheme is secure against collusion. If not, then the scheme may be vulnerable to a collusion attack.\")\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.verify_trivial_security","title":"<code>verify_trivial_security(masterkey, special_s, kenc, cenc, benc, unknown, controlled, constraints)</code>","text":"<p>The first two functions are for the AC17 case . It also verifies the trivial security of a scheme that satisfies the AC17 form.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Sympy expression of the master key.</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding factor.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Trivial security verification.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def verify_trivial_security(masterkey, special_s, kenc, cenc, benc, unknown, controlled, constraints):\n\"\"\"\n    The first two functions are for the AC17 case . It also verifies the trivial\n    security of a scheme that satisfies the AC17 form.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Sympy expression of the master key.\n        special_s (sp.core.list.Symbol): Blinding factor.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Trivial security verification.\n    \"\"\"    \n    (eqsfound, eqs_to_analyze) = check_kernel_products(masterkey, special_s, kenc, cenc, benc, unknown)\n    if not eqsfound:\n        print(\"\\n\\t Failed!\")\n        return False\n    else:\n        at_least_one_nonzero = False\n        for eq in eqs_to_analyze:\n            if eq != 0:\n                at_least_one_nonzero = True\n        print(\"\\n\\t Passed! The security of the scheme depends on whether at least one of the following assumption(s) holds:\")\n        ctr = 1\n        for eq in eqs_to_analyze:\n            if type(eq) != int: \n                print(\"\\n\\t\\t (\" + str(ctr) + \") \" + str(eq) + \" != 0\")\n                ctr += 1\n        if ctr == 1:\n            print(\"\\n\\t\\t None\")\n        return at_least_one_nonzero\n</code></pre>"},{"location":"reference/#doc_trivial_security_and_collusion.verify_trivial_security_generalized","title":"<code>verify_trivial_security_generalized(blindingvalue, kenc, cenc, benc, unknown)</code>","text":"<p>Verifies the trivial security of the scheme. The blinding value is what masks the message.</p> <p>Parameters:</p> Name Type Description Default <code>blindingvalue</code> <code>sp.core.list.Symbol</code> <p>What masks the message.</p> required <code>kenc</code> <code>list</code> <p>Key encodings.</p> required <code>cenc</code> <code>list</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list</code> <p>Public key encodings.</p> required <code>unknown</code> <code>list</code> <p>Unknown variables.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Verification result.</p> Source code in <code>doc_trivial_security_and_collusion.py</code> <pre><code>def verify_trivial_security_generalized(blindingvalue, kenc, cenc, benc, unknown):\n\"\"\"\n    Verifies the trivial security of the scheme. The blinding value is what masks the message.\n\n    Parameters:\n\n        blindingvalue (sp.core.list.Symbol): What masks the message.\n        kenc (list): Key encodings.\n        cenc (list): Ciphertext encodings.\n        benc (list): Public key encodings.\n        unknown (list): Unknown variables.\n\n    Returns:\n        (bool): Verification result.\n    \"\"\"   \n    penc = gen_all_p(kenc, cenc, benc, [])\n    penc = canonical(penc)\n\n    denoms = collect_denoms(penc, unknown)\n    denomprod = denoms_prod(denoms)\n    penc = transform_encoding_list(denomprod, penc)\n    blindingvalue = canonical([cancel(blindingvalue * denomprod)])[0]\n\n    (mat, uvector) = writeencodingasprod(penc, unknown)\n    mat = Matrix(mat)\n\n    luvec1 = len(uvector)\n    target_vector = Matrix([writepolyasprod(blindingvalue, uvector, unknown)])\n    luvec2 = len(uvector)\n    if luvec1 != luvec2:\n        print(\"\\n\\t Passed! The blinding value contains terms that cannot be created with the rest of the ciphertext and the key. However, because of this property, collusion security cannot be verified.\")\n        return (False, None, None, None, None)\n\n    list_bv_indices = []\n    ctr = 0\n    for elem in target_vector:\n        if elem != 0:\n            list_bv_indices.append(ctr)\n        ctr += 1\n\n    kern = mat.nullspace()\n\n    kern_red = []\n    kern_remainder = []\n    for vec in kern:\n        at_least_one_zero = False\n        for ind in list_bv_indices:\n            if vec[ind] != 0:\n                at_least_one_zero = True\n        if at_least_one_zero:\n            kern_red.append(vec)\n        else:\n            kern_remainder.append(vec)\n\n    if len(kern_red) == 0:\n        print(\"\\n\\t Failed!\")\n        return (False, None, None, None, None)\n\n    print(\"\\n\\t If there exists a solution for the following system of equations:\")\n    msg = \"\"\n    ctr = 1\n    ctr2 = 0\n    for ind in range(len(list_bv_indices)):\n        msg2 = \"\\n\\t\\t (\" + str(ctr) + \") \"\n        first = True\n        at_least_one_nonzero = False\n        for ind2 in range(len(kern_red)):\n            eq_is_zero = False\n            el = cancel(kern_red[ind2][list_bv_indices[ind]])\n            if not el.is_integer:\n                eq = \"(\" + str(el) + \")\"\n                at_least_one_nonzero = True\n            else:\n                if el != 0:\n                    eq = str(el)\n                    at_least_one_nonzero = True\n                else:\n                    eq_is_zero = True\n\n            if not eq_is_zero:\n                if not first: \n                    msg2 += \" + c\" + str(ind2) + \"*\" + eq\n                else: \n                    msg2 += \" c\" + str(ind2) + \"*\" + eq\n                    first = False\n        if at_least_one_nonzero:\n            msg2 += \" = \" + \"d\" + str(ctr2) #str(target_vector[list_bv_indices[ind]])\n            msg += msg2\n        else: \n            msg += msg2 + \" 0 = \" + \"d\" + str(ctr2) #+ str(target_vector[list_bv_indices[ind]])\n        ctr += 1\n        ctr2 += 1\n\n    msg2 = \"\\n\\t\\t (\" + str(ctr) + \") \"\n    ctr3 = 0\n    first = True\n    for ind in range(len(list_bv_indices)):\n        if not first:\n            msg2 += \" +\"\n        else:\n            first = False\n        el = target_vector[list_bv_indices[ind]]\n        if not el.is_integer:\n            msg2 += \" d\" + str(ctr3) + \"*(\" + str(el) + \")\"\n        else:\n            msg2 += \" d\" + str(ctr3) + \"*\" + str(el)\n        ctr3 += 1\n    msg2 += \" != 0\"\n    msg += msg2\n\n    print(msg)\n    if len(kern_red) &gt; 1:\n        if len(kern_red) &gt; 2:\n            cstring = \"c0,...,c\" + str(len(kern_red) - 1) + \",\"\n        else:\n            cstring = \"c0,c1,\"\n    else:\n        cstring = \"c0,\"\n\n    if len(list_bv_indices) &gt; 1:\n        if len(list_bv_indices) &gt; 2:\n            dstring = \"d0,...,d\" + str(len(list_bv_indices) - 1)\n        else:\n            dstring = \"d0,d1\"\n    else:\n        dstring = \"d0\"\n\n    print(\"\\n\\t where \" + cstring + dstring + \" denote the coefficients, then the scheme is trivially secure.\")\n\n    kern_red2 = []\n    for vec in kern_red:\n        if sum(target_vector[i] * vec[i] for i in range(len(target_vector))) != 0:\n            kern_red2.append(vec)\n\n    if len(kern_red2) &gt; 0:\n        return (True, kern_red + kern_remainder, uvector, target_vector, list_bv_indices)\n    else:\n        return (False, kern_red + kern_remainder, uvector, target_vector, list_bv_indices)\n</code></pre>"},{"location":"reference/#security-class-for-performing-security-checks-on-abe-schemes","title":"Security class for performing security checks on ABE schemes","text":""},{"location":"reference/#security.SecurityAttack","title":"<code>SecurityAttack</code>","text":"<p>             Bases: <code>Attack</code></p> <p>Analyzes the security of an ABE scheme.</p> <p>Attributes:</p> Name Type Description <code>SOL_MSG</code> <code>str</code> <p>The scheme is secure.</p> <code>NOT_FOUND_MSG</code> <code>str</code> <p>The scheme is insecure.</p> <code>alpha</code> <code>sp.core.list.Symbol</code> <p>Representation of the master key.</p> <code>s</code> <code>sp.core.list.Symbol</code> <p>Representation of the blinding factor.</p> <code>key</code> <code>sp.core.list.Symbol</code> <p>Representation of the master key and blinding factor.</p> <code>is_fractional</code> <code>bool</code> <p>The scheme is fractional.</p> <code>sol</code> <code>string</code> <p>Solution of the attack, if found.</p> <code>k_encodings</code> <code>list</code> <p>List of sp.core.symbol.Symbol types representing the key encodings.</p> <code>c_encodings</code> <code>list</code> <p>List of sp.core.symbol.Symbol types representing the ciphertext components.</p> <code>mpk_encodings</code> <code>list</code> <p>List of sp.core.symbol.Symbol types representing the  master public key components involved in the attack (they could be related to corruption of the authorities). </p> <code>unknown</code> <code>list</code> <p>List of sp.core.symbol.Symbol types representing the  unknown variables.</p> <code>trivial_secure</code> <code>bool</code> <p>The scheme is trivial secure.</p> <code>collusion_secure</code> <code>bool</code> <p>The scheme is collusion secure.</p> Source code in <code>security.py</code> <pre><code>class SecurityAttack(Attack):\n\"\"\"\n        Analyzes the security of an ABE scheme.\n\n        Attributes:\n            SOL_MSG (str): The scheme is secure.\n            NOT_FOUND_MSG (str): The scheme is insecure.\n            alpha (sp.core.list.Symbol): Representation of the master key.\n            s (sp.core.list.Symbol): Representation of the blinding factor.\n            key (sp.core.list.Symbol): Representation of the master key and blinding factor.\n            is_fractional (bool): The scheme is fractional.\n            sol (string): Solution of the attack, if found.\n            k_encodings (list): List of sp.core.symbol.Symbol types representing the key\n                encodings.\n            c_encodings (list): List of sp.core.symbol.Symbol types representing the\n                ciphertext components.\n            mpk_encodings (list): List of sp.core.symbol.Symbol types representing the \n                master public key components involved in the attack (they could be related\n                to corruption of the authorities). \n            unknown (list): List of sp.core.symbol.Symbol types representing the \n                unknown variables.\n            trivial_secure (bool): The scheme is trivial secure.\n            collusion_secure (bool): The scheme is collusion secure.\n        \"\"\"\n\n        SOL_MSG = \"[*] The scheme is secure: \"\n        NOT_FOUND_MSG = \"[!] The scheme is insecure\"\n        alpha = None\n        s = None\n        is_fractional =  None\n        sol = None\n        k_encodings = None\n        c_encodings = None\n        key = None\n        mpk_encodings = None\n        unknown = None\n        trivial_secure = False\n        collusion_secure = False\n        description = \"SecurityAttack\"\n        result_security = None\n        proof_log = None\n\n        def init(self, key, k_encodings, c_encodings, mpk_encodings, unknown) -&gt; None:\n            #self.alpha = alpha\n            #self.s = s\n            self.key = key\n            #self.is_fractional =  is_fractional\n            self.sol = None\n            self.k_encodings = k_encodings\n            self.c_encodings = c_encodings\n            self.mpk_encodings = mpk_encodings\n            self.unknown = unknown\n            self.trivial_secure = False\n            self.collusion_secure = False\n            self.result_security = None\n            self.proof_log = None\n\n        def __init__(self) -&gt; None:\n\"\"\"\n            The constructor for SecurityAttack class. \n            \"\"\"\n            self.alpha = None\n            self.s = None\n            self.key = None\n            self.is_fractional =  None\n            self.sol = None\n            self.k_encodings = None\n            self.c_encodings = None\n            self.mpk_encodings = None\n            self.unknown = None\n            self.trivial_secure = False\n            self.collusion_secure = False\n            self.result_security = None\n            self.proof_log = None\n\n        def show_solution(self) -&gt; str:\n\"\"\"\n            Returns the result of the attack.\n\n            Returns:\n                solution (str): The result of the attack.\n            \"\"\"\n            return self.sol\n\n        def show_proof(self) -&gt; None:\n\"\"\"\n            Returns the result of the proof.\n            \"\"\"\n            # process proof log\n\n            placeholder_1 = \"\\n The selective proof: \\n\"\n            placeholder_2 = \"\\n The co-selective proof: \\n\"\n\n            if self.proof_log:\n                for line in self.proof_log:\n                    if self.proof_log[self.proof_log.index(line) -1] == placeholder_1:\n                        pprint(line, use_unicode=True)\n                    elif self.proof_log[self.proof_log.index(line) -1] == placeholder_2:\n                        pprint(line, use_unicode=True)                    \n                    else:\n                        print(line)\n\n        def show_proof_latex(self) -&gt; None:\n\"\"\"\n            Returns the result of the proof in latex for HTML.\n\n            \"\"\"\n\n            message_log = []\n            header = []\n            post_header = False\n\n            # process proof log\n\n            placeholder_1 = \"\\n The selective proof: \\n\"\n            placeholder_2 = \"\\n The co-selective proof: \\n\"\n\n            if self.proof_log:\n                for line in self.proof_log:\n                    if line == placeholder_1:\n                        break\n                    else:\n                        header.append(line)\n\n            message_log.append(placeholder_1)\n\n            if self.proof_log:\n                for line in self.proof_log:\n                    if self.proof_log[self.proof_log.index(line) -1] == placeholder_1:\n                        post_header = True\n                        message_log.append(\"\\[ \" + latex(line) + \" \\]\")\n                    elif self.proof_log[self.proof_log.index(line) -1] == placeholder_2:\n                        message_log.append(\"\\[ \" + latex(line) + \" \\]\")\n                    else:\n                        if post_header:\n                            message_log.append(line)\n\n            if self.proof_log:\n                return '\\n'.join(message_log), '\\n'.join(header)\n            else:\n                return None, None\n\n        def format_encodings(self) -&gt; None:\n\"\"\"\n            Prints the involved encodings in the given ABE scheme.\n            \"\"\"\n            # TODO\n\n        def set_sol_msg(self, msg: str) -&gt; None:\n\"\"\"\n            Allows to set the found solution message.\n\n            Parameters:\n                msg (str): Message.\n            \"\"\"\n            self.SOL_MSG = msg\n\n        def set_not_found_msg(self, msg: str) -&gt; None:\n\"\"\"\n            Allows to set the not found solution message.\n\n            Parameters:\n                msg (str): Message.\n            \"\"\"\n            self.NOT_FOUND_MSG = msg\n\n\n        def run(self) -&gt; None:\n\"\"\"\n            Analyze the security of the scheme with the supplied\n            ABE scheme parameters.\n            \"\"\"\n\n            # First, we determine the type of scheme.\n            is_fractional = not all_enc_contains_no_fractions(self.k_encodings, self.c_encodings, self.unknown)\n            self.is_fractional = is_fractional\n\n            if not is_fractional:\n\n                # Second, we need to determine alpha and special s.\n                res, alpha, special_s = blinding_value_correct_form(self.key, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown)\n\n                if res:\n                    self.trivial_secure, self.collusion_secure, self.result_security, self.proof_log = security_analysis(alpha, special_s, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown, [], [])\n                else:\n                    self.trivial_secure, self.collusion_secure, self.result_security = analysis_trivial_and_collusion_security(self.key, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown)\n            else:\n                self.trivial_secure, self.collusion_secure, self.result_security = analysis_trivial_and_collusion_security(self.key, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown)\n\n            self.sol = \"NOTE: If the scheme is MA-ABE you might try to run this check with corruption.\\n\\n\"\n            self.sol += str(self.result_security)\n\n\n        def add_corruptable_variable_generic(self, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n            Adds variables that can be obtained by corruption to the unknown variables array.\n\n            Parameters:\n                corr (sp.core.symbol.Symbol): Corruptable variable.\n            \"\"\"\n            if self.unknown is not None:\n                self.unknown = list(filter((corr).__ne__, self.unknown))\n</code></pre>"},{"location":"reference/#security.SecurityAttack.__init__","title":"<code>__init__()</code>","text":"<p>The constructor for SecurityAttack class.</p> Source code in <code>security.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    The constructor for SecurityAttack class. \n    \"\"\"\n    self.alpha = None\n    self.s = None\n    self.key = None\n    self.is_fractional =  None\n    self.sol = None\n    self.k_encodings = None\n    self.c_encodings = None\n    self.mpk_encodings = None\n    self.unknown = None\n    self.trivial_secure = False\n    self.collusion_secure = False\n    self.result_security = None\n    self.proof_log = None\n</code></pre>"},{"location":"reference/#security.SecurityAttack.add_corruptable_variable_generic","title":"<code>add_corruptable_variable_generic(corr)</code>","text":"<p>Adds variables that can be obtained by corruption to the unknown variables array.</p> <p>Parameters:</p> Name Type Description Default <code>corr</code> <code>sp.core.symbol.Symbol</code> <p>Corruptable variable.</p> required Source code in <code>security.py</code> <pre><code>def add_corruptable_variable_generic(self, corr: sp.core.symbol.Symbol) -&gt; None:\n\"\"\"\n    Adds variables that can be obtained by corruption to the unknown variables array.\n\n    Parameters:\n        corr (sp.core.symbol.Symbol): Corruptable variable.\n    \"\"\"\n    if self.unknown is not None:\n        self.unknown = list(filter((corr).__ne__, self.unknown))\n</code></pre>"},{"location":"reference/#security.SecurityAttack.format_encodings","title":"<code>format_encodings()</code>","text":"<p>Prints the involved encodings in the given ABE scheme.</p> Source code in <code>security.py</code> <pre><code>def format_encodings(self) -&gt; None:\n\"\"\"\n    Prints the involved encodings in the given ABE scheme.\n    \"\"\"\n</code></pre>"},{"location":"reference/#security.SecurityAttack.run","title":"<code>run()</code>","text":"<p>Analyze the security of the scheme with the supplied ABE scheme parameters.</p> Source code in <code>security.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    Analyze the security of the scheme with the supplied\n    ABE scheme parameters.\n    \"\"\"\n\n    # First, we determine the type of scheme.\n    is_fractional = not all_enc_contains_no_fractions(self.k_encodings, self.c_encodings, self.unknown)\n    self.is_fractional = is_fractional\n\n    if not is_fractional:\n\n        # Second, we need to determine alpha and special s.\n        res, alpha, special_s = blinding_value_correct_form(self.key, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown)\n\n        if res:\n            self.trivial_secure, self.collusion_secure, self.result_security, self.proof_log = security_analysis(alpha, special_s, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown, [], [])\n        else:\n            self.trivial_secure, self.collusion_secure, self.result_security = analysis_trivial_and_collusion_security(self.key, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown)\n    else:\n        self.trivial_secure, self.collusion_secure, self.result_security = analysis_trivial_and_collusion_security(self.key, self.k_encodings, self.c_encodings, self.mpk_encodings, self.unknown)\n\n    self.sol = \"NOTE: If the scheme is MA-ABE you might try to run this check with corruption.\\n\\n\"\n    self.sol += str(self.result_security)\n</code></pre>"},{"location":"reference/#security.SecurityAttack.set_not_found_msg","title":"<code>set_not_found_msg(msg)</code>","text":"<p>Allows to set the not found solution message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Message.</p> required Source code in <code>security.py</code> <pre><code>def set_not_found_msg(self, msg: str) -&gt; None:\n\"\"\"\n    Allows to set the not found solution message.\n\n    Parameters:\n        msg (str): Message.\n    \"\"\"\n    self.NOT_FOUND_MSG = msg\n</code></pre>"},{"location":"reference/#security.SecurityAttack.set_sol_msg","title":"<code>set_sol_msg(msg)</code>","text":"<p>Allows to set the found solution message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>Message.</p> required Source code in <code>security.py</code> <pre><code>def set_sol_msg(self, msg: str) -&gt; None:\n\"\"\"\n    Allows to set the found solution message.\n\n    Parameters:\n        msg (str): Message.\n    \"\"\"\n    self.SOL_MSG = msg\n</code></pre>"},{"location":"reference/#security.SecurityAttack.show_proof","title":"<code>show_proof()</code>","text":"<p>Returns the result of the proof.</p> Source code in <code>security.py</code> <pre><code>def show_proof(self) -&gt; None:\n\"\"\"\n    Returns the result of the proof.\n    \"\"\"\n    # process proof log\n\n    placeholder_1 = \"\\n The selective proof: \\n\"\n    placeholder_2 = \"\\n The co-selective proof: \\n\"\n\n    if self.proof_log:\n        for line in self.proof_log:\n            if self.proof_log[self.proof_log.index(line) -1] == placeholder_1:\n                pprint(line, use_unicode=True)\n            elif self.proof_log[self.proof_log.index(line) -1] == placeholder_2:\n                pprint(line, use_unicode=True)                    \n            else:\n                print(line)\n</code></pre>"},{"location":"reference/#security.SecurityAttack.show_proof_latex","title":"<code>show_proof_latex()</code>","text":"<p>Returns the result of the proof in latex for HTML.</p> Source code in <code>security.py</code> <pre><code>def show_proof_latex(self) -&gt; None:\n\"\"\"\n    Returns the result of the proof in latex for HTML.\n\n    \"\"\"\n\n    message_log = []\n    header = []\n    post_header = False\n\n    # process proof log\n\n    placeholder_1 = \"\\n The selective proof: \\n\"\n    placeholder_2 = \"\\n The co-selective proof: \\n\"\n\n    if self.proof_log:\n        for line in self.proof_log:\n            if line == placeholder_1:\n                break\n            else:\n                header.append(line)\n\n    message_log.append(placeholder_1)\n\n    if self.proof_log:\n        for line in self.proof_log:\n            if self.proof_log[self.proof_log.index(line) -1] == placeholder_1:\n                post_header = True\n                message_log.append(\"\\[ \" + latex(line) + \" \\]\")\n            elif self.proof_log[self.proof_log.index(line) -1] == placeholder_2:\n                message_log.append(\"\\[ \" + latex(line) + \" \\]\")\n            else:\n                if post_header:\n                    message_log.append(line)\n\n    if self.proof_log:\n        return '\\n'.join(message_log), '\\n'.join(header)\n    else:\n        return None, None\n</code></pre>"},{"location":"reference/#security.SecurityAttack.show_solution","title":"<code>show_solution()</code>","text":"<p>Returns the result of the attack.</p> <p>Returns:</p> Name Type Description <code>solution</code> <code>str</code> <p>The result of the attack.</p> Source code in <code>security.py</code> <pre><code>def show_solution(self) -&gt; str:\n\"\"\"\n    Returns the result of the attack.\n\n    Returns:\n        solution (str): The result of the attack.\n    \"\"\"\n    return self.sol\n</code></pre>"},{"location":"reference/#functions-for-checking-the-fabeo-property","title":"Functions for checking the FABEO property","text":""},{"location":"reference/#doc_FABEO_properties.FABEO_properties","title":"<code>FABEO_properties(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>This is the main function that checks whether the FABEO property is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Master key description</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding value description.</p> required <code>kenc</code> <code>list of sp.core.list.Symbol</code> <p>Key encodings,</p> required <code>cenc</code> <code>list of sp.core.list.Symbol</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list of sp.core.list.Symbol</code> <p>Common variable encodings.</p> required <code>unknown</code> <code>list of sp.core.list.Symbol</code> <p>List of unknown variables.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The result of the checking the FABEO property.</p> Source code in <code>doc_FABEO_properties.py</code> <pre><code>def FABEO_properties(masterkey, special_s, kenc, cenc, benc, unknown) -&gt; str:\n\"\"\"\n    This is the main function that checks whether the FABEO property is satisfied.\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Master key description\n        special_s (sp.core.list.Symbol): Blinding value description.\n        kenc (list of sp.core.list.Symbol): Key encodings,\n        cenc (list of sp.core.list.Symbol): Ciphertext encodings.\n        benc (list of sp.core.list.Symbol): Common variable encodings.\n        unknown (list of sp.core.list.Symbol): List of unknown variables.\n\n    Returns:\n        (str): The result of the checking the FABEO property.\n    \"\"\"\n\n    process_log = []\n\n    (correct, kenc, cenc) = correct_form_silent(kenc, cenc, benc, unknown)\n\n    blindingvalue = masterkey * special_s\n\n    (nonlones_c, nonlones_k, cpolys, kpolys) = determine_nonlones_and_polys(masterkey, special_s, kenc, cenc, benc, unknown)\n\n    penc = compute_products_ac17(kpolys, cpolys, nonlones_k, nonlones_c)\n\n    (mat, uvector) = writeencodingasprod(penc, unknown)\n\n    mat = Matrix(mat)\n\n    target_vector = Matrix([writepolyasprod(blindingvalue, uvector, unknown)])\n\n    list_bv_indices = []\n    ctr = 0\n    for elem in target_vector:\n        if elem != 0:\n            list_bv_indices.append(ctr)\n        ctr += 1\n\n    (lis_masterkeys, lis_vars_kenc, lis_vars_cenc, lis_vars_benc) = obtain_masterkeys(blindingvalue, kenc, cenc, benc, unknown)\n\n    lis_shared_indices = []\n    for ind in range(len(uvector)):\n        vars_elem = get_vars_polynomial(uvector[ind])\n        is_shared = True\n        for var in vars_elem:\n            if (var in lis_vars_kenc) and not (var in lis_vars_benc) and not (var in lis_masterkeys):\n                is_shared = False\n        if is_shared:\n            lis_shared_indices.append(ind)\n\n    lis_shared_indices_not_bv = [ind for ind in lis_shared_indices if not ind in list_bv_indices]\n\n    rs_shared = []\n    for ind in lis_shared_indices:\n        vec = zeros(1,len(uvector))\n        vec[ind] = 1\n        rs_shared.append(vec)\n\n    rank_rs_s = Matrix(rs_shared).rank()\n    mat_rs = mat.rowspace()\n    rank_rs = Matrix(mat_rs).rank()\n\n    rank_both = Matrix(rs_shared + mat_rs).rank()\n\n    if rank_both == rank_rs_s + rank_rs:\n        #print(\"\\t The scheme satisfies the FABEO property and is thus secure against collusion. \\n\")\n        process_log.append(\"\\t The scheme satisfies the FABEO property and is thus secure against collusion. \\n\")\n        process_log += print_transcript_of_FABEO_property(mat, uvector, lis_shared_indices)\n    else:\n        #print(\"\\t The scheme does not satisfy the FABEO property. \\n\")\n        process_log.append(\"\\t The scheme does not satisfy the FABEO property. \\n\")\n\n    return '\\n'.join(process_log)\n</code></pre>"},{"location":"reference/#doc_FABEO_properties.compute_products_ac17","title":"<code>compute_products_ac17(kpolys, cpolys, knons, cnons)</code>","text":"<p>This function computes all products of non-lone variables and encoding polynomials</p> <p>Parameters:</p> Name Type Description Default <code>kpolys</code> <code>list</code> <p>Key encoding polynomial.</p> required <code>cpolys</code> <code>list</code> <p>Ciphertext encoding polynomial.</p> required <code>knons</code> <code>list</code> <p>Key non-lone variables.</p> required <code>cnons</code> <code>list</code> <p>Ciphertext non-lone variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Products.</p> Source code in <code>doc_FABEO_properties.py</code> <pre><code>def compute_products_ac17(kpolys, cpolys, knons, cnons):\n\"\"\"\n    This function computes all products of non-lone variables and encoding polynomials\n\n    Parameters:\n        kpolys (list): Key encoding polynomial.\n        cpolys (list): Ciphertext encoding polynomial.\n        knons (list): Key non-lone variables.\n        cnons (list): Ciphertext non-lone variables.\n\n    Returns:\n        (list): Products.\n    \"\"\"\n\n    prods = []\n    for x_k in knons:\n        for poly_c in cpolys:\n            prods.append(cancel(x_k * poly_c))\n    for x_c in cnons:\n        for poly_k in kpolys:\n            prods.append(cancel(x_c * poly_k))\n    return prods\n</code></pre>"},{"location":"reference/#doc_FABEO_properties.determine_nonlones_and_polys","title":"<code>determine_nonlones_and_polys(masterkey, special_s, kenc, cenc, benc, unknown)</code>","text":"<p>This function determines the non-lone variables and the encoding polynomials</p> <p>Parameters:</p> Name Type Description Default <code>masterkey</code> <code>sp.core.list.Symbol</code> <p>Master key description</p> required <code>special_s</code> <code>sp.core.list.Symbol</code> <p>Blinding value description.</p> required <code>kenc</code> <code>list of sp.core.list.Symbol</code> <p>Key encodings,</p> required <code>cenc</code> <code>list of sp.core.list.Symbol</code> <p>Ciphertext encodings.</p> required <code>benc</code> <code>list of sp.core.list.Symbol</code> <p>Common variable encodings.</p> required <code>unknown</code> <code>list of sp.core.list.Symbol</code> <p>List of unknown variables.</p> required <p>Returns:</p> Type Description <code>list</code> <p>Non-lone ciphertext variables.</p> <code>list</code> <p>Non-lone key variables.</p> <code>list</code> <p>Ciphertext encoding polynomials.</p> <code>list</code> <p>Key encoding polynomials.</p> Source code in <code>doc_FABEO_properties.py</code> <pre><code>def determine_nonlones_and_polys(masterkey, special_s, kenc, cenc, benc, unknown):\n\"\"\"\n    This function determines the non-lone variables and the encoding polynomials\n\n    Parameters:\n        masterkey (sp.core.list.Symbol): Master key description\n        special_s (sp.core.list.Symbol): Blinding value description.\n        kenc (list of sp.core.list.Symbol): Key encodings,\n        cenc (list of sp.core.list.Symbol): Ciphertext encodings.\n        benc (list of sp.core.list.Symbol): Common variable encodings.\n        unknown (list of sp.core.list.Symbol): List of unknown variables.\n\n    Returns:\n        (list): Non-lone ciphertext variables.\n        (list): Non-lone key variables.\n        (list): Ciphertext encoding polynomials.\n        (list): Key encoding polynomials.\n    \"\"\"\n\n\n    (matk, uvectork) = writeencodingasprod(kenc, unknown)\n    (matc, uvectorc) = writeencodingasprod(cenc, unknown)\n\n    matk = Matrix(matk)\n    matc = Matrix(matc)\n\n    nonlone_c = determine_non_lone_vars_in_uvector(cenc, benc, uvectorc)\n\n    (sublist_nonlones_c, sublist_lones_c) = sublistslonenonlone(nonlone_c)\n\n    sublist_nonlones_c = put_special_s_first_entry(special_s, sublist_nonlones_c)\n\n    nonlone_k = determine_non_lone_vars_in_uvector(kenc, benc, uvectork)\n\n    (sublist_nonlones_k, sublist_lones_k) = sublistslonenonlone(nonlone_k)\n\n    kpolys = [k_poly for k_poly in kenc if not k_poly in sublist_nonlones_k]\n    cpolys = [c_poly for c_poly in cenc if not c_poly in sublist_nonlones_c]\n\n    return (sublist_nonlones_c, sublist_nonlones_k, cpolys, kpolys)\n</code></pre>"},{"location":"reference/#doc_FABEO_properties.print_transcript_of_FABEO_property","title":"<code>print_transcript_of_FABEO_property(mat, uvector, lis_shared)</code>","text":"<p>This function generates a transcript that proves that the encodings satisfy the FABEO property.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array</code> <p>Matrix.</p> required <code>uvector</code> <code>list</code> <p>Unknown variables.</p> required <code>lis_shared</code> <code>list</code> <p>Shared variables.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Transcript of FABEO property.</p> Source code in <code>doc_FABEO_properties.py</code> <pre><code>def print_transcript_of_FABEO_property(mat, uvector, lis_shared) -&gt; str:\n\"\"\"\n    This function generates a transcript that proves that the encodings satisfy the FABEO property.\n\n    Parameters:\n        mat (array): Matrix.\n        uvector (list): Unknown variables.\n        lis_shared (list): Shared variables.\n\n    Returns:\n        (str): Transcript of FABEO property.\n    \"\"\"\n    transcript_log = []\n    msg = \"\\t Generating transcript that proves that the FABEO property holds..\"\n    kern = mat.nullspace()\n    kern_short = []\n    for vec in kern:\n        vec_r = []\n        ctr = 0\n        for el in vec:\n            if ctr in lis_shared:\n                vec_r.append(el)\n            ctr += 1\n        kern_short.append(Matrix(vec_r))\n\n    err_sol_not_found = False\n    kern_new = []\n    ctr = 0\n    for ind in lis_shared:\n        vec = zeros(len(lis_shared),1)\n        vec[ctr] = 1\n        ks_new = Matrix([vec1.transpose() for vec1 in kern_short + [vec]]).transpose()\n        kern_ks_new = ks_new.nullspace()\n        sol_found = False\n        for kern_vec in kern_ks_new:\n            if kern_vec[-1] != 0:\n                sol_found = True\n                val = -kern_vec[-1]\n                sol_vec = [entry/val for entry in kern_vec]\n        if sol_found:\n            new_kern_vec_long = kern[0]*sol_vec[0]\n            for ind in range(1,len(kern)):\n                new_kern_vec_long += kern[ind]*sol_vec[ind]\n            kern_new.append(new_kern_vec_long)\n        else:\n            err_sol_not_found = True\n        ctr += 1\n\n    if err_sol_not_found:\n        msg += \"\\n\\t Transcript not found..\"\n        return msg\n\n    msg += \"\\n\\t\\t For the transcript, we use the following reference vector of monomials: \\n\\t\\t\\t\" + str(uvector)\n\n    transcript_log.append(msg)\n\n    ctr = 0\n    for ind in lis_shared:\n        msg = \"\\n\\t\\t The vector with 1 in the entry corresponding to \" + str(uvector[ind])\n        if len(lis_shared) &gt; 2:\n            msg += \" and 0 in the entries corresponding to \" \n        else:\n            msg += \" and 0 in the entry corresponding to \" \n        first = True\n        for ind1 in lis_shared:\n            if ind1 != ind:\n                if not first:\n                    msg += \",\"\n                else:\n                    first = False\n                msg += str(uvector[ind1])\n        msg += \" is: \\n\\t\\t\\t\"\n        msg += str(list(kern_new[ctr]))\n        transcript_log.append(msg)\n        # ideally, str(list(kern_new[ctr])) should be added without casting the vector as a string and list\n        # transcript_log.append(kern_new[ctr]))\n        ctr += 1\n\n    return transcript_log\n</code></pre>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#tools-provided-by-acabella","title":"Tools provided by ACABELLA","text":"<p>ACABELLA provides different tools to analyze the security of ABE schemes:</p>"},{"location":"tools/#acabella-analysis-command-line-tool","title":"ACABELLA analysis command line tool","text":"<p>It receives a JSON input describing an ABE scheme and analyzes its security.</p> <pre><code>[*] ACABELLA cmd tool\nusage: acabella_cmd.py [-h] -a {mk,da,sec,cond,all,comp} -c CONFIG\n\noptions:\n  -h, --help            show this help message and exit\n  -a {mk,da,sec,cond,all,comp}, --analysis {mk,da,sec,cond,all,comp}\n                        Select the type of analysis to perform: mk for master key\n                        attack, da for decryption attack, ac17 for security analysis,\n                        cond for conditional attack, all for performing every\n                        analysis type and comp for only running attacks whenever the\n                        scheme is detected as insecure\n  -c CONFIG, --config CONFIG\n                        Configuration file for the analysis type in ACABELLA JSON\n                        format\n</code></pre> <p>For instance, to look for master-key attacks we can use the following JSON input file:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha + r * b\", \"r\"],\n    \"master_key\": \"alpha\",\n    \"unknown_vars\" :  [\"alpha\", \"b\", \"r\"],\n    \"corruption_model\" : \"CA\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_CA\", \"var\":\"b\" }\n         ],\n    \"MPK_CA\": [\"b\"],\n    \"MSK_CA\": [\"alpha\"],\n    \"MPK_AA\": [],\n    \"MSK_AA\": [],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n} \n</code></pre> <p>An example utilization in this case would be:</p> <pre><code>$ python acabella_cmd.py -a mk -c examples/lxxh16_config json                                                             \n\n[*] ACABELLA cmd tool\n[*] Analyzing scheme...\n\nList of encodings:\n         k0 : alpha + b*r\n         k1 : r\n\nFor the corruption of the Central Authority.\n\nStructure of CA/AAs:\n        Contents of the CA MPK: [b]\n        Contents of the CA MSK: [alpha]\n\nList of variables obtained via corruption:\n        b from MPK_CA\n\n[*] Master key attack with corruption found: 1*k0 + -b*k1\n</code></pre> <p>The <code>comp</code> mode first analyzes the security of the scheme, then according to the result, it can decide to look for existing attacks in the scheme or not.</p>"},{"location":"tools/#abgw-docker-tool","title":"ABGW docker tool","text":"<p>It invokes the ABGW ggm analyzer proposed by [ABGW17] in a docker container and analyzes the inputs provided in <code>solver_inputs</code>.</p> <p>Located at <code>tools/abgw_docker</code>, it invokes the ABGW tool with ABE schemes defined in the <code>solver_inputs</code> directory. Note that the <code>build_and_run.sh</code> script compiles the image defined in the docker file and launch a container image where ABGW is executed.</p> <p>For instance:</p> <pre><code>$ ./build_and_run.sh               \nSending build context to Docker daemon  48.13kB\nStep 1/27 : FROM ubuntu:16.04\n ---&gt; b6f507652425\nStep 2/27 : RUN apt update -y\n ---&gt; Using cache\n ---&gt; 1688783f3dcc\nStep 3/27 : RUN ln -fs /usr/share/zoneinfo/America/New_York /etc/localtime\n ---&gt; Using cache\n ---&gt; 0dbe43f37870\nStep 4/27 : RUN apt-get install -y tzdata\n ---&gt; Using cache\n ---&gt; e3f3790737f4\nStep 5/27 : RUN dpkg-reconfigure --frontend noninteractive tzdata\n ---&gt; Using cache\n ---&gt; e6d34b8176ad\nStep 6/27 : RUN apt-get --assume-yes install software-properties-common\n ---&gt; Using cache\n ---&gt; 9ed00e1180b3\nStep 7/27 : RUN echo \"export GGM_PATH=/root/ggm-symbolic-solver\" &gt;&gt; /etc/bash.bashrc\n ---&gt; Using cache\n ---&gt; c09a02d4d6f1\nStep 8/27 : RUN apt install git vim build-essential sudo python3-dev wget flex bison python3-pip libssl-dev libgmp10 libgmp-dev git openssl -y\n ---&gt; Using cache\n ---&gt; 0107f2df09fb\nStep 9/27 : RUN apt-get install -y curl ocaml ocaml-native-compilers opam libtool libtool-bin libgmp-dev libffi-dev m4 libz-dev libssl-dev camlp4-extra\n ---&gt; Using cache\n ---&gt; 629689e6d19b\nStep 10/27 : WORKDIR /root\n ---&gt; Using cache\n ---&gt; d79f0bee8e6f\nStep 11/27 : RUN git clone https://github.com/miguel-ambrona/ggm-symbolic-solver\n ---&gt; Using cache\n ---&gt; 1a87191dcd28\nStep 12/27 : WORKDIR /root/ggm-symbolic-solver\n ---&gt; Using cache\n ---&gt; d9117f162a43\nStep 13/27 : RUN opam init --yes\n ---&gt; Using cache\n ---&gt; ea83d8958f44\nStep 14/27 : RUN eval `opam config env`\n ---&gt; Using cache\n ---&gt; 3744bac4bc53\nStep 15/27 : RUN opam pin add symbolic-solver . -n --yes\n ---&gt; Using cache\n ---&gt; 57ee5bb1a57a\nStep 16/27 : RUN opam install symbolic-solver --deps-only --yes\n ---&gt; Using cache\n ---&gt; d151dd1a053f\nStep 17/27 : RUN export GGM_PATH=/root/ggm-symbolic-solver/\n ---&gt; Using cache\n ---&gt; fc1963909dd5\nStep 18/27 : RUN apt-add-repository -y ppa:aims/sagemath\n ---&gt; Using cache\n ---&gt; d74a3b71a915\nStep 19/27 : RUN apt-get update -y\n ---&gt; Using cache\n ---&gt; e66d9de8839d\nStep 20/27 : RUN apt-get --assume-yes install sagemath-upstream-binary\n ---&gt; Using cache\n ---&gt; 0dc912223b53\nStep 21/27 : COPY ggm_setup.sh/ .\n ---&gt; Using cache\n ---&gt; 54581c89d3eb\nStep 22/27 : RUN chmod +x ggm_setup.sh\n ---&gt; Using cache\n ---&gt; 99be81b5d1b0\nStep 23/27 : RUN ./ggm_setup.sh\n ---&gt; Using cache\n ---&gt; 2caff98e273d\nStep 24/27 : RUN rm -rf examples/*\n ---&gt; Using cache\n ---&gt; ff8f9b8c477b\nStep 25/27 : COPY solver_inputs/* examples/\n ---&gt; Using cache\n ---&gt; 4df8886f035e\nStep 26/27 : COPY changes/* .\n ---&gt; Using cache\n ---&gt; c62e8b35a2c7\nStep 27/27 : CMD [\"/bin/bash\"]\n ---&gt; Using cache\n ---&gt; eb18b1849e3d\nSuccessfully built eb18b1849e3d\nSuccessfully tagged abeattacks:latest\n\n\n[*] Now run run_examples.py\n\nroot@5f232cb06e7c:~/ggm-symbolic-solver# \nroot@5f232cb06e7c:~/ggm-symbolic-solver# ./run_examples.py \n\nInitialized solver!\n\n./examples/cp_abe_ndcw15.ggm  Complete output:\n[...]\n</code></pre>"},{"location":"tools/#abgw-bridge","title":"ABGW bridge","text":"<p>We also provide a ABGW bridge in our toolset. This bridge translates ACABELLA's JSON format for describing ABE schemes into a valid input to the ABGW tool. This tool then analyzes single-key security in the generic group model.    </p> <p>Located at <code>tools/abgw_bridge</code>, it receives a description   of an ABE scheme written in JSON, for instance, for the YJR13 scheme:    </p> <pre><code>{    \n    \"scheme_id\": \"yjr13\",    \n    \"analysis\": \"abgw\",    \n    \"k\": [\"a * (1 / x1) + x2 * b + r * (b / bp)\", \"r * bp * (1 / x1)\", \"r * b\"],    \n    \"c\": [\"s\", \"s / bp\"],    \n    \"mpk\": [\"bp\"],    \n    \"gp\": [\"b\"],    \n    \"key\" : \"a * s\",    \n    \"unknown_vars\" :  [\"a\", \"r\", \"s\", \"b\", \"bp\"],    \n    \"known_vars\" : [\"x1\", \"x2\"]    \n}    \n</code></pre> <p>It can be used to obtain the corresponding input for ABGW, for instance:</p> <pre><code>$ python abgw_bridge_cmd.py example.json \n[*] ABGW bridge cmd tool\n[!] Processing example.json\n\nparams c1,c2,c3,c4,c5,c6 in Zp.\nvars a,r,s,b,bp in Zp.\nparams x1,x2 in Zp.\n\n\nc1*(a*s/x1 + b*s*x2 + b*r*s/bp) +\nc2*(a*s/(bp*x1) + b*s*x2/bp + b*r*s/bp*bp) +\nc3*(bp*r*s/x1) +\nc4*(r*s/x1) +\nc5*(b*r*s) +\nc6*(b*r*s/bp)\n= a * s.\n\ngo.\n</code></pre>"},{"location":"tools/#acabella-web-application","title":"ACABELLA web application","text":"<p>It provides a web interface for analyzing the security of ABE schemes. The prototype can be launch from tools/acabella_web via flask:</p> <pre><code>#!/bin/sh\n\nflask --app flaskr --debug run\n</code></pre> <p>Note that the requirements listed at <code>tools/acabella_web/requirements.txt</code> must be installed.</p> <p></p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#analyzing-the-security-of-abe-schemes-using-the-ac17-framework","title":"Analyzing the security of ABE schemes using the AC17 framework","text":"<p>TODO</p>"},{"location":"tutorials/#pair-encodings","title":"Pair encodings","text":""},{"location":"tutorials/#the-ac17-framework","title":"The AC17 framework","text":""},{"location":"tutorials/#finding-master-key-attacks-in-abe-schemes","title":"Finding master key attacks in ABE schemes","text":""},{"location":"tutorials/#master-key-attacks-encodings","title":"Master key attacks encodings","text":"<p>TODO</p>"},{"location":"tutorials/#attacking-lxxh16","title":"Attacking LXXH16","text":"<p>The LXXH16 scheme [^1] is a multi-authority ABE scheme for the Cloud, based on five different entities. </p> <p>Note</p> <p>In this section we only describe the variables that are interesting for testing if  we can find a master key attack on the scheme.</p> <ul> <li>CA: It generates the system parameters and the attributes public keys. Register users attribute-authorities and creates a uid and an aid respectively. The CA is not involved in the generation of secret keys related to attributes.</li> </ul> <p>Once the system parameters have been chosen (pairing groups, group generators, etc.),  the CA generates the value  as master key and computes the master public key (MPK) as .</p> <p>The CA will generate a uid  for each user of the system as well as an aid for identifying the AAs involved where aid .</p> <p>In summary, if the CA is corrupted, we could obtain the parameter  and that could perhaps help us in performing a master key attack and obtain the attribute-authority private key .</p> <ul> <li>AA: It manages the attribute generation and secret key sassociated to the attributes.</li> </ul> <p>During the <code>AASetup</code> algorithm each AA i generates a master secret key MSK AA =   and an MPK AA = .</p> <ul> <li>Data owner: It uses MA-ABE to encrypt a plaintext with a certain access policy.</li> <li>User: Identified by the uid generated by the CA. It can decrypt a ciphertext if it can satisfiy the respective access policy.</li> </ul> <p>If they have the right permissions in the system, the can ask secret keys related to attributes that they can use to fuilfill an access policy and decrypt a ciphertext. We focus on those components of the secret keys during the key generation algorithm that are attribute-independent: </p> <p>The AA generates the random value . Then, it obtains the attribute key component  and the component  .</p> <ul> <li>Cloud server: It provides the storage capabilities to deploy the system.</li> </ul>"},{"location":"tutorials/#obtaining-the-involved-encodings","title":"Obtaining the involved encodings","text":"<ul> <li> <p>For the CA, we have the  encoding as  that we rename as  (we use  to describe public key parameters in the scheme). We consider that we can obtain this value via corruption of the CA.</p> </li> <li> <p>Every AA contains the encoding .</p> </li> <li> <p>For every key generated by an AA, the user obtains the encodings: , that we rename as  (we use  to denote random variables associated to keys) and .</p> </li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella","title":"Generating inputs for ACABELLA","text":"<p>Based on the encodings we identified, we can prepare JSON inputs for ACABELLA.</p> <p>We'll start with an input file where corruption is not performed, and where we try to find  based on the available encodings as a normal user:</p> <pre><code>{\n    \"scheme_id\": \"lxhh16\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_i + r * b\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"r\"],\n    \"corruption_model\" : \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_CA\": [\"b\"],\n    \"MPK_AA\": [\"alpha_i\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>Using acabella_cmd will report that no attack was found, via <code>python acabella_cmd.py -a mk -c examples/lxxh16/lxxh16_config_mka_no_corruption.json</code>.</p> <p>However, we can suppose that the CA has been corrupted and that we have obtained the MPK CA encoding, :</p> <pre><code>{\n    \"scheme_id\": \"lxhh16\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_i + r * b\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"r\"],\n    \"corruption_model\" : \"mixed_CA_corr\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_CA\", \"var\":\"b\" }\n         ],\n    \"MPK_CA\": [\"b\"],\n    \"MPK_AA\": [\"alpha_i\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>Note</p> <p>We have chosen the mixed_CA_corr corruption model, that is, a system where multiple AAs and a CA is used. Within this corruption model, we associated the variable b as a variable of the CA (MPK).</p> <p>In this case, the output we obtain from ACABELLA is:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0[i][j] : alpha_i + b*r\n         k1[i][j] : r\n\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: [b]\n        Contents of the AA MPK encodings: [alpha_i]\n\nList of variables obtained via corruption:\n        b from MPK_CA\n\n[*] Master key attack with corruption found: 1*k0[i][j] + -b*k1[i][j]\n</code></pre> <p>and we have obtained a linar combination of key encodings that allow us to recover the master key of the AA.</p>"},{"location":"tutorials/#attacking-mgz19","title":"Attacking MGZ19","text":"<p>The MGZ19 scheme [^2] is a multi-authority ABE scheme that uses multiplies CAs and AAs. We first describe each entity and identify the relevant encodings that we could use in our attack:</p> <ul> <li> <p>The CA generates the system parameters and execute <code>CKeyGen</code>, which generates an identity key  for a user id GID and a set of attributes. Moreover, it generates the parameter r and the component , later used by the attribute authorities. We should keep in mind that we can corrupt the CA and recover the  encoding.</p> </li> <li> <p>Each AA i generates  and  and assign those values to the master secret key of the AA. The MPK pair of the AA is then represented by  and .</p> </li> </ul> <p>For those registers user, the AA i generates secret keys related to attributes  as .</p>"},{"location":"tutorials/#obtaining-the-involved-encodings_1","title":"Obtaining the involved encodings","text":"<ul> <li>The structure of the CA contains the parameter .</li> <li>Each AA contain a MPK with encodings  and , that we rename as  (related to a public key).</li> <li>For ever attribute key generated by an authenticated user, the key-independent part contains the encodings  and .</li> <li>If the corruption of the CA is possible, we could obtain .</li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella_1","title":"Generating inputs for ACABELLA","text":"<p>Let's assume that the CA can be corrupted and that we can obtain  in the following JSON input for ACABELLA:</p> <pre><code>{\n    \"scheme_id\": \"mgz19\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_j + r * b_j\", \"b_j\"],\n    \"master_key\": \"alpha_j\",\n    \"unknown_vars\" :  [\"alpha_j\", \"b_j\", \"r\"],\n    \"corruption_model\" : \"mixed_CA_corr\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_CA\", \"var\":\"r\" }\n         ],\n    \"MPK_CA\": [\"r\"],\n    \"MPK_AA\": [\"alpha_j\", \"b_j\"],\n    \"MPK_vars\": [\"b_j\"],\n    \"GP_vars\": []\n}\n</code></pre> <p>ACABELLA finds an attack to recover the AA master key:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0[i][j] : alpha_j + b_j*r\n         k1[i][j] : b_j\n\nFor the corruption of a Central Authority [i] in a model with several Attribute Authorities [j].\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: [r]\n        Contents of the AA MPK encodings: [alpha_j, b_j]\n\nList of variables obtained via corruption:\n        r from MPK_CA\n\n[*] Master key attack with corruption found: 1*k0[i][j] + -r*k1[i][j]\n</code></pre>"},{"location":"tutorials/#attacking-qlz13","title":"Attacking QLZ13","text":"<p>The QLZ13 scheme [^3] is a multi-authority ABE scheme consisting of only attribute-authorities AAs.</p> <p>During the AA setup algorithm, each authority  generates:</p> <ul> <li>For each attribute managed by the authority , it generates .</li> </ul> <p>Thus, the master public key of the AA is composed of: , , and . The master secret key of the AA consists of: , , and .</p> <p>The users are identified via a global identifier (GID) , generated .</p> <p>During key generation, the  generates random values , . We are interested in the following attribute-independent key components:</p> <ul> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"tutorials/#obtaining-the-involved-encodings_2","title":"Obtaining the involved encodings","text":"<ul> <li>From every AA , we identify the encodings  and , the latter identified by  ( prime, since is related to a public key encoding and we use the letter  for those encodings as a convention). We don't consider the  encoding since it is not attribute-independent.</li> <li>From the key components generated during key generation, we associated the letter  to the user identifier . The  parameter is identified as  and the  parameter as . Random exponents  and  and identified by  and  respectively. Hence, we have the following key encodings: ,  and .</li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella_2","title":"Generating inputs for ACABELLA","text":"<p>In this case, given the absence of CA and the structure of every AA, there is no much we can obtain via corruption. We can then specify all the encodings in a JSON input file for ACABELLA and try to find master key attacks:</p> <pre><code>{\n    \"scheme_id\": \"qlz13\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"alpha_i + r * b + b1 / (x + bp)\", \"r * b - rp * b1\", \"(rp + 1 / (x + bp)) * b1\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"b1\", \"bp\", \"r\", \"rp\", \"x\"],\n    \"corruption_model\" : \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_CA\": [],\n    \"MPK_AA\": [\"alpha_i\", \"bp\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": []\n}\n</code></pre> <p>We finds the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0 : alpha_i + b*r + b1/(bp + x)\n         k1 : b*r - b1*rp\n         k2 : b1*(rp + 1/(bp + x))\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: []\n        Contents of the AA MPK encodings: [alpha_i, bp]\n\n[*] Master key attack found: 1*k0 + -1*k1 + -1*k2\n</code></pre>"},{"location":"tutorials/#attacking-yj12","title":"Attacking YJ12","text":"<p>The MA-ABE YJ12 scheme [^4] consists of a CA and several AAs.</p> <ul> <li> <p>During the <code>Setup</code> algorithm, the CA generates the system parameters and registers AAs and users. Particularly for the users, it generates an UID  and a public key . The <code>OwnerSetup</code> algorithm generates the parameters  and  and obtains the so called  pair consisting of  and . This parameter is sent to every attribute-authority. The CA is fully trusted in the YJ12 scheme.</p> </li> <li> <p>Finally, every AA generates the public key of each attribute it manages. </p> </li> <li> <p>During the key generation algorithm, each AA generates an attribute-independent key part  which is equivalent to .</p> </li> </ul>"},{"location":"tutorials/#obtaining-the-involved-encodings_3","title":"Obtaining the involved encodings","text":"<ul> <li>The CA has generated every public key for the users and contains the parameter u. However it is fully trusted and we don't consider the corruption of the CA.</li> <li>Each AA contains  and , which we rename to   and  respectively.</li> <li>The attribute-independent encodings from key generation are:  and .</li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella_3","title":"Generating inputs for ACABELLA","text":"<p>In this case, the idea is to corrupt one AA  and use the obtained value  to attack another authority , using the mixed AA corruption model. In this case, we can use the following JSON input file:</p> <pre><code>{\n    \"scheme_id\": \"yj12\",\n    \"analysis\": \"master_key\",\n    \"k\": [\"r * b / bp + alpha_i/bp\", \"r\"],\n    \"master_key\": \"alpha_i\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\"],\n    \"corruption_model\" : \"mixed_AA_corr\",\n    \"corruptable_vars\": [ { \"type\":\"MPK_AA\", \"var\":\"b/bp\" }],\n    \"MPK_CA\": [\"r\"],\n    \"MPK_AA\": [\"alpha_i\", \"b/bp\"],\n    \"MPK_vars\": [],\n    \"GP_vars\": [\"b\", \"bp\"]\n}\n</code></pre> <p>which produces the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Master key attack results:\n\n\nList of encodings:\n         k0[i] : alpha_i/bp + b*r/bp\n         k1[i] : r\n         gp : b\n         gp : bp\n\nFor the corruption of an attribute authority AA[j] and attacking an attribute authority AA[i].\n\nStructure of CA/AAs:\n        Contents of the CA MPK encodings: [r]\n        Contents of the AA MPK encodings: [alpha_i, b/bp]\n\nList of variables obtained via the corruption of AA[j]:\n        b/bp from MPK_AA\n\n[*] Master key attack with corruption found: bp*k0[i] + -b*k1[i]\n</code></pre>"},{"location":"tutorials/#advice-on-finding-master-key-attacks-on-schemes","title":"Advice on finding master key attacks on schemes","text":"<ul> <li> <p>We are interested in the attribute-independent key components generated during the key generation algorithm. </p> </li> <li> <p>Schemes adding new capabilities such as traceability and outsourcing are typically prone to errors due to the number of exponents that are generated by the CAs/AAs that are not correctly validated.</p> </li> <li> <p>Sometimes, schemes that can be attacked via corruption are those where the CA generates exponents that are later utilized by AAs. In some cases, the CA can be corrupted and those values obtained and finally used to recover the master key of a AA. This is the case of the MGZ19 scheme.</p> </li> <li> <p>Other times, the CA can kept values that we can use to recover the master key of an AA via a linear combination of encodings. In those cases, it's worth trying to find master key attacks involving the corruption of those values stored by the CA. See for instance the attack against LXXH16.</p> </li> <li> <p>Finally, it is possible to corrupt an attribute-authority  and obtain certain parameter that can enable an attack on a second authority,  and that allow us to recover its master key . See for instance the YJ12 attack.</p> </li> </ul>"},{"location":"tutorials/#finding-decryption-attacks-in-abe-schemes","title":"Finding decryption attacks in ABE schemes","text":"<p>In this section we show, step by step, how to find decryption attacks in  ABE schemes. First, we start by describing the JSON input file that ACABELLA expects for looking for this type of attack.</p>"},{"location":"tutorials/#the-json-input-for-acabella","title":"The JSON input for ACABELLA","text":"<p>XXX:TODO Move section from start.md here</p> <p>In decryption attacks, the MPK value introduces the encodings in the matrix. When using  the AA extended corruption model, this value is equivalent to MPK_AAj. However the MPK_AAj input field is only use for adding descriptive information about the structure of an attribute authority. </p> <p>Note</p> <p>Take into account that both MPK_AAj and MPK_AAi do not insert any additional encoding into the matrix.</p>"},{"location":"tutorials/#attacking-cm14","title":"Attacking CM14","text":"<p>The CM14 scheme [^5] is a multi-authority ABE where there are only distributed AAs and no CA. During Setup, every authority generates a secret key consisting of ,  and for every attribte , . The public key of every authority consists of the tuple ,  and . Every user of the system has an identifier (GID). This identifier is involved in the key components to link them to the user.</p> <p>During key generation, the attribute-independent component is:</p> <ul> <li>  =  </li> </ul> <p>During encryption, the attribute-independent component is .</p>"},{"location":"tutorials/#obtaining-the-involved-encodings_4","title":"Obtaining the involved encodings","text":"<p>To obtain the involved key encodings, we take  and replace the hash of GID by  and add the encoding . Then, we rename  as  and obtain:   as encodings. From the ciphertext encodings, we obtain . And as MPK encodings, we obtain .</p> <p>As unknown variables, we have: , , , .</p>"},{"location":"tutorials/#generating-inputs-for-acabella_4","title":"Generating inputs for ACABELLA","text":"<p>In this case, we can only perform an decryption attack with or without corruption. If we use corruption, we should use the <code>AA_extended</code> corruption model, based on the corruption of an attribute authority where we obtain one of its values (and possibly, key or ciphertext components) and on the use of the recovered parameters to attack an honest attribute authority.</p> <p>Given on the encodings that we have obtained in the past section, we can prepare the following input to ACABELLA for a decryption attack without corruption:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_AAi\": [],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n}\n</code></pre> <p>In this case, the output of ACABELLA is: </p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\n         k0 : (alpha_i + r)/b\n         k1 : r\n         c0 : b*s\n         mpk0 : b\n\nStructure of CA/AAs:\n\n[!] No decryption attack found\n</code></pre> <p>We can also try the AA_extended corruption model. We'll suppose we obtain the  parameter of a corrupted authority , . Then, we'll obtain ciphertext encodings from that authority too. The goal is to attack, using those encodings, a honest authority . We prepare the following input for ACABELLA:</p> <pre><code>{\n    \"scheme_id\": \"cm14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i + r) / b\", \"r\"],\n    \"c\": [\"s * b\", \"s * b2\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"AA_extended\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AAi\", \"var\":\"b2\" }\n         ],\n    \"MPK_AAi\": [\"b2\"],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n}\n</code></pre> <p>ACABELLA finds the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0[i]*c0 : s*(alpha_i + r)\n         k1[i]*c1 : b2*r*s\n         k1[i]*mpk1 : b2*r\n         c0*mpk1 : b*b2*s\n         c1*mpk0 : b*b2*s\n         k[i]0 : (alpha_i + r)/b\n         k[i]1 : r\n         c0 : b*s\n         c1 : b2*s\n         mpk0 : b\n         mpk1 : b2\n\nFor the corruption of an attribute authority AA[i] where c0 and c1 are obtained from different attribute authorities.\n\nStructure of CA/AAs:\n        Master key pair of AA[i]: mpk[i]: [b2]\n        Master key pair of AA[j]: mpk[j]: [b]\n\nList of variables obtained via corruption:\n        b2 from MPK_AAi\n\n[*] Decryption attack found: 1*k0[i]*c0 + -1/b2*k1[i]*c1\n</code></pre>"},{"location":"tutorials/#attacking-po17","title":"Attacking PO17","text":"<p>The PO17 scheme [^6] is a MA-ABE scheme with a similar structure as CM14. It only consists of multiple attribute-authorities AA in a distributed fashion. </p> <ul> <li> <p>During <code>Setup</code>, every attribute authority generates ,  and  (for every supported attribute  as the master secret key tuple MSK. The MPK of every authority consist then on  and .  Moreover, for every attribute , an associated public key is generated as . </p> </li> <li> <p>The key generation component that is attribute-independent is .</p> </li> <li> <p>In the encryption process, the attribute-independent variables correspond to . </p> </li> </ul>"},{"location":"tutorials/#obtaining-the-involved-encodings_5","title":"Obtaining the involved encodings","text":"<p>We rename the key generation component  as  and we  add the corresponding encoding of , . From the ciphertext component, we rename it as . Finally, we also add the MPK corresponding to the attribute authority to the encoding list.</p>"},{"location":"tutorials/#generating-inputs-for-acabella_5","title":"Generating inputs for ACABELLA","text":"<p>We follow the same strategy as with the CM14 [^5] scheme, using the <code>AA_extended</code> corruption model. We create the following JSON input:</p> <pre><code>{\n    \"scheme_id\": \"po17\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"(alpha_i - r) / b\", \"r\"],\n    \"c\": [\"s * b\", \"s * b2\"],\n    \"mpk\": [\"b\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\"],\n    \"corruption_model\": \"AA_extended\",\n    \"corruptable_vars\": [\n        { \"type\":\"MPK_AAi\", \"var\":\"b2\" }\n         ],\n    \"MPK_AAi\": [\"b2\"],\n    \"MPK_AAj\": [\"b\"],\n    \"misc_vars\": []\n}\n</code></pre> <p>and ACABELLA finds the following decryption attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0[i]*c0 : s*(alpha_i - r)\n         k1[i]*c0 : b*r*s\n         k0[i]*mpk0 : alpha_i - r\n         k0[i]*mpk0 : alpha_i - r\n         k1[i]*mpk0 : b*r\n         k1[i]*mpk0 : b*r\n         c0*mpk0 : b**2*s\n         c0*mpk0 : b**2*s\n         k[i]0 : (alpha_i - r)/b\n         k[i]1 : r\n         c0 : b*s\n         mpk0 : b\n         mpk0 : b\n\nFor the corruption of an attribute authority AA[i].\n\nStructure of CA/AAs:\n        Master key pair of AA[i]: mpk[i]: [b]\n\nList of variables obtained via corruption:\n        b from MPK_AAi\n\n[*] Decryption attack found: 1*k0[i]*c0 + 1/b*k1[i]*c0\n</code></pre>"},{"location":"tutorials/#attacking-ndcw15","title":"Attacking NDCW15","text":"<p>The NDCW15 scheme [^7] is a CP-ABE scheme with traceability capabilities to detect illegal key redistribution. </p> <p>During <code>Setup</code>, the master key of the system,  is generated as well  as the corresponding public keys of every attribute in the system and the rest of public parameters ( for instance is relevant to us as it appears in one of the attribute-independent ciphertext components).</p> <p>We are interested in the following key components, that are attribute-independent:</p> <p>for  and .</p> <ul> <li> <p> </p> </li> <li> <p> </p> </li> </ul> <p>where  is known by the user as well as .</p> <p>From <code>Encryption</code>, we are interested in the following ciphertext encodings:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> <p>The user knows the following variables  (sent by the authority),  (generated by the user) and , that is part of one attribute-independent component of the key.</p>"},{"location":"tutorials/#obtaining-the-involved-encodings_6","title":"Obtaining the involved encodings","text":"<p>We rename the known variables by the user as  variables:</p> <ul> <li>  becomes  </li> <li>  becomes  </li> <li>  becomes  </li> </ul> <p>The global parameters are renamed as:</p> <ul> <li>  becomes  </li> <li>  becomes  </li> </ul> <p>Now, the corresponding key encodings are:</p> <ul> <li> </li> <li> </li> </ul> <p>And the corresponding ciphertext encodings are:</p> <ul> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella_6","title":"Generating inputs for ACABELLA","text":"<p>If we try a decryption attack without corruptin with the following input:</p> <pre><code>{\n    \"scheme_id\": \"ndcw15\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha * (1 / (b1 + x3)) + x2 * b2 * (1 / (b1 + x3))\", \"x1\", \"x1 * b1\"],\n    \"c\": [\"s\", \"s * b1\", \"s * b2\"],\n    \"mpk\": [],\n    \"gp\": [\"b1\", \"b2\", \"1\"],\n    \"key\" : \"alpha * s\",\n    \"unknown_vars\" :  [\"alpha\", \"b1\", \"b2\", \"s\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],\n    \"MPK_AAi\": [],\n    \"MPK_AAj\": [],\n    \"misc_vars\": []\n}\n</code></pre> <p>ACABELLA finds a decryption attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0*c0 : s*(alpha/(b1 + x3) + b2*x2/(b1 + x3))\n         k0*c1 : b1*s*(alpha/(b1 + x3) + b2*x2/(b1 + x3))\n         k1*c0 : s*x1\n         k1*c1 : b1*s*x1\n         k1*c2 : b2*s*x1\n         k2*c0 : b1*s*x1\n         k2*c1 : b1**2*s*x1\n         k2*c2 : b1*b2*s*x1\n         c0*gp0 : b1*s\n         c0*gp1 : b2*s\n         c0*gp2 : s\n         c1*gp0 : b1**2*s\n         c1*gp1 : b1*b2*s\n         c1*gp2 : b1*s\n         c2*gp0 : b1*b2*s\n         c2*gp2 : b2*s\n         k1*gp0 : b1*x1\n         k1*gp1 : b2*x1\n         k2*gp2 : b1*x1\n         k0 : alpha/(b1 + x3) + b2*x2/(b1 + x3)\n         k1 : x1\n         k2 : b1*x1\n         c0 : s\n         c1 : b1*s\n         c2 : b2*s\n         gp0 : b1\n         gp1 : b2\n         gp2 : 1\n\n[*] Decryption attack found: k0*c0*x3 + 1*k0*c1 + -x2/x1*k1*c2\n</code></pre>"},{"location":"tutorials/#attacking-yj14","title":"Attacking YJ14","text":"<p>The YJ14 scheme [^8] is a MA-ABE scheme that uses one central authority and several attribute authorities. The CA runs the Setup algorithm and registers users and AAs. The AAs are independents and generate attribute public and secret keys as well as revoke attributes. The scheme is cloud-centered and also consists of a cloud server, data owners (those who encrypt and store ciphertextexts in the cloud) as well as data consumers (or users, those who decrypt ciphertexts if they can fulfill an access policy).</p> <p>During Setup, the CA generates  global master key comprised of , . It also publishes the global system parameters tuple, consisting of , ,  and the hash function . During the user registration functionality, the CA generates  and  and generates the following keys:</p> <p>It sends to the user ,  and a certificate.</p> <p>It also generates an identifier, aid to every AA involved in the system.</p> <p>Each  generates the parameters: ,  and . The AA public key consists of ,  and .</p> <p>We are interested in the following key encodings, which are attribute-independent:</p> <p>where  is generated .</p> <p>Finally, we are interested in the following ciphertext encodings (which are attribute-independent):</p>"},{"location":"tutorials/#obtaining-the-involved-encodings_7","title":"Obtaining the involved encodings","text":"<ul> <li>We identify the  and  encodings that are part of the global parameters. We rename  to  and  to .</li> <li>The user secret key,  parameter, is renamed it as . This parameter is kept secret and distributed in the attribute authorities.</li> <li>The key encodings are then  and .</li> <li>The ciphertext encodings are  and .</li> <li>The unkown variables in this case are <code>[\"alpha_i\", \"b\", \"bp\", \"r\", \"s\", \"x\"]</code>.</li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella_7","title":"Generating inputs for ACABELLA","text":"<p>Given the identified encodings, we can try to find a decryption attack with the following input:</p> <pre><code>{\n    \"scheme_id\": \"yj14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha_i + x * b + r * bp\", \"r\"],\n    \"c\": [\"s\", \"s * bp\"],\n    \"mpk\": [\"b\", \"bp\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"bp\", \"r\", \"s\", \"x\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],    \n    \"MPK_AAi\": [\"alpha_i\", \"x\"],\n    \"MPK_AAj\": [],\n    \"misc_vars\": [\"x\"]\n}\n</code></pre> <p>However, ACABELLA doesn't find an attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k1*c1 : bp*r*s\n         k0 : alpha_i + b*x + bp*r\n         k1 : r\n         c0 : s\n         c1 : bp*s\n         mpk0 : b\n         mpk1 : bp\n\nStructure of CA/AAs:\n\n[!] No decryption attack found\n</code></pre> <p>Every attribute authority in the system contains the user secret key . It could be that having this parameter could enable a decryption attack. In order to check that, we can corrupt an , obtain  and then launch an attack against an honest authority . In this case, we'll use the <code>AA</code> corruption model (there is no CA involved), and we'll obtain the variable  from a corrupted authority:</p> <pre><code>{\n    \"scheme_id\": \"yj14\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha_i + x * b + r * bp\", \"r\"],\n    \"c\": [\"s\", \"s * bp\"],\n    \"mpk\": [\"b\", \"bp\"],\n    \"gp\": [],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"b\", \"bp\", \"r\", \"s\", \"x\"],\n    \"corruption_model\": \"AA\",\n    \"corruptable_vars\": [\n        { \"type\":\"misc\", \"var\":\"x\" }\n         ],    \n    \"MPK_AAi\": [\"alpha_i\", \"x\"],\n    \"MPK_AAj\": [],\n    \"misc_vars\": [\"x\"]\n}\n</code></pre> <p>In this case, ACABELLA shows us how to perform a decryption attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0[i]*c0 : s*(alpha_i + b*x + bp*r)\n         k1[i]*c1 : bp*r*s\n         c0*mpk0 : b*s\n         c1*mpk0 : b*bp*s\n         k[i]0 : alpha_i + b*x + bp*r\n         k[i]1 : r\n         c0 : s\n         c1 : bp*s\n         mpk0 : b\n         mpk1 : bp\n\nFor the corruption of an attribute authority AA[i].\n\nStructure of CA/AAs:\n        Master key pair of AA[i]: mpk[i]: [alpha_i, x]\n\nList of variables obtained via corruption:\n        x from AAi\n\n[*] Decryption attack found: 1*k0[i]*c0 + -1*k1[i]*c1 + -x*c0*mpk0\n</code></pre>"},{"location":"tutorials/#attacking-yjr13","title":"Attacking YJR13","text":"<p>The YJR13 scheme [^9] is a multi-authority scheme that uses a CA and several attribute authorities. The problem of this scheme, as we'll see is that the user knows two exponents that enable it to perform a decryption attack without the need of corruption.</p> <ul> <li>The CA, during <code>Setup</code>, generates  as master key and publshes  as part of the system parameters.</li> <li>During the user registration, the CA generates  and  via  and . In this scheme, the user knows  a well as its uid (used as  in the scheme).</li> <li>The AAs, during <code>Setup</code>, generate ,  and  as secret key and publish as public key: , , .</li> <li>During key generation, the followign attribute-independent components are generated: ,  and  for .</li> <li>We are interested in the following attribute-independent components generated during encryption:  and .</li> </ul>"},{"location":"tutorials/#obtaining-the-involved-encodings_8","title":"Obtaining the involved encodings","text":"<ul> <li>We know that the user has , that we rename as  and , renamed as .</li> <li>The random exponent  is renamed as .</li> <li>The key encodings are then: ,  and .</li> <li>The global parameter , generated by the CA is also involved in our analysis and we rename it as .</li> <li>The MPK triple of every attribute authority i consists of ,  (renamed as ) and , renamed as .</li> <li>The ciphertex-related encodings are  and .</li> </ul>"},{"location":"tutorials/#generating-inputs-for-acabella_8","title":"Generating inputs for ACABELLA","text":"<p>Since the user knows already two exponents in the scheme, we can try to find an attack without corruption using the following input:</p> <pre><code>{\n    \"scheme_id\": \"yjr13\",\n    \"analysis\": \"decryption\",\n    \"k\": [\"alpha_i * (1 / x1) + x2 * b + r * (b / bp)\", \"r * bp * (1 / x1)\", \"r*b\"],\n    \"c\": [\"s\", \"s / bp\"],\n    \"mpk\": [\"bp\"],\n    \"gp\": [\"b\"],\n    \"key\" : \"alpha_i * s\",\n    \"unknown_vars\" :  [\"alpha_i\", \"r\", \"s\", \"b\", \"bp\"],\n    \"corruption_model\": \"NoCorruption\",\n    \"corruptable_vars\": [],    \n    \"MPK_AAi\": [\"alpha_i\", \"bp\"],\n    \"MPK_AAj\": [],\n    \"misc_vars\": [\"x1\", \"x2\"]\n}\n</code></pre> <p>ACABELLA finds the following attack:</p> <pre><code>[*] ACABELLA cmd tool\n\n\n[*] Analyzing scheme...\n\n\n\n[*] Decryption key attack results:\n\nList of encodings:\n         k0*c0 : s*(alpha_i/x1 + b*x2 + b*r/bp)\n         k2*c1 : b*r*s/bp\n         k2*mpk0 : b*bp*r\n         c0*gp0 : b*s\n         c1*gp0 : b*s/bp\n         k1*gp0 : b*bp*r/x1\n         k0 : alpha_i/x1 + b*x2 + b*r/bp\n         k1 : bp*r/x1\n         k2 : b*r\n         c0 : s\n         c1 : s/bp\n         mpk0 : bp\n         gp0 : b\n\nStructure of CA/AAs:\n\n[*] Decryption attack found: k0*c0*x1 + -x1*k2*c1 + -x1*x2*c0*gp0\n</code></pre>"},{"location":"tutorials/#advice-on-finding-decryption-attacks","title":"Advice on finding decryption attacks","text":"<ul> <li>Sometimes, it is possible to corrupt an attribute authority and obtain a variable, that, together with an ciphertext component from the same attribute, allow us to attack an honest attribute authority. See for instance the attack against the CM14 and PO17 schemes.</li> </ul>"},{"location":"tutorials/#references","title":"References","text":"<p>[^1]: Wei Li, Kaiping Xue, Yingjie Xue, and Jianan Hong. Tmacs: a robust and verifiable threshold multi-authority access control system in public cloud storage. IEEE Transactions on Parallel and Distributed Systems, 27(5):1484\u20131496, 2016. doi:10.1109/TPDS.2015.2448095. [^2]: Chuangui Ma, Aijun Ge, and Jie Zhang. Fully secure decentralized ciphertext-policy attribute-based encryption in standard model. In Fuchun Guo, Xinyi Huang, and Moti Yung, editors, Information Security and Cryptology, 427\u2013447. Cham, 2019. Springer International Publishing. [^3]: Huiling Qian, Jiguo Li, and Yichen Zhang. Privacy-preserving decentralized ciphertext-policy attribute-based encryption with fully hidden access structure. In Sihan Qing, Jianying Zhou, and Dongmei Liu, editors, Information and Communications Security, 363\u2013372. Cham, 2013. Springer International Publishing. [^4]: Kan Yang and Xiaohua Jia. Attributed-based access control for multi-authority systems in cloud storage. In 2012 IEEE 32nd International Conference on Distributed Computing Systems, volume, 536\u2013545. 2012. doi:10.1109/ICDCS.2012.42. [^5]: Jianwei Chen and Huadong Ma. Efficient decentralized attribute-based access control for cloud storage with user revocation. In 2014 IEEE International Conference on Communications, ICC 2014, 3782\u20133787. 06 2014. doi:10.1109/ICC.2014.6883910. [^6]: Harsha S. Gardiyawasam Pussewalage and Vladimir A. Oleshchuk. A distributed multi-authority attribute based encryption scheme for secure sharing of personal health records. In Proceedings of the 22nd ACM on Symposium on Access Control Models and Technologies, SACMAT '17 Abstracts, 255\u2013262. New York, NY, USA, 2017. Association for Computing Machinery. URL: https://doi.org/10.1145/3078861.3078880, doi:10.1145/3078861.3078880. [^7]: Jianting Ning, Xiaolei Dong, Zhenfu Cao, and Lifei Wei. Accountable authority ciphertext-policy attribute-based encryption with white-box traceability and public auditing in the cloud. In European Symposium on Research in Computer Security, 270\u2013289. Springer, 2015. [^8]: Kan Yang and Xiaohua Jia. Expressive, efficient, and revocable data access control for multi-authority cloud storage. Parallel and Distributed Systems, IEEE Transactions on, 25:1735\u20131744, 07 2014. doi:10.1109/TPDS.2013.253. [^9]: Kan Yang, Xiaohua Jia, Kui Ren, Bo Zhang, and Ruitao Xie. DAC-MACS: effective data access control for multiauthority cloud storage systems. IEEE Trans. Inf. Forensics Secur., 8(11):1790\u20131801, 2013. URL: https://doi.org/10.1109/TIFS.2013.2279531, doi:10.1109/TIFS.2013.2279531.</p>"}]}